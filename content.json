{"pages":[],"posts":[{"title":"CSS 变量及其应用","text":"基本介绍自定义属性 （有时候也被称作CSS 变量或者级联变量）是由 CSS 作者定义的，它包含的值可以在整个文档中重复使用。由自定义属性标记设定值（比如： **--main-color: black;**），由var() 函数来获取值（比如： color: **var(--main-color)**;）复杂的网站都会有大量的 CSS 代码，通常也会有许多重复的值。举个例子，同样一个颜色值可能在成千上百个地方被使用到，如果这个值发生了变化，需要全局搜索并且一个一个替换（很麻烦哎～）。自定义属性在某个地方存储一个值，然后在其他许多地方引用它。另一个好处是语义化的标识。比如，--main-text-color 会比 #00ff00 更易理解，尤其是这个颜色值在其他上下文中也被使用到。自定义属性受级联的约束，并从其父级继承其值。 与 sass less 变量的区别 sass 命名是$color，less 命名是@color，css 命名是–color。 读取 css 变量，需要使用 val()方法，sass 和 less 可以直接使用。 css 最大优势在于不需要编译，在运行时可以随时修改，同时应用到上下文。缺点是不兼容 ie 浏览器。 基本用法声明一个自定义属性，属性名需要以两个减号（--）开始，属性值则可以是任何有效的 CSS 值。和其他属性一样，自定义属性也是写在规则集之内的，如下： 123element { --main-bg-color: brown;} 注意，规则集所指定的选择器定义了自定义属性的可见作用域。通常的最佳实践是定义在根伪类 :root 下，这样就可以在 HTML 文档的任何地方访问到它了： 123:root { --main-bg-color: brown;} 然而这条规则不是绝对的，如果有理由去限制你的自定义属性，那么就应该限制。***注意：\\*自定义属性名是大小写敏感的，--my-color 和 --My-color 会被认为是两个不同的自定义属性。如前所述，使用一个局部变量时用 var() 函数包裹以表示一个合法的属性值： 123element { background-color: var(--main-bg-color);} 使用自定义属性的第一步我们从这个简单的 CSS 代码开始，它将相同的颜色应用在了不同 class 的元素上： 12345678910111213141516171819202122232425262728293031.one { color: white; background-color: brown; margin: 10px; width: 50px; height: 50px; display: inline-block;}.two { color: white; background-color: black; margin: 10px; width: 150px; height: 70px; display: inline-block;}.three { color: white; background-color: brown; margin: 10px; width: 75px;}.four { color: white; background-color: brown; margin: 10px; width: 100px;}.five { background-color: brown;} 应用在如下 HTML 上： 123456&lt;div&gt; &lt;div class=&quot;one&quot;&gt;1:&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;2: Text &lt;span class=&quot;five&quot;&gt;5 - more text&lt;/span&gt;&lt;/div&gt; &lt;input class=&quot;three&quot; /&gt; &lt;textarea class=&quot;four&quot;&gt;4: Lorem Ipsum&lt;/textarea&gt;&lt;/div&gt; 其呈现是：注意到在 CSS 代码中的重复：背景色 brown 被多处设置。对于一些 CSS 声明，是可以在级联关系更高的位置设置，通过 CSS 继承自然地解决这个重复的问题。但在一般项目中，是不可能通过这样的方式去解决。通过在 :root 伪类上设置自定义属性，然后在整个文档需要的地方使用，可以减少这样的重复性： 12345678910111213141516171819202122232425262728293031323334:root { --main-bg-color: brown;}.one { color: white; background-color: var(--main-bg-color); margin: 10px; width: 50px; height: 50px; display: inline-block;}.two { color: white; background-color: black; margin: 10px; width: 150px; height: 70px; display: inline-block;}.three { color: white; background-color: var(--main-bg-color); margin: 10px; width: 75px;}.four { color: white; background-color: var(--main-bg-color); margin: 10px; width: 100px;}.five { background-color: var(--main-bg-color);} 这里呈现的结果和前面的例子是一致的，但允许对所需属性值进行一个规范的声明。 自定义属性的继承性自定义属性会继承。这意味着如果在一个给定的元素上，没有为这个自定义属性设置值，在其父元素上的值会被使用。看这一段 HTML： 123456&lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;two&quot;&gt; &lt;div class=&quot;three&quot;&gt;&lt;/div&gt; &lt;div class=&quot;four&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 配套的 CSS： 123456.two { --test: 10px;}.three { --test: 2em;} 在这个情况下， var(--test) 的结果分别是： 对于元素 class=&quot;two&quot; ：10px 对于元素 class=&quot;three&quot; ：2em 对于元素 class=&quot;four&quot; ：10px （继承自父属性） 对于元素 class=&quot;one&quot; ：_非法值_，会变成自定义属性的默认值 注意，这些是自定义属性，并不是你在其他编程语言中遇到的实际的变量。这些值仅当需要的时候才会计算，而并不会按其他规则进行保存。比如，你不能为元素设置一个属性，然后让它从兄弟或旁支子孙规则上获取值。属性仅用于匹配当前选择器及其子孙，这和通常的 CSS 是一样的。 自定义属性备用值用 var() 函数可以定义多个备用值(fallback value)，当给定值未定义时将会用备用值替换。这对于 Custom Elements 和 Shadow DOM 都很有用。备用值并不是用于实现浏览器兼容性的。如果浏览器不支持 CSS 自定义属性，备用值也没什么用。它仅对支持 CSS 自定义属性的浏览器提供了一个备份机制，该机制仅当给定值未定义或是无效值的时候生效。函数的第一个参数是自定义属性的名称。如果提供了第二个参数，则表示备用值，当自定义属性值无效时生效。第二个参数可以嵌套，但是不能继续平铺展开下去了，例如： 12345678910111213141516.two { color: var(--my-var, red); /* Red if --my-var is not defined */}.three { background-color: var( --my-var, var(--my-background, pink) ); /* pink if --my-var and --my-background are not defined */}.three { background-color: var( --my-var, --my-background, pink ); /* Invalid: &quot;--my-background, pink&quot; */} 第二个例子展示了如何处理一个以上的 fallback。该技术可能会导致性能问题，因为它花了更多的时间在处理这些变量上。注意：像自定义属性这些 fallback 语法允许使用逗号。比如 var(--foo, red, blue) 定义了一个 red, blue 的备用值——从第一个逗号到最后的全部内容，都会被作为备用值的一部分。 有效性和值传统的 CSS 概念里，有效性和属性是绑定的，这对自定义属性来说并不适用。当自定义属性值被解析，浏览器不知道它们什么时候会被使用，所以必须认为这些值都是有效的。不幸的是，即便这些值是有效的，但当通过 var() 函数调用时，它在特定上下文环境下也可能不会奏效。属性和自定义变量会导致无效的 CSS 语句，这引入了一个新的概念：_计算时有效性_。 无效变量会导致什么？当浏览器遇到无效的 var() 时，会使用继承值或初始值代替。考虑如下代码： 1&lt;p&gt;This paragraph is initial black.&lt;/p&gt; 123456789:root { --text-color: 16px;}p { color: blue;}p { color: var(--text-color);} 毫不意外，浏览器将 --text-color 的值替换给了 var(--text-color)，但是 16px 并不是 color 的合法属性值。代换之后，该属性不会产生任何作用。浏览器会执行如下两个步骤： 检查属性 color 是否为继承属性。是，但是 &lt;p&gt; 没有任何父元素定义了 color 属性。转到下一步。 将该值设置为它的默认初始值，比如 black。Result 段落颜色并不是蓝色，因为无效代换导致了它被替换成了默认初始值的黑色。如果你直接写 n color: 16px 的话，则会导致语法错误，而前面的定义则会生效（段落显示为蓝色）。注意：当 CSS 属性-值对中存在语法错误，该行则会被忽略。然而如果自定义属性的值无效，它并不会被忽略，从而会导致该值被覆盖为默认值。 JavaScript 中的值在 JavaScript 中获取或者修改 CSS 变量和操作普通 CSS 属性是一样的： 123456// 获取一个 Dom 节点上的 CSS 变量element.style.getPropertyValue(&quot;--my-var&quot;);// 获取任意 Dom 节点上的 CSS 变量getComputedStyle(element).getPropertyValue(&quot;--my-var&quot;);// 修改一个 Dom 节点上的 CSS 变量element.style.setProperty(&quot;--my-var&quot;, jsVar + 4); 应用：全局样式，定义主题，快速切换。实现黑夜模式深色模式为目前网络发展的一大趋势，可以看到大量的网站为了提高网站的体验都添加了深色模式。深色模式在光线不足的情况下看起来不会那么刺眼，能够很好的保护我们的眼睛。在这边文章中主要讲如何使用 CSS 和 JS 实现深色模式和浅色模式的任意切换 分析需求假设有这么一个页面，我们需要自由切换深色模式和浅色模式。那么就需要在不同模式使用不同的 css，这里可以通过两种方式一种是直接引入不同的 css 文件，另外一种通过更改 css 变量值的方式进行更改样式，下面是浅色模式的截图 具体实现首先定义浅色模式的变量名和变量值 1234567891011:root { --primary-bg: #eee; --primary-fg: #000; --secondary-bg: #ddd; --secondary-fg: #555; --primary-btn-bg: #000; --primary-btn-fg: #fff; --secondary-btn-bg: #ff0000; --secondary-btn-fg: #ffff00;}复制代码 当切换场景的时候需要更改 css 变量的值，更改如下: 1234567891011:root { --primary-bg: #282c35; --primary-fg: #fff; --secondary-bg: #1e2129; --secondary-fg: #aaa; --primary-btn-bg: #ddd; --primary-btn-fg: #222; --secondary-btn-bg: #780404; --secondary-btn-fg: #baba6a;}复制代码 可以看到当切换到深色模式的时候，变量使用了更加暗的颜色，从而实现深色模式 更改 css如何切换到暗模式有多种解决方法，在这里我们使用媒体查询，prefers-color-scheme这个媒体查询能够获取到用户的系统是否切换到了深色主题，具体如下: 1234567891011121314@media (prefers-color-scheme: dark) { :root { --primary-bg: #282c35; --primary-fg: #fff; --secondary-bg: #1e2129; --secondary-fg: #aaa; --primary-btn-bg: #ddd; --primary-btn-fg: #222; --secondary-btn-bg: #780404; --secondary-btn-fg: #baba6a; --image-opacity: 0.85; }}复制代码 如果希望用户可以通过选择系统的设置来切换浅色模式还是深色模式，那么上面这种方式就足够了。浏览的网站能够通过系统设置选择不同的样式但是上面这种方式存在一个问题，就是用户希望这个页面的模式不要跟随系统配置的更改而更改。用户可以主动更改网站的模式，那么上面这种方式就不合适了 手动选择模式思路就是通过控制 js 来给元素添加不同的 class，不同的 class 拥有不同的样式。首先添加在 html 中添加一个按钮用于切换不同的模式 12345&lt;button id=&quot;toggle-button&quot;&gt;toggle&lt;/button&gt;&lt;script&gt; const toggleButton = document.querySelector(&quot;#toggle-button&quot;);&lt;/script&gt;复制代码 然后需要地方存储用户的偏好设置，这里使用 localStorage 来存储用户的选择。然后给按钮添加事件用于切换主题，下面是具体的代码 1234567891011121314151617const toggleButton = document.querySelector(&quot;#toggle-button&quot;);toggleButton.addEventListener(&quot;click&quot;, (e) =&gt; { darkMode = localStorage.getItem(&quot;theme&quot;); if (darkMode === &quot;dark&quot;) { disableDarkMode(); } else { enableDarkMode(); }});function enableDarkMode() { localStorage.setItem(&quot;theme&quot;, &quot;dark&quot;);}function disableDarkMode() { localStorage.setItem(&quot;theme&quot;, &quot;light&quot;);}复制代码; 现在我们就可以存储这个用户的偏好设置。然后不同的主题下给 body 元素添加不同的class，具体如下 123456789function enableDarkMode() { document.body.classList.add(&quot;dark-mode&quot;); localStorage.setItem(&quot;theme&quot;, &quot;dark&quot;);}function disableDarkMode() { document.body.classList.remove(&quot;dark-mode&quot;); localStorage.setItem(&quot;theme&quot;, &quot;light&quot;);}复制代码; 和媒体查询一样，在dark-mode的情况下更改 css 变量的属性值，具体如下: 123456789101112.dark-mode { --primary-bg: #282c35; --primary-fg: #fff; --secondary-bg: #1e2129; --secondary-fg: #aaa; --primary-btn-bg: #ddd; --primary-btn-fg: #222; --secondary-btn-bg: #780404; --secondary-btn-fg: #baba6a; --image-opacity: 0.85;}复制代码 同时在进入这个页面的时候需要获取到用户的偏好设置，从 localStorage 中读取 123let darkMode = localStorage.getItem(&quot;theme&quot;);if (darkMode === &quot;dark&quot;) enableDarkMode();复制代码; 这次就可以在页面刷新以后仍然拿到用户的偏好设置。","link":"/2021/04/02/CSS/CSS%20%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"},{"title":"ES2020(ES11)新特性","text":"ECMAScript 2020 是 ECMAScript 语言规范的第11版，引入了以下新特性。 目录 String的matchAll方法 动态导入语句 import() import.meta export * as ns from ‘module’ Promise.allSettled 一种新的数据类型: BigInt GlobalThis Promise.allSettled 一种新的数据类型： BigInt Nullish coalescing Operator matchAllmatchAll() 方法返回一个包含所有匹配正则表达式的结果的迭代器。使用 for…of 遍历或者使用操作符 … Array.from 将其转换成数组。 1234const reg = /[0-3]/g;const data = '2020';console.log(data.matchAll(reg)); // data.matchAll 的返回值是一个迭代器console.log([...data.matchAll(reg)]); /* 0: [“2”, index: 0, input: “2020”, groups: undefined] 1: [“0”, index: 1, input: “2020”, groups: undefined] 2: [“2”, index: 2, input: “2020”, groups: undefined] 3: [“0”, index: 3, input: “2020”, groups: undefined] */ Dynamic import标准用法的 import 导入的模块是静态的，会使所有被导入的模块，在加载时就被翻译(无法做到按需编译，降低首页加载速度)。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。在 import() 之前，当我们需要根据条件导入模块时，不得不使用 require()。如： 123if(XXX){ const menu = require('./menu');} 如今可以替换为： 123if(XXX){ const menu = import('./menu');} @babel/preset-env 已经包含了 @babel/plugin-syntax-dynamic-import，因此如果要使用 import() 语法，只需要配置 @babel/preset-env 即可。**提示： 请不要滥用动态导入（只有在必要情况下采用）。静态框架能更好的初始化依赖，而且更有利于静态分析工具和 tree shaking 发挥作用。另外，import() 返回是一个 promise 对象，例如： 1234567891011//menu.jsexport default { menu: 'menu'}//index.jsif(true) { let menu = import('./menu'); console.log(menu); //Promise {&lt;pending&gt; menu.then(data =&gt; console.log(data));//Module {default: {menu: &quot;menu&quot;}, __esModule: true, Symbol(Symbol.toStringTag): &quot;Module&quot;}} else {} import.metaimport.meta 会返回一个对象，有一个 url 属性，返回当前模块的url路径，只能在模块内部使用。。 12345&lt;script src='./main.js' type=&quot;module&quot;&gt;&lt;/script&gt;//main.jsconsole.log(import.meta); //{url: &quot;http://localhost:8080/main.js&quot;} PS：使用了 http-s&lt;script src='./main.js' type=&quot;module&quot;&gt;&lt;/script&gt;//main.jsconsole.log(import.meta); //{url: &quot;http://localhost:8080/main.js&quot;} PS：使用了 http-server 启动 因为 import.meta 必须要在模块内部使用，如果不加 type=”module”，控制台会报错：Cannot use ‘import.meta’ outside a module。export * as ns from ‘module’ES2020新增了 export * as XX from ‘module’，和 import * as XX from ‘module’ 12//menu.jsexport * as ns from './info'; 可以理解为是下面两条语句合并为一句： 12import * as ns from './info';export { ns }; 不过需要注意的是 export * as ns from ‘./info’ 并不会真的将导入模块，因此在该模块(menu.js)中，我们是获取不到 ns 的。 Promise.allSettledPromise.all 或者 Promise.race 有的时候并不能满足我们的需求。比如，我们需要在所有的 Promise 都结束的时候做一些操作，而并不在乎它们是成功还是失败。在没有 Promise.allSettled之前，我们需要自已去写实现。Promise.allSettled() 方法返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果。 1234567891011const promise1 = Promise.resolve(100);const promise2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 100, 'info'));const promise3 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 200, 'name'))Promise.allSettled([promise1, promise2, promise3]). then((results) =&gt; console.log(result));/* [ { status: 'fulfilled', value: 100 }, { status: 'rejected', reason: 'info' }, { status: 'fulfilled', value: 'name' } ] 可以看到，Promise.allSettled() 的成功的结果是一个数组，该数组的每一项是一个对象，每个对象都有一个 status 属性，值为 fulfilled 或 rejected，如果 status 的值是 fulfilled，那么该对象还有一个 value 属性，其属性值是对应的 promise 成功的结果；如果 status 的值是 rejectedd，那么该对象有一个 reason 属性，其属性值是对应的 promise 失败的原因。 BigIntBigInt 是一种数字类型的数据，它可以表示任意精度格式的整数。在此之前，JS中安全的最大数字是 9009199254740091，即2^53-1，在控制台中输入 Number.MAX_SAFE_INTEGER 即可查看。超过这个值，JS 没有办法精确表示。另外，大于或等于2的1024次方的数值，JS 无法表示，会返回 Infinity。BigInt 即解决了这两个问题。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。为了和 Number 类型进行区分，BigInt类型的数据必须添加后缀 n。 123456789101112131415161718//Number类型在超过9009199254740991后，计算结果即出现问题const num1 = 90091992547409910;console.log(num1 + 1); //90091992547409900//BigInt 计算结果争取const num2 = 90091992547409910n;console.log(num2 + 1n); //90091992547409911n//Number 类型不能表示大于 2 的 1024 次方的数值let num3 = 9999;for(let i = 0; i &lt; 10; i++) { num3 = num3 * num3;}console.log(num3); //Infinity//BigInt 类型可以表示任意位数的整数let num4 = 9999n;for(let i = 0n; i &lt; 10n; i++) { num4 = num4 * num4;}console.log(num4); //一串超级长的数字，这里就不贴了 我们还可以使用 BigInt 对象来初始化 BigInt 实例： 1console.log(BigInt(999)); // 999n 注意：没有 new 关键字！！！ 需要说明的是，BigInt 和 Number 是两种数据类型，不能直接进行四则运算，不过可以进行比较操作。 123console.log(99n == 99); //trueconsole.log(99n === 99); //falseconsole.log(99n + 1);//TypeError: Cannot mix BigInt and other types, use explicit conversionss GlobalThisJS 中存在一个顶层对象，但是，顶层对象在各种实现里是不统一的。从不同的 Javascript 环境中获取全局对象需要不同的语句，在 Web 中，可以通过 window、self取到全局对象，但是在 Web Workers 中，只有 self 可以。在 Node.js 中，它们都无法获取，必须使用 global。在 globalThis 之前，我们这样去获取全局对象： 123456var getGlobal = function () { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } throw new Error('unable to locate global object');}; ES2020 中引入 globalThis 作为顶层对象，在任何环境下，都可以简单的通过 globalThis 拿到顶层对象。 Nullish coalescing OperatorES2020 新增了一个运算符 ??。当作侧的操作作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。使用 || 操作符，当左侧的操作数为0、null、undefined、NaN、false、’’时，都会使用右侧的操作符，如果使用 || 来为某些变量设置默认值，可能会遇到意料之外的行为。例如： 123jconst defaultValue = 100;let value = someValue || defaultValue;//当 someValue 转成 boolean 值为 false 时，value 的值都是 defaultValue 当 someValue 的值为 0 时，我们其实期望 value 值为 0，但是它却错误的分配成了100.??操作符可以规避以上问题，它只有在左操作数是 null 或者是 undefined时，才会返回右侧操作数。 12const defaultValue = 100;let value = someValue ?? defaultValue;//someValue 为 0 ，value 的值是 0 Optional Chaining可选链操作符？.允许读取于连接对象链深处的属性的值，而不必明确验证链中的每个引用时否有效。？.操作符的功能类似于 . 链式操作符，不同于之处在于，在引用为空 (nullish，即 null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值是 undefined。例如，我们要访问 info 对象的 animal 的 reptile 的 tortoise。但是我们不确定 animal，reptile是否存在，因此我们需要这样写： 1const tortoise = info.animal &amp;&amp; info.animal.reptile &amp;&amp; info.animal.reptile.tortoise; 因为 null.reptile 或 undefined..reptile 会抛出错误：TypeError: Cannot read property ‘reptile’ of undefined 或 TypeError: Cannot read property ‘reptile’ of null，为了避免报错，如果我们需要访问的属性更深，那么这个代码会越来越长。而有了可选链操作符？.，我们在访问 reptile 之前，不再需要校验 info.animal的值。同样，在访问 info.animal.reptile.tortoise之前，也不需要校验 info.animal.reptile的值。上面代码简化为： 1const tortoise = info.animal?.reptile?.tortoise; JS在尝试访问 info.animal.reptile 之前，会隐式检查并确定 info.animal 的值不是 null 或 undefined，如果其值是 null 或 undefined，如果其值是 null 或 undefined，那么表达式短路计算直接返回 undefined。可以看到可选链操作符 ?. 和空位合并操作符一样，都是针对的 null 和 undefined 这两个值。","link":"/2021/04/02/JS/ES2020(ES11)%E6%96%B0%E7%89%B9%E6%80%A7/"},{"title":"事件循环和同步异步","text":"某日，群里有人发了一张这样的图，问输出结果为什么和预期的不一样，有几个人在讨论，都说不出个为什么。这一看就是一道面试题，考察了js的同步异步和事件循环，当然工作中类似的场景也非常多，这道题对于理解同类的问题会有一定的帮助。这里就这道题，解析一下它是如何执行的。在继续看下去之前，可以把你的答案先记下来。 12345678910111213141516171819202122232425async function async1() { console.log('async1 start') await async2() console.log('async1 end')}async function async2() { console.log('async2')}console.log('script start')setTimeout(function() { console.log('setTimeout')}, 0)async1();new Promise( function( resolve ) { console.log('promise1') resolve();} ).then( function() { console.log('promise2')} )console.log('script end') async要理解这道题，首先要理解es2017 async 语法。 async 函数返回promise对象，后面可以直接接then。 语法规定，async 的 await 命令后面，可以接promise对象或者原始类型的值（但是会转成立即resolve的promise对象。Promise.resolve()）。 async的基本用法async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。下面是一个例子。函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。 123456789async function getStockPriceByName(name) { const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;}getStockPriceByName('goog').then(function (result) { console.log(result);}); 举个栗子，async3() 返回了promise对象 123456789101112131415161718192021// 预期输出// res// undefinedasync function async3() { console.log('res');}async3().then((res) =&gt; { console.log(res); })// 类似async1里面的操作，但是这里没有await关键字，所以不会阻塞// console.log('async1 start')// await async2()// console.log('async1 end')console.log(1);Promise.resolve();console.log(2);// 输出// 1// 2// undefined event loops event loops是什么Javascript是单线程的语言，既然是单线程的，在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。 而浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，会创建事件并放入执行队列中，按照一定的顺序进行执行。 event loops的任务类型 宏任务 setTimeout setInterval requestAnimationFrame 解析HTML 执行主线程JS代码 修改URL 页面加载 用户交互 。。。 微任务 Promise MutationObserver process.nextTick （nodejs） queueMicrotask #### event loops的执行顺序（浏览器） 第一步，检查macrotask队列，运行最前面的任务，如果队列为空，前往第二步。 第二步，检查microtask队列，一直运行该队列任务直到该队列为空。 第三步，执行渲染ui。渲染后回到第一步。 执行过程解析理解基本async语法和event loops机制后，可以写出执行过程如下 定义了async函数 async1 定义了async函数 async2 输出 script start 定义了一个setTimeout，该异步操作属于宏任务，推入macrotask队列 执行到了async1，进入async1 输出 async1 start 执行到了await语句，先执行async2()，输出 async2， async2()返回了一个promise对象，这个promise被推入microtask队列，await会阻塞当前执行函数体后续的语句，等待这个异步promise完成。 代码跳出async1继续执行 进入new Promise同步执行部分，输出 promise1 执行resolve，异步回调推入推入microtask队列 输出 script end 从microtask队列取出第一个异步任务执行，这个promise对象的resolve返回值为 undefined 继续执行async1里await后面的语句，输出 async1 end 从microtask队列取出第二个异步任务执行，输出 promise2 当前macrotask执行完毕 取出下一个macrotask执行，输出 setTimeout 最终输出结果 script start async1 start async2 promise1 script end async1 end promise2 setTimeout","link":"/2021/04/02/JS/JS%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5/"},{"title":"JS常用实现（一）","text":"debounce（防抖）防抖可以让多个顺序调用的事件合成一个，防止抖动，防止正常需要一次执行就可以的事件执行了多次。在用户停止触发事件的时候，才进行执行事件。例如在搜索引擎输入框中输入文字时，每输入一个键盘字符，搜索框会实时将输入值通过请求发送到后台。将每个用户输入的字符都发送至后台，会导致请求过于频繁，造成资源的浪费。同时用户的体验也不佳，每输入一个字符都发送请求，对于服务器的性能要求很高，因为如果请求耗时太长，就无法做到每敲一个字符，就马上出来关联的输入提示内容，需要很优秀的服务器性能来配合实现。所以一般来说，这样的输入框都需要用防抖来进行处理。除非数据检索或者代码执行耗时足够短，可以不做处理。同样适用的场景有浏览器的大小调整resize监听，滚动条滚动scroll监听，按钮点击click事件等。 123456789101112/** * 防抖 * @param func 处理函数 * @param wait 等待时长，毫秒 */const debounce = (func, wait) =&gt; { let timeout = null; return () =&gt; { clearTimeout(timeout); timeout = setTimeout(func, wait); }} 123/** 测试用例 */const testDebounce = (e) =&gt; { console.log(e) }document.addEventListener('scroll', debounce(testDebounce, 300)); 这里为什么要return一个函数，因为timeout变量存在于debounce局部作用域内，正常调用后timeout变量会被内存回收。返回一个函数，引用了timeout变量，形成了闭包，所以在返回的函数内部可以读取到局部timeout变量。 throttle（节流）节流，也可以理解为限流。让事件在每个间隔的时间里，只执行一次。和防抖不同，节流保证了在x毫秒的事件内，必然触发一次事件。例如地铁上下班时间限流，每隔5分钟才能进站一波人，这就是限流。防抖和节流，作用区别不大，在应用场景上有一定的重合，关键在于是否需要在一段时间内必须触发一次事件。 1234567891011121314151617181920/** * 节流，结合了防抖的例子 * @param func 处理函数 * @param wait 等待时长，毫秒 * @param mustRun 间隔时长，毫秒 */const throttle = (func, wait, mustRun) =&gt; { let timeout = null; let startTime = new Date(); return (...args) =&gt; { const curTime = new Date(); clearTimeout(timeout); if (curTime - startTime &gt;= mustRun) { func.apply(this, args); startTime = curTime; } else { timeout = setTimeout(func, wait); } }} 123456789101112131415/** * 节流，不使用定时器。previous变量不会被销毁，所以根据节流的特性可以这样直接调用。 * @param func 处理函数 * @param mustRun 间隔时长，毫秒 */const throttle = (func, mustRun) =&gt; { let previous = 0; return (...args) =&gt; { const curTime = new Date(); if (curTime - previous &gt;= mustRun) { func.apply(this, args); previous = curTime; } }} 1234567891011121314151617/** * 节流，使用定时器 * @param func 处理函数 * @param wait 间隔时长，毫秒 */const throttle = (func, mustRun) =&gt; { let timeout = null; return (...args) =&gt; { if (timeout) { return; } timeout = setTimeout(() =&gt; { func.apply(this, args); timeout = null; }, mustRun); }} 注意 123/** 测试用例 */const test = (e) =&gt; { console.log(e) }document.addEventListener('scroll', throttle(test, 300)); new（new运算符）new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。语法 new constructor[([arguments])]new是创建一个新实例，新实例肯定是一个对象。New操作符实际上经历以下4个步骤： 创建一个新对象 将构造函数的作用域赋给新对象（this指向新对象） 执行构造函数中的代码（为新对象添加属性） 返回新对象，如果是引用类型，返回这个引用类型对象，否则返回新创建对象 new 主要来新建实例，要理解new首先来对JS原型链有一定的认识。JS原型prototype在父类里是protoype，在实例里是[[prototype]]，可以通过__proto__访问。因此创建一个新对象，同时将新对象的__proto__设置为父类的prototype，实现继承父类。例如: 123class A {};const a = new A();a.__proto__ === A.prototype; // true 12345678910111213/** * 模拟实现new * @param parentObject 父类 * @param args 父类构造函数参数 */const newObject = (parentObject, ...args) =&gt; { // 绑定原型 const newObj= Object.create(parentObject.prototype); // 使用create方法设置新对象__proto__ // 调用构造函数 const result = parentObject.apply(newObj, args); // 返回 return result instanceof Object ? result : newObj;} deepClone (深拷贝)网上的深拷贝代码一般都有些问题的，因为对于一些特殊的对象没有进行处理，但是一般也不会出现bug，简单的深拷贝有时也能实现功能。对象有可能出现循环引用。 123const a = { name: 'ben' };const b = { a };a.b = b; 结构如下：实现一 JSON.stringify &amp;&amp; JSON.parse通过JSON的两个方法使对象重新构造成新的对象实现深拷贝，它的问题在于会丢弃对象的constructor，也不支持循环引用。同时必须保证处理的对象为能够被json数据结构表示，不符合转换规则会抛出错误。 不推荐这种实现，如果要用，需要配合错误捕获方法来使用。 12const a = {};const b = JSON.parse(JSON.stringify(a)); 实现二 递归存在问题，支持的特殊对象不是很多，但是还算优雅，解决了循环引用的问题，同时遇到已经引用过的对象，不再重复循环一遍。可以解决循环引用问题，因为遇到相同对象会从cache里直接拿出来返回，并且拿出来的是已经处理过的对象，不进入循环。 1234567891011121314151617181920212223const deepClone = (obj, cache = new WeakMap()) =&gt; { if (!obj instanceof Object) return obj; if (cache.get(obj)) return cache.get(obj); // 防止循环引用 if (obj instanceof Function) { return (...arg) =&gt; { obj.apply(this, args) } } // 支持函数 if (obj instanceof Date) return new Date(obj); // 支持日期 if (obj instanceof RegExp) return new RegExp(obj.source, obj.flags); // 支持正则对象 const res = Array.isArray(obj) ? [] : {}; cache.set(obj, res); // 缓存 copy 的对象，用于处理循环引用的情况 Object.keys(obj).forEach((key) =&gt; { if (obj[key] instanceof Object) { res[key] = deepClone(obj[key], cache); } else { res[key] = obj[key]; } }); return res;} 测试用例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 执行解释// 执行deepClone(a);// 'a对应对象'本身不在缓存里，将res设置为缓存，此时初始res = {}; 初始res同时也是递归结束后要返回的对象。// 进入循环// key等于name，不在缓存里，设置缓存。继续执行，不是对象，直接返回。此时初始res = {name: 'ben'};// key等于b，不在缓存里，设置缓存。继续执行，b值是对象。进入下一层循环。此时初始res = {name: 'ben'}; b的res是： {}// key等于a，在缓存里，拿出来返回。b的res是: { a: 初始res }。循环结束，函数返回b的res。 此时初始res = {name: 'ben', b: { a: 初始res }};// 循环结束，返回初始res {name: 'ben', b: { a: 初始res }}// 注意！当时设置'a对应对象'的缓存值是新构造的res对象，所以新拿出来的'a对应对象'的缓存值，是重新构造后的值，并不是原始的值。// 变成了新的克隆对象循环引用构造后的它自己本身的值。const a = { name: 'ben' };const b = { a };a.b = b;const deepClone = (obj, cache = new WeakMap()) =&gt; { if (!obj instanceof Object) return obj; if (cache.get(obj)) return cache.get(obj); // 防止循环引用 if (obj instanceof Function) { return (...arg) =&gt; { obj.apply(this, args) } } // 支持函数 if (obj instanceof Date) return new Date(obj); // 支持日期 if (obj instanceof RegExp) return new RegExp(obj.source, obj.flags); // 支持正则对象 const res = Array.isArray(obj) ? [] : {}; cache.set(obj, res); // 缓存 copy 的对象，用于处理循环引用的情况 Object.keys(obj).forEach((key) =&gt; { console.log(key); if (obj[key] instanceof Object) { res[key] = deepClone(obj[key], cache); } else { res[key] = obj[key]; } }); console.log(res, 'res'); return res;}const c = deepClone(a);console.log(a.b.a.b.a.b === c.b.a.b.a.b); // falsea.age = 1;c.age = 2;console.log(a);console.log(c); 输出","link":"/2021/04/02/JS/JS%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"Vue性能提升之Object.freeze()","text":"序在 Vue 的文档中介绍数据绑定和响应时，特意标注了对于经过 Object.freeze() 方法的对象无法进行更新响应。因此，特意去查了 Object.freeze() 方法的具体含义。 含义Object.freeze() 方法用于冻结对象，禁止对于该对象的属性进行修改（由于数组本质也是对象，因此该方法可以对数组使用）。在 Mozilla MDN 中是如下介绍的： 可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改 该方法的返回值是其参数本身。 需要注意的是以下两点 Object.freeze() 和 const 变量声明不同，也不承担 const 的功能。 const 和 Object.freeze() 完全不同 const 的行为像 let。它们唯一的区别是， const 定义了一个无法重新分配的变量。 通过 const 声明的变量是具有块级作用域的，而不是像 var 声明的变量具有函数作用域。 Object.freeze() 接受一个对象作为参数，并返回一个相同的不可变的对象。这就意味着我们不能添加，删除或更改对象的任何属性。 const 和 Object.freeze() 并不同，const 是防止变量重新分配，而 Object.freeze() 是使对象具有不可变性。 以下代码是正确的： Object.freeze() 是 “浅冻结”，以下代码是生效的: 实例常规用法 明显看到，a 的 prop 属性未被改变，即使重新赋值了。 延伸“深冻结” 要完全冻结具有嵌套属性的对象，您可以编写自己的库或使用已有的库来冻结对象，如Deepfreeze或immutable-js 123456789101112131415161718// 深冻结函数.function deepFreeze(obj) { // 取回定义在obj上的属性名 var propNames = Object.getOwnPropertyNames(obj); // 在冻结自身之前冻结属性 propNames.forEach(function(name) { var prop = obj[name]; // 如果prop是个对象，冻结它 if (typeof prop == 'object' &amp;&amp; prop !== null) deepFreeze(prop); }); // 冻结自身(no-op if already frozen) return Object.freeze(obj);} 其实就是个简单的递归方法。但是涉及到一个很重要，但是在写业务逻辑的时候很少用的知识点 Object.getOwnPropertyNames(obj) 。我们都知道在 JS 的 Object 中存在原型链属性，通过这个方法可以获取所有的非原型链属性。 利用Object.freeze()提升性能除了组件上的优化，我们还可以对 vue 的依赖改造入手。初始化时，vue 会对 data 做 getter、setter 改造，在现代浏览器里，这个过程实际上挺快的，但仍然有优化空间。 Object.freeze() 可以冻结一个对象，冻结之后不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。该方法返回被冻结的对象。 当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter，这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 但 Vue 在遇到像 Object.freeze() 这样被设置为不可配置之后的对象属性时，不会为对象加上 setter getter 等数据劫持的方法。参考 Vue 源码 Vue observer 源码 性能提升效果对比在基于 Vue 的一个 big table benchmark 里，可以看到在渲染一个一个 1000 x 10 的表格的时候，开启Object.freeze() 前后重新渲染的对比。 big table benchmark 开启优化之前 开启优化之后 在这个例子里，使用了 Object.freeze()比不使用快了 4 倍 为什么Object.freeze() 的性能会更好不使用Object.freeze() 的 CPU 开销 使用 Object.freeze()的 CPU 开销 对比可以看出，使用了 Object.freeze() 之后，减少了 observer 的开销。 Object.freeze()应用场景由于 Object.freeze()会把对象冻结，所以比较适合展示类的场景，如果你的数据属性需要改变，可以重新替换成一个新的 Object.freeze()的对象。 Javascript 对象解冻修改 React props React 生成的对象是不能修改 props 的, 但实践中遇到需要修改 props 的情况. 如果直接修改, js 代码将报错, 原因是 props 对象被冻结了, 可以用 Object.isFrozen() 来检测, 其结果是 true. 说明该对象的属性是只读的. 那么, 有方法将 props 对象解冻, 从而进行修改吗? 事实上, 在 javascript 中, 对象冻结后, 没有办法再解冻, 只能通过克隆一个具有相同属性的新对象, 通过修改新对象的属性来达到目的. 可以这样: 12ES6: Object.assign({}, frozenObject);lodash: _.assign({}, frozenObject); 来看实际代码: 12345678910111213function modifyProps(component) { let condictioin = this.props.condictioin, newComponent = Object.assign({}, component), newProps = Object.assign({}, component.props) if (condictioin) { if (condictioin.add) newProps.add = true if (condictioin.del) newProps.del = true } newComponent.props = newProps return newComponent} 锁定对象的方法 Object.preventExtensions() no new properties or methods can be added to the project 对象不可扩展, 即不可以新增属性或方法, 但可以修改 / 删除 Object.seal() same as prevent extension, plus prevents existing properties and methods from being deleted 在上面的基础上，对象属性不可删除, 但可以修改 Object.freeze() same as seal, plus prevent existing properties and methods from being modified 在上面的基础上，对象所有属性只读, 不可修改 以上三个方法分别可用 Object.isExtensible(), Object.isSealed(), Object.isFrozen() 来检测 Object.freeze( ) 阻止 Vue 无法实现 响应式系统当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，视图将会产生 “响应”，即匹配更新为新的值。但是如果使用 Object.freeze()，这会阻止修改现有的属性，也意味着响应系统无法再追踪变化。 具体使用办法举例： 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;p&gt;freeze后会改变吗 {{obj.foo}} &lt;/p&gt; &lt;!-- 两个都不能修改？？为什么？第二个理论上应该是可以修改的--&gt; &lt;button @click=&quot;change&quot;&gt;点我确认&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;var obj = { foo: '不会变'}Object.freeze(obj)export default { name: 'index', data () { return { obj: obj } }, methods: { change () { this.obj.foo = '改变' } }}&lt;/script&gt; 运行后： 从报错可以看出只读属性 foo 不能进行修改，Object.freeze() 冻结的是值，你仍然可以将变量的引用替换掉, 将上述代码更改为： 1234567&lt;button @click=&quot;change&quot;&gt;点我确认&lt;/button&gt;change () { this.obj = { foo: '会改变' } } Object.freeze() 是 ES5 新增的特性，可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。防止对象被修改。 如果你有一个巨大的数组或 Object，并且确信数据不会修改，使用 Object.freeze() 可以让性能大幅提升。 实践心得和技巧Object.freeze() 是 ES5 新增的特性，可以冻结一个对象，防止对象被修改。 vue 1.0.18 + 对其提供了支持，对于 data 或 vuex 里使用 freeze 冻结了的对象，vue 不会做 getter 和 setter 的转换。 如果你有一个巨大的数组或 Object，并且确信数据不会修改，使用 Object.freeze() 可以让性能大幅提升。在我的实际开发中，这种提升大约有 5~10 倍，倍数随着数据量递增。 并且，Object.freeze() 冻结的是值，你仍然可以将变量的引用替换掉。举个例子： 1&lt;p v-for=&quot;item in list&quot;&gt;{{ item.value }}&lt;/p&gt; 1234567891011121314151617181920212223new Vue({ data: { // vue不会对list里的object做getter、setter绑定 list: Object.freeze([ { value: 1 }, { value: 2 } ]) }, created () { // 界面不会有响应 this.list[0].value = 100; // 下面两种做法，界面都会响应 this.list = [ { value: 100 }, { value: 200 } ]; this.list = Object.freeze([ { value: 100 }, { value: 200 } ]); }}) vue 的文档没有写上这个特性，但这是个非常实用的做法，对于纯展示的大数据，都可以使用 Object.freeze 提升性能。 https://juejin.cn/post/6844903922469961741","link":"/2021/04/02/VUE/Vue%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E4%B9%8BObject.freeze()/"},{"title":"一个关于image访问图片跨域的问题","text":"一、背景项目中遇到一个问题，同一个图片在 dom 节点中使用了’img’ 标签来加载，同时由于项目使用了 ThreeJS 3D 渲染引擎，在加载纹理时使用了 TextureLoader 来加载了同一张图片，而由于图片是在阿里云服务器上的，所以最后报出了如下错误，意思是在访问图片时出现了跨域问题： 二、问题梳理 2.1 关于图片的加载图片是来自于阿里云服务器的，和本地 localhost 必然存在跨域问题。通过 dom 节点的’img’ 标签来直接访问是没有问题，因为浏览器本身不会有跨域问题。问题出在通过 TextureLoader 来加载图片时出现了跨域问题。查看了 TextureLoader 的源码，发现其进一步使用了 ImageLoader 来加载图片，加载图片的代码大致如下： 12345678910crossOrigin: 'anonymous',......var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );......if ( url.substr( 0, 5 ) !== 'data:' ) { if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;}......image.src = url; 这段代码所描述的大致思路是： 通过 JS 代码，创建一个 img 的 dom element，然后使用这个 element 来加载图片。 默认情况下，设置了 crossOrigin 的跨域属性为’anonymous’。 所以，问题的关键在于，同一张图片，先用’img’ 标签去加载了，然后再在 JS 代码中，创建一个’img’ 并且设置了 crossOrigin 的跨域属性为’anonymous’，那么在 JS 中创建的’img’ 就会出现访问图片而产生跨域的问题。 2.2 关于 crossOrigin关于 crossOrigin，我们看看 MDN 的解释。 这段话，用我自己的理解来解释一下： 加了 crossorigin 属性，则表明图片就一定会按照 CORS 来请求图片。而通过 CORS 请求到的图片可以再次被复用到 canvas 上进行绘制。换言之，如果不加 crossorigin 属性的话，那么图片是不能再次被复用到 canvas 上去的。 可以设置的值有 anonymous 以及 use-credentials，2 个 value 的作用都是设置通过 CORS 来请求图片，区别在于 use-credentials 是加了证书的 CORS。 如果默认用户不进行任何设置，那么就不会发起 CORS 请求。但如果设置了除 anonymous 和 use-credentials 以外的其他值，包括空字串在内，默认会当作 anonymous 来处理。 2.3 问题总结通过前面 2 点的梳理，我们得出如下结论： 通过’img’ 加载的图片，浏览器默认情况下会将其缓存起来。 当我们从 JS 的代码中创建的’img’ 再去访问同一个图片时，浏览器就不会再发起新的请求，而是直接访问缓存的图片。但是由于 JS 中的’img’ 设置了 crossorigin，也就意味着它将要以 CORS 的方式请求，但缓存中的图片显然不是的，所以浏览器直接就拒绝了。连网络请求都没有发起。 在 Chrome 的调试器中，在 network 面板中，我们勾选了 disable cache 选项，验证了问题确实如第 2 点所述，浏览器这时发起了请求并且 JS 的’img’ 也能正常请求到图片。 三、解决问题前面通过勾选 disable cache 来避免浏览器使用缓存图片而解决了问题，但实际用户不会这样使用啊。根据前面的梳理，’img’ 不跨域请求，而 JS 中的’img’ 跨域请求，所以不能访问缓存，那么是不是可以将 JS 中的’img’ 也设置成不跨域呢，于是将 JS 中的’img’ 的 crossorigin 设置为 undefine，结果图片是可以加载了，但又得到如下错误。这段错误的意思是，这一个来自于 CORS 的图片，是不可以再次被复用到 canvas 上去的。这就验证了关于 crossorigin 中的第 1 点。既然’img’ 和 JS 中的’img’ 都不加 crossorigin 不能解决 canvas 重用的问题，那么在两边同时都加上 crossorigin 呢？果然，在’img’ 中和 JS 中的’img’ 都加上 crossorigin = “anonymous”，图片可以正常加了，同时也可以被复用到’canvas’ 上去了。另外，需要注意的 2 个小问题是： 服务器必须加上字段，否则，客户端设置了也是没用的。 Access-Control-Allow-Origin: * 如果是已经出了问题，你才看到这篇文章，或者才去想到这么解决。那么要记得先清理一下游览器所缓存的图片。否则你就会发现，有的图片可以访问，而有的不可以。那是因为缓存中之前存储了未 CORS 的图片。 四、总结前面说了一框，只是想把这个过程完整的记录下来。整个问题的总结是： 同一张图片或者同一个地址，同时被’img’ 所访问，而随后后又会被如 JS 中去访问。而图片存储的地址是跨域的，那么就可能因为缓存问题而导致 JS 中的访问出现跨域问题。 解决的办法是让’img’ 标签和 JS 中的访问都走跨域访问的方式，这样既可以解决跨域访问的问题，也可以解决跨域图片在 canvas 中的复用。 最后，感谢你能读到并读完此文章，如果分析的过程中存在错误或者疑问都欢迎留言讨论。如果我的分享能够帮助到你，还请记得帮忙点个赞吧，谢谢。安装掘金浏览器插件打开新标签页发现好内容，掘金、GitHub、Dribbble、ProductHunt 等站点内容轻松获取。快来安装掘金浏览器插件获取高质量内容吧！https://juejin.cn/post/6844903795726483463","link":"/2021/04/02/html/%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8Eimage%E8%AE%BF%E9%97%AE%E5%9B%BE%E7%89%87%E8%B7%A8%E5%9F%9F%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"掌握甩锅技术 Typescript 运行时数据校验","text":"背景 为什么要运行时校验数据？ io-ts 解决方案？ 理想方案探索 JSON schema typescript -&gt; json-schema json-schema 校验库 commit 时自动更新 json-schema 总结 背景大家出来写 代码的，难免会出 Bug。文章背景就发生在一个 Bug 身上，有一天，测试慌张中带着点兴奋冲过来：测试：”xxx 系统前端线上出 Bug 了，点进 xx 页面一片空白啊”。我：”纳尼？我写的 Bug 怎么会出现代码呢？”。虽然大脑一片空白，但是锅还是要背的。进入页面一看，哦豁，完蛋，cannot read the property 'xx' of undefined。确实是前端常见的报错呀。背锅王，我当定了？未必。我眉头一皱，发现事情并不是那么简单，经过一番猛如虎的操作之后，最终定位到问题是：后端接口响应的 JSON 数据中，一个嵌套比较深的字段没有返回，即前端只读到了 undefined。咱按章程办事，后端提供的接口文档指定了数据结构，那你没有返回正确数据结构，这就是你后端的锅，虽然严谨点前端也能捕获到错误进行处理，但归根到底，是你后端数据接口处理有问题，这锅，我不背。甩锅又是一门扯皮的事情，杀敌一千自伤八百，锅已经扣下来了，想甩出去就难咯，。唉，要是在接口出错的时候，能立刻知道接口数据出问题，先发制人，马上把锅甩出去那就好咯。这就是本文即将要讲述的 “Typescript 运行时数据校验”。 为什么要运行时校验数据？众所周知，Typescript 是 JavaScript 超集，可以给我们的项目代码提供静态类型检查，避免因为各种原因而未及时发现的代码错误，在编译时就能发现隐藏的代码隐患，从而提高代码质量。但是，TypeScript 项目的一个常见问题是: 如何验证来自外部源的数据并将验证的数据与 TypeScript 类型联系起来。 即，如何避免后端 API 返回的数据与 Typescript 类型定义不一致导致的运行时错误。Typescript 能用于运行时校验数据类型，那么有没有一种方法，能让我们在 运行时 也进行 Typescript 数据类型校验呢？ io-ts 解决方案？业界开源了一个运行时校验的工具库：io-ts。 12345678910111213141516// io-ts 例子import * as t from 'io-ts'// ts 定义interface Category { name: string categories: Array&lt;Category&gt;}// 对应上述ts定义的 io-ts 实现const Category: t.Type&lt;Category&gt; = t.recursion('Category', () =&gt; t.type({ name: t.string, categories: t.array(Category) })) 但是，如上面的代码所示，这工具看起来就有点啰嗦有点难用，对代码的侵入性非常强，要全盘依据它的语法来重写代码。这对于一个团队来说，存在一定的迁移成本。而我们更希望做到的理想方案是：写好接口的数据结构 typescript 定义，不需要做太多的额外变动，直接就能校验后端接口响应的数据结构是否符合 typescript 接口定义 理想方案探索首先，我们了解到，后端响应的数据接口一般为 JSON，那么，抛开 Typescript，如果要校验一个 JSON 的数据结构，我们可以怎么做到呢？答案是JSON schema。 JSON schemaJSON schema 是一种描述 JSON 数据格式的模式。例如 typescript 数据结构： 123456type TypeSex = 1 | 2 | 3interface UserInfo { name: string age?: number sex: TypeSex} 等价于以下的 json schema ： 1234567891011121314151617181920212223242526272829{ &quot;$id&quot;: &quot;api&quot;, &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;, &quot;definitions&quot;: { &quot;UserInfo&quot;: { &quot;properties&quot;: { &quot;age&quot;: { &quot;type&quot;: &quot;number&quot; }, &quot;name&quot;: { &quot;type&quot;: &quot;string&quot; }, &quot;sex&quot;: { &quot;enum&quot;: [ 1, 2, 3 ], &quot;type&quot;: &quot;number&quot; } }, &quot;required&quot;: [ &quot;name&quot;, &quot;sex&quot; ], &quot;type&quot;: &quot;object&quot; } }} 根据已有 json-schema 校验库，即可校验数据对象 1someValidateFunc(jsonSchema, apiResData) 这里大家可能就又会困惑：这json-schema写起来也太费劲了？还不一样要学习成本，那和 io-ts 有什么区别。但是，既然我们同时知道 typescript 和 json-schema 的语法定义规则，那么就两者必然能够互相转换。也就是说，即便我们不懂 json-schema 的规范与语法，我们也能通过typescript 转化生成 json-schema。那么，在以上的前提下，我们的思路就是：既然 typescript 本身不支持运行时数据校验，那么我们可以将 typescript 先转化成 json schema, 然后用 json-schema 校验数据结构 typescript -&gt; json-schema要将 typescript 声明转换成 json-schema ，这里推荐使用 typescript-json-schema。我们可以直接使用它的命令行工具，这里就不仔细展开说明了，感兴趣的可以看下官方文档： 123456789101112131415161718192021Usage: typescript-json-schema &lt;path-to-typescript-files-or-tsconfig&gt; &lt;type&gt;Options: --refs Create shared ref definitions. [boolean] [default: true] --aliasRefs Create shared ref definitions for the type aliases. [boolean] [default: false] --topRef Create a top-level ref definition. [boolean] [default: false] --titles Creates titles in the output schema. [boolean] [default: false] --defaultProps Create default properties definitions. [boolean] [default: false] --noExtraProps Disable additional properties in objects by default. [boolean] [default: false] --propOrder Create property order definitions. [boolean] [default: false] --required Create required array for non-optional properties. [boolean] [default: false] --strictNullChecks Make values non-nullable by default. [boolean] [default: false] --useTypeOfKeyword Use `typeOf` keyword (https://goo.gl/DC6sni) for functions. [boolean] [default: false] --out, -o The output file, defaults to using stdout --validationKeywords Provide additional validation keywords to include [array] [default: []] --include Further limit tsconfig to include only matching files [array] [default: []] --ignoreErrors Generate even if the program has errors. [boolean] [default: false] --excludePrivate Exclude private members from the schema [boolean] [default: false] --uniqueNames Use unique names for type symbols. [boolean] [default: false] --rejectDateType Rejects Date fields in type definitions. [boolean] [default: false] --id Set schema id. [string] [default: &quot;&quot;] github 上也有所有类型转换的 测试用例，可以对比看看 typescript 和 转换出的 json-schema 结果 json-schema 校验库利用 typescript-json-schema 工具生成了 json-schema 文件后，我们需要根据该文件进行数据校验。json-schema 数据校验的库很多，ajv，jsonschema 之类的，这里用 jsonschema 作为示例。 123456789101112131415161718192021222324import { Validator } from 'jsonschema'import schema from './json-schema.json'const v = new Validator()// 绑定schema，这里的 `api` 对应 json-schema.json 的 `$id`v.addSchema(schema, '/api')const validateResponseData = (data: any) =&gt; { // 校验响应数据 const result = v.validate(data, { // SomeInterface 为 ts 定义的接口 $ref: `api#/definitions/SomeInterface` }) // 校验失败，数据不符合预期 if (!result.valid) { console.log('data is ', data) console.log('errors', result.errors.map((item) =&gt; item.toString())) } return data} 当我们校验以下数据时： 1234567891011121314151617// 声明文件interface UserInfo { name: string sex: string age: number phone?: number}// 校验结果validateResponseData({ name: 'xxxx', age: 'age应该是数字'})// 得出结果// data is { name: 'xxxx', age: 'age应该是数字' }// errors [ 'instance.age is not of a type(s) number',// 'instance requires property &quot;sex&quot;' ] 完全例子请看 github配合上前端上报系统，当线上系统接口返回了非预料的数据，导致出 bug，就可以实时知道到底错在哪了，并且及时甩锅给后端啦。 commit 时自动更新 json-schema前面提到，我们需要执行 typescript-json-schema &lt;path-to-typescript-files-or-tsconfig&gt; &lt;type&gt; 命令来声明 typescript 对应的 json-schema 文件。那么，这里就有个问题，接口数量有可能增加，接口数据也有可能变动，那也就代表着，我们每次变更接口数据结构，都要重新跑一下 typescript-json-schema ，时刻保持 json-schema 和 typescript 一一对应。这我们就可以用 husky 的 precommit ， 加上 lint-staged 来实现每次更新提交代码时，自动执行 typescript-json-schema，无需时刻关注 typescript 接口定义的变更。完全例子请看 github 总结综上，我们实现了 typescript 声明文件 转换生成 json-schema 文件 代码接口层拦截校验数据，如校验失败，通过前端上报系统 (如：sentry) 进行相关上报 通过 husky + lint-staged 每次提交代码自动执行 步骤 1，保持 git 仓库的代码 typescript 声明 和 json-schema 时刻保持一致。 那么，当 Bug 出现的时候，你甚至可以在测试都还没发现这个 Bug 之前，就已经把锅甩了出去。只要你跑得足够快，Bug 就会追不上你。https://github.com/SunshowerC/blog/issues/13","link":"/2021/04/02/typescript/%E6%8E%8C%E6%8F%A1%E7%94%A9%E9%94%85%E6%8A%80%E6%9C%AFts%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%A1%E9%AA%8C/"},{"title":"单点登录的三种实现方式","text":"前言 实现方式一：父域 Cookie 实现方式二：认证中心 实现方式三：LocalStorage 跨域 补充：域名分级 前言在 B/S 系统中，登录功能通常都是基于 Cookie 来实现的。当用户登录成功后，一般会将登录状态记录到 Session 中，或者是给用户签发一个 Token，无论哪一种方式，都需要在客户端保存一些信息（Session ID 或 Token ），并要求客户端在之后的每次请求中携带它们。在这样的场景下，使用 Cookie 无疑是最方便的，因此我们一般都会将 Session 的 ID 或 Token 保存到 Cookie 中，当服务端收到请求后，通过验证 Cookie 中的信息来判断用户是否登录 。单点登录（Single Sign On, SSO）是指在同一帐号平台下的多个应用系统中，用户只需登录一次，即可访问所有相互信任的应用系统。举例来说，百度贴吧和百度地图是百度公司旗下的两个不同的应用系统，如果用户在百度贴吧登录过之后，当他访问百度地图时无需再次登录，那么就说明百度贴吧和百度地图之间实现了单点登录。单点登录的本质就是在多个应用系统中共享登录状态。如果用户的登录状态是记录在 Session 中的，要实现共享登录状态，就要先共享 Session，比如可以将 Session 序列化到 Redis 中，让多个应用系统共享同一个 Redis，直接读取 Redis 来获取 Session。当然仅此是不够的，因为不同的应用系统有着不同的域名，尽管 Session 共享了，但是由于 Session ID 是往往保存在浏览器 Cookie 中的，因此存在作用域的限制，无法跨域名传递，也就是说当用户在 app1.com 中登录后，Session ID 仅在浏览器访问 app1.com 时才会自动在请求头中携带，而当浏览器访问 app2.com 时，Session ID 是不会被带过去的。实现单点登录的关键在于，如何让 Session ID（或 Token）在多个域中共享。 实现方式一：父域 Cookie在将具体实现之前，我们先来聊一聊 Cookie 的作用域。Cookie 的作用域由 domain 属性和 path 属性共同决定。domain 属性的有效值为当前域或其父域的域名 / IP 地址，在 Tomcat 中，domain 属性默认为当前域的域名 / IP 地址。path 属性的有效值是以 “/” 开头的路径，在 Tomcat 中，path 属性默认为当前 Web 应用的上下文路径。如果将 Cookie 的 domain 属性设置为当前域的父域，那么就认为它是父域 Cookie。Cookie 有一个特点，即父域中的 Cookie 被子域所共享，换言之，子域会自动继承父域中的 Cookie。利用 Cookie 的这个特点，不难想到，将 Session ID（或 Token）保存到父域中不就行了。没错，我们只需要将 Cookie 的 domain 属性设置为父域的域名（主域名），同时将 Cookie 的 path 属性设置为根路径，这样所有的子域应用就都可以访问到这个 Cookie 了。不过这要求应用系统的域名需建立在一个共同的主域名之下，如 tieba.baidu.com 和 map.baidu.com，它们都建立在 baidu.com 这个主域名之下，那么它们就可以通过这种方式来实现单点登录。总结：此种实现方式比较简单，但不支持跨主域名。 实现方式二：认证中心我们可以部署一个认证中心，认证中心就是一个专门负责处理登录请求的独立的 Web 服务。用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 Token 写入 Cookie。（注意这个 Cookie 是认证中心的，应用系统是访问不到的。）应用系统检查当前请求有没有 Token，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心。由于这个操作会将认证中心的 Cookie 自动带过去，因此，认证中心能够根据 Cookie 知道用户是否已经登录过了。如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录，如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 URL ，并在跳转前生成一个 Token，拼接在目标 URL 的后面，回传给目标应用系统。应用系统拿到 Token 之后，还需要向认证中心确认下 Token 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 Token 写入 Cookie，然后给本次访问放行。（注意这个 Cookie 是当前应用系统的，其他应用系统是访问不到的。）当用户再次访问当前应用系统时，就会自动带上这个 Token，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了。这里顺便介绍两款认证中心的开源实现： Apereo CAS 是一个企业级单点登录系统，其中 CAS 的意思是”Central Authentication Service“。它最初是耶鲁大学实验室的项目，后来转让给了 JASIG 组织，项目更名为 JASIG CAS，后来该组织并入了 Apereo 基金会，项目也随之更名为 Apereo CAS。 XXL-SSO 是一个简易的单点登录系统，由大众点评工程师许雪里个人开发，代码比较简单，没有做安全控制，因而不推荐直接应用在项目中，这里列出来仅供参考。 总结：此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法。 实现方式三：LocalStorage 跨域前面，我们说实现单点登录的关键在于，如何让 Session ID（或 Token）在多个域中共享。父域 Cookie 确实是一种不错的解决方案，但是不支持跨域。那么有没有什么奇淫技巧能够让 Cookie 跨域传递呢？很遗憾，浏览器对 Cookie 的跨域限制越来越严格。Chrome 浏览器还给 Cookie 新增了一个 SameSite 属性，此举几乎禁止了一切跨域请求的 Cookie 传递（超链接除外），并且只有当使用 HTTPs 协议时，才有可能被允许在 AJAX 跨域请求中接受服务器传来的 Cookie。不过，在前后端分离的情况下，完全可以不使用 Cookie，我们可以选择将 Session ID （或 Token ）保存到浏览器的 LocalStorage 中，让前端在每次向后端发送请求时，主动将 LocalStorage 的数据传递给服务端。这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 Session ID （或 Token ）放在响应体中传递给前端。在这样的场景下，单点登录完全可以在前端实现。前端拿到 Session ID （或 Token ）后，除了将它写入自己的 LocalStorage 中之外，还可以通过特殊手段将它写入多个其他域下的 LocalStorage 中。关键代码如下： 1234567891011121314151617181920// 获取 tokenvar token = result.data.token;// 动态创建一个不可见的 iframe，在 iframe 中加载一个跨域 HTMLvar iframe = document.createElement(&quot;iframe&quot;);iframe.src = &quot;http://app1.com/localstorage.html&quot;;document.body.append(iframe);// 使用 postMessage() 方法将 token 传递给 iframesetTimeout(function () { iframe.contentWindow.postMessage(token, &quot;http://app1.com&quot;);}, 4000);setTimeout(function () { iframe.remove();}, 6000);// 在这个 iframe 所加载的 HTML 中绑定一个事件监听器，当事件被触发时，把接收到的 token 数据写入 localStoragewindow.addEventListener('message', function (event) { localStorage.setItem('token', event.data)}, false); 前端通过 iframe+postMessage() 方式，将同一份 Token 写入到了多个域下的 LocalStorage 中，前端每次在向后端发送请求之前，都会主动从 LocalStorage 中读取 Token 并在请求中携带，这样就实现了同一份 Token 被多个域所共享。 总结：此种实现方式完全由前端控制，几乎不需要后端参与，同样支持跨域。 补充：域名分级从专业的角度来说（根据《计算机网络》中的定义），.com、.cn 为一级域名（也称顶级域名），.com.cn、baidu.com 为二级域名，sina.com.cn、tieba.baidu.com 为三级域名，以此类推，N 级域名就是 N-1 级域名的直接子域名。从使用者的角度来说，一般把可支持独立备案的主域名称作一级域名，如 baidu.com、sina.com.cn 皆可称作一级域名，在主域名下建立的直接子域名称作二级域名，如 tieba.baidu.com 为二级域名。为了避免歧义，本人将使用 “主域名“替代” 一级域名“的说法。推荐阅读 点击标题可跳转那些总是写 “烂代码” 的同学，强烈推荐你用这款 IDEA 插件！国内又一起 “删库跑路” 事件：程序员怒删公司 9TB 数据，判刑 7 年！Eclipse 出品，1.3 万 Star！网友说要干掉 VS Code 的新工具看完本文有收获？请转发分享给更多人关注「ImportNew」，提升 Java 技能好文章，我在看❤️https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;mid=2651492507&amp;idx=1&amp;sn=734a4c50620ac22bb4a611129e8d25e7&amp;chksm=bd25fce48a5275f2fb63e4d55b561893ebae700426e70fbdae8a80ff569ea375cbdfa01619b6&amp;scene=132#wechat_redirect","link":"/2021/04/02/%E4%B8%9A%E5%8A%A1/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"},{"title":"rollup初体验","text":"进入一个目录，npm init 进行初始化，可以一路回车安装tsnpm install -D typescript 生存配置文件./node_modules/.bin/tsc –init 根目录下新建一个rollup配置文件rollup.config.js 添加以下内容 1234567891011121314151617181920212223242526272829303132333435363738import clear from 'rollup-plugin-clear'; // 转换cjsimport commonjs from 'rollup-plugin-commonjs'; // 转换cjsimport { terser } from 'rollup-plugin-terser'; // 压缩，可以判断模式，开发模式不加入到pluginsimport resolve from 'rollup-plugin-node-resolve';import babel from 'rollup-plugin-babel';import typescript from 'rollup-plugin-typescript';export default { input: 'src/index.ts', // 源文件入口 output: [ { file: 'dist/browser-version.esm.js', // package.json 中 &quot;module&quot;: &quot;dist/browser-version.esm.js&quot; format: 'esm', // es module 形式的包， 用来import 导入， 可以tree shaking sourcemap: false }, { file: 'dist/browser-version.cjs.js', // package.json 中 &quot;main&quot;: &quot;dist/browser-version.cjs.js&quot;, format: 'cjs', // commonjs 形式的包， require 导入 sourcemap: false }, { file: 'dist/browser-version.umd.js', name: 'GLWidget', format: 'umd', // umd 兼容形式的包， 可以直接应用于网页 script sourcemap: false, } ], plugins: [ clear({ targets: ['dist'] }), resolve(), babel({ exclude: 'node_modules/**' }), typescript(), commonjs(), terser(), ]} 修改packagejson 12345678910111213141516171819202122232425262728293031323334353637{ &quot;name&quot;: &quot;browser-version-tool-html&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Print tips on outdate browser. &quot;, &quot;main&quot;: &quot;dist/browser-version.cjs.js&quot;, &quot;module&quot;: &quot;dist/browser-version.esm.js&quot;, &quot;browser&quot;: &quot;dist/browser-version.umd.js&quot;, &quot;scripts&quot;: { &quot;build&quot;: &quot;rollup -c&quot;, &quot;dev&quot;: &quot;rollup -c -w&quot;, &quot;test&quot;: &quot;ts-node test/test.ts&quot;, &quot;pretest&quot;: &quot;npm run build&quot; }, &quot;author&quot;: &quot;Yenkos&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: { &quot;@babel/core&quot;: &quot;^7.12.10&quot;, &quot;@rollup/plugin-html&quot;: &quot;^0.2.0&quot;, &quot;@types/ms&quot;: &quot;^0.7.31&quot;, &quot;babel-plugin-external-helpers&quot;: &quot;^6.22.0&quot;, &quot;babel-preset-latest&quot;: &quot;^6.24.1&quot;, &quot;rollup&quot;: &quot;^2.35.1&quot;, &quot;rollup-plugin-babel&quot;: &quot;^4.4.0&quot;, &quot;rollup-plugin-clear&quot;: &quot;^2.0.7&quot;, &quot;rollup-plugin-commonjs&quot;: &quot;^10.1.0&quot;, &quot;rollup-plugin-hash&quot;: &quot;^1.3.0&quot;, &quot;rollup-plugin-node-resolve&quot;: &quot;^5.2.0&quot;, &quot;rollup-plugin-terser&quot;: &quot;^7.0.2&quot;, &quot;rollup-plugin-typescript&quot;: &quot;^1.0.1&quot;, &quot;rollup-plugin-uglify&quot;: &quot;^6.0.4&quot;, &quot;ts-node&quot;: &quot;^9.1.1&quot;, &quot;tslib&quot;: &quot;^2.0.3&quot;, &quot;typescript&quot;: &quot;^4.1.3&quot; }, &quot;types&quot;: &quot;dist/index.d.ts&quot;} npm i 安装依赖进入src/index.ts 编写代码rollup 打包npm run build 发布包到npm首先需要注册npm账号 npm addusernpm loginnpm publish","link":"/2021/04/02/%E5%B7%A5%E7%A8%8B%E5%8C%96/rollup%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"title":"package-lock.json的作用","text":"什么是package-lock.json在前端项目根目录里有一个package-lock.json文件，有同学疑惑这个文件是干嘛用，不是已经有一个package文件了吗？这个文件前身是npm-shrinkwrap.json，因为npm的依赖管理非常宽松，一个项目在同一天内都可能会安装到不同版本的依赖包，依赖包的升级可能会给项目带来bug。 这时shrinkwrap就应运而生，但是大家都懒得写，所以npm在5+版本之后，收到yarn.lock的启发，默认会在安装时生成package-loack文件。 举个例子 总结package-lock是用来严格控制版本依赖的。 package-lock.json 详细解析package-lock.json会为npm修改node_modules树或的任何操作自动生成package.json。它描述了生成的确切树，因此无论中间依赖项更新如何，后续安装都可以生成相同的树。该文件旨在提交到源存储库中，并具有多种用途： 描述依赖关系树的单个表示，这样可以确保队友，部署和持续集成安装完全相同的依赖关系。 为用户提供一种工具，使其可以“时间旅行”到以前的状态，node_modules而不必提交目录本身。 为了通过可读的源代码控制差异更好地了解树的变化。 并允许npm跳过以前安装的软件包的重复元数据解析，从而优化安装过程。 关于package-lock.json它的一个关键细节是它无法发布，并且如果在顶级软件包之外的任何地方找到它，它将被忽略。它与共享格式npm-shrinkwrap.json，该文件本质上是相同的文件，但可以发布。除非部署CLI工具或使用发布过程来生产生产软件包，否则不建议这样做。如果软件包的根目录中同时存在package-lock.json和npm-shrinkwrap.json，package-lock.json将被完全忽略。 文件格式name这是程序包锁定的程序包名称。这必须与中的内容匹配 package.json。 version这是程序包锁定的程序包版本。这必须与中的内容匹配 package.json。 lockfileVersion整数版本，1从此文档的版本号开始，在生成this时使用了其语义package-lock.json。 packageIntegrity这是从中创建的子资源完整性值package.json。package.json不应进行任何预处理。子资源完整性字符串可由类似的模块生成 ssri。 preserveSymlinks表示安装是在NODE_PRESERVE_SYMLINKS启用环境变量的情况下完成的 。安装程序应坚持使该属性的值与该环境变量匹配。 dependencies程序包名称到依赖对象的映射。依赖项对象具有以下属性：version这是一个说明符，可唯一标识此程序包，并应可用于获取其新副本。 捆绑的依赖关系：不管来源如何，这都是一个纯粹用于参考目的的版本号。 注册表源：这是一个版本号。（例如，1.2.3） git源：这是一个具有已解决承诺的git说明符。（例如，git+https://example.com/foo/bar#115311855adb0789a0466714ed48a1499ffea97e） http tarball来源：这是tarball的URL。（例如，[https://example.com/example-1.3.0.tgz](https://example.com/example-1.3.0.tgz)） 本地tarball来源：这是tarball的文件URL。（例如file:///opt/storage/example-1.3.0.tgz） 本地链接源：这是链接的文件URL。（例如file:libs/our-module） integrity这是此资源的标准子资源完整性。 对于捆绑的依赖项，无论来源如何，均不包括在内。 对于注册表源，这是integrity注册表提供的，或者如果未提供SHA1 shasum。 对于git源，这是我们从中克隆的特定提交哈希。 对于远程tarball源，这是基于文件SHA512的完整性。 对于本地tarball源：这是基于文件SHA512的完整性字段。 resolved 对于捆绑的依赖项，无论来源如何，均不包括在内。 对于注册表源，这是相对于注册表URL的压缩包的路径。如果tarball URL与注册表URL不在同一服务器上，则这是完整的URL。 bundled如果为true，则为捆绑的依赖关系，并将由父模块安装。安装时，此模块将在提取阶段从父模块中提取，而不是作为单独的依赖项安装。 dev如果为true，则此依赖项仅是顶层模块的开发依赖项，或者是一个传递性依赖项。对于既是顶层的开发依赖关系又是顶层的非开发依赖关系的传递依赖关系的依赖关系，这是错误的。 optional如果为true，则此依赖项仅是顶层模块的可选依赖项，或者是一个传递性依赖项。对于既是顶层的可选依赖关系又是顶层的非可选依赖关系的传递性依赖关系的依赖关系，则为false。即使所有可选依赖项都可以在当前平台上卸载，也应包括在内。 requires这是模块名称到版本的映射。这是此模块所需的所有内容的列表，无论它将安装在何处。版本应通过正常匹配规则匹配我们dependencies或更高级别的依赖关系 。 dependencies此依赖关系的依赖关系，与顶层完全相同。","link":"/2021/04/02/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E4%BB%80%E4%B9%88package-lock.json%20_/"},{"title":"再次梳理AMD、CMD、CommonJS、ES6 Module的区别","text":"前言回想起之前的一次面试，第一轮面试官问我 AMD 和 CMD 的区别，我只回答说 AMD 是提前加载，CMD 是按需加载。第二轮面试官又问了我 CommonJS 和 ES6 Module 的区别，emmm…，我大致回答说新的比旧的好~~，虽然面试官并没有说什么，不过显然这样的答案并不是有助于面试、有助于自己的技术积累的。所以有必要进行一次梳理，以便更清晰地了解它们的特点及差异。 AMDAMD 一开始是 CommonJS 规范中的一个草案，全称是 Asynchronous Module Definition，即异步模块加载机制。后来由该草案的作者以 RequireJS 实现了 AMD 规范，所以一般说 AMD 也是指 RequireJS。 RequireJS 的基本用法通过define来定义一个模块，使用require可以导入定义的模块。 1234567891011//a.js//define可以传入三个参数，分别是字符串-模块名、数组-依赖模块、函数-回调函数define(function(){ return 1;})// b.js//数组中声明需要加载的模块，可以是模块名、js文件路径require(['a'], function(a){ console.log(a);// 1}); RequireJS 的特点对于依赖的模块，AMD 推崇依赖前置，提前执行。也就是说，在define方法里传入的依赖模块 (数组)，会在一开始就下载并执行。 CMDCMD 是 SeaJS 在推广过程中生产的对模块定义的规范，在 Web 浏览器端的模块加载器中，SeaJS 与 RequireJS 并称，SeaJS 作者为阿里的玉伯。 SeaJS 的基本用法12345678910111213141516171819//a.js/** define 接受 factory 参数，factory 可以是一个函数，也可以是一个对象或字符串，* factory 为对象、字符串时，表示模块的接口就是该对象、字符串。* define 也可以接受两个以上参数。字符串 id 表示模块标识，数组 deps 是模块依赖.*/define(function(require, exports, module) { var $ = require('jquery'); exports.setColor = function() { $('body').css('color','#333'); };});//b.js//数组中声明需要加载的模块，可以是模块名、js文件路径seajs.use(['a'], function(a) { $('#el').click(a.setColor);}); SeaJS 的特点对于依赖的模块，CMD 推崇依赖就近，延迟执行。也就是说，只有到require时依赖模块才执行。 CommonJSCommonJS 规范为 CommonJS 小组所提出，目的是弥补 JavaScript 在服务器端缺少模块化机制，NodeJS、webpack 都是基于该规范来实现的。 CommonJS 的基本用法1234567891011121314151617181920//a.jsmodule.exports = function () { console.log(&quot;hello world&quot;)}//b.jsvar a = require('./a');a();//&quot;hello world&quot;//或者//a2.jsexports.num = 1;exports.obj = {xx: 2};//b2.jsvar a2 = require('./a2');console.log(a2);//{ num: 1, obj: { xx: 2 } } CommonJS 的特点 所有代码都运行在模块作用域，不会污染全局作用域； 模块是同步加载的，即只有加载完成，才能执行后面的操作； 模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存； CommonJS 输出是值的拷贝 (即，require返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值)。 ES6 ModuleES6 Module 是 ES6 中规定的模块体系，相比上面提到的规范， ES6 Module 有更多的优势，有望成为浏览器和服务器通用的模块解决方案。 ES6 Module 的基本用法12345678910111213141516171819202122//a.jsvar name = 'lin';var age = 13;var job = 'ninja';export { name, age, job};//b.jsimport { name, age, job} from './a.js';console.log(name, age, job);// lin 13 ninja//或者//a2.jsexport default function () { console.log('default ');}//b2.jsimport customName from './a2.js';customName(); // 'default' ES6 Module 的特点 (对比 CommonJS) CommonJS 模块是运行时加载，ES6 Module 是编译时输出接口； CommonJS 加载的是整个模块，将所有的接口全部加载进来，ES6 Module 可以单独加载其中的某个接口； CommonJS 输出是值的拷贝，ES6 Module 输出的是值的引用，被输出模块的内部的改变会影响引用的改变； CommonJS this指向当前模块，ES6 Module this指向undefined; 目前浏览器对 ES6 Module 兼容还不太好，我们平时在 webpack 中使用的export/import，会被打包为exports/require。 写在后面这里比较宽泛地把 JavaScript 中的几大模块化规范列举出来，希望借此对 JavaScript 模块化有大致的认识，而未对细节展开具体分析，感兴趣的可以自行探索。https://juejin.cn/post/6844903983987834888","link":"/2021/04/02/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%86%8D%E6%AC%A1%E6%A2%B3%E7%90%86AMD%E3%80%81CMD%E3%80%81CommonJS%E3%80%81ES6%20Module%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"私有npm仓库搭建与使用","text":"NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 一、为什么需要私有npm仓库 安全：内部源码不能发布到npm上开源，避免业务代码公开 免费：在npm上发布私有内容需要收费 效率：统一管理积累内部开发资源，提高开发效率 二、技术选型 sinopia 不考虑，好几年没更新了 cnpmjs 太笨重了，使用的方式基于作用域，略显繁琐 verdaccio 轻量，使用简单，基于registry的概念，侵入少 👏👏👏👌 三、verdaccio搭建步骤-使用docker-安装在一组开发服务器上1.下载镜像 docker pull verdaccio/verdaccio 2.容器启动配置在 /alidata/www 目录下新建 npm 文件夹，并且创建 docker-compose.yml 配置文件 docker-compose是用来编排容器的，主要作用是将容器配置写在配置文件中，避免每次启动都需要手动运行 docker run 一堆东西。 cd /alidata/wwwmkdir npm &amp;&amp; touch npm/docker-compose.yml 写入以下配置 12345678910111213141516171819version: '2'services: verdaccio: image: verdaccio/verdaccio container_name: verdaccio networks: - node-network environment: - VERDACCIO_PORT=4873 ports: - 4873:4873 volumes: - ./storage:/verdaccio/storage - ./conf:/verdaccio/conf - ./plugins:/verdaccio/pluginsnetworks: node-network: driver: bridge 主要做了这些事情 将 npm/storage 目录挂载到容器的 /verdaccio/storage 将 npm/conf 目录挂载到容器的 /verdaccio/conf 将 npm/plugins 目录挂载到容器的 /verdaccio/plugins 容器和主机端口都设置为4873 /alidata/www/npm 文件夹下的内容可以定期git提交到云效，进行备份。主要包括用户资料，包代码。 3.verdaccio配置 配置说明文档 链接 在 /alidata/www/npm/conf 下新建一个文件 touch npm/conf/config.yaml 123456789101112131415161718storage: /verdaccio/storageauth: htpasswd: file: /verdaccio/conf/htpasswduplinks: npmjs: url: https://registry.npm.taobao.org/packages: # scope packages '@scope/*': access: $all publish: $authenticated proxy: npmjs '**': access: $all proxy: npmjslogs: - {type: stdout, format: pretty, level: http} htpasswd 存放的是 npm 用户及密码信息的文件。 uplinks 配置了npm替代地址，这里配置了淘宝源。如果在当前仓库找不相应软件包，就到uplinks配置的源获取。 4.启动容器 docker-compose up -d –build 5.nginx配置先找到一组服务器的配置文件 ps aux|grep nginx 在 /rrzuji/nginx/conf/vhosts 下新建配置 12345678server { listen 80; server_name npm.rruzji.net; location / { proxy_pass http://127.0.0.1:4873/; proxy_set_header Host $host; }} 6.访问服务 npm.rrzuji.net出现以下界面说明容器已经正常运行 7.设置访问权限尝试新建用户，发现出现500错误查看docker日志，提示 permission denied 显然，这是一个文件权限问题，容器无法访问宿主路径。 docker logs –tail 20 verdaccio 查看文档 执行下面代码，10001是容器内verdaccio使用的UID，65533是GID sudo chown -R 10001:65533 /alidata/www/npm/conf/htpasswdsudo chown -R 10001:65533 /alidata/www/npm/storage 测试功能是否正常 到这里安装已经结束。接下来介绍一下如何使用以及注意事项。 四、使用方法1.安装nrm没有安装nrm的可以先安装nrm，nrm是用来给npm快速换源的工具。安装好之后，新增一个名为 rnpm 的源。 npm i nrm -gnrm add rnpm http://npm.rrzuji.net http://npm.rrzuji.net 相当于私有源+淘宝源的组合，以下统称rnpm。 2.用户注册 3.用户登录这个登录表示用户登录到rnpm，会在 userconfig 的文件里新增一条登录信息，不会影响到旧的npm用户授权认证记录。nrm use npm 切换后，就变成了npm用户，再 nrm use rnpm，就变成了 rnpm用户。 4.上传软件包登录后，就可以上传软件包了，进入到软件包目录，执行 npm publish 注意，提交的软件包名需要为私有库的格式(@scope/*)，同时也是为了和普通的包区别开来，否则会被拦截。 5.项目安装使用安装私有包 npm install @scope/browser-version-tool-html 安装私有包和公共npm仓库的包，这是一个混用的例子 npm install @scope/browser-version-tool-html axios 6.删除软件包 npm unpublish 7.更新软件包更新版本号后，重新发布进行更新 npm publish","link":"/2021/04/02/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E7%A7%81%E6%9C%89npm%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"title":"经典题解-回溯法和动态规划","text":"题目数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的 **括号组合。示例：输入：n = 3输出：[ “((()))”, “(()())”, “(())()”, “()(())”, “()()()” ] 解法 回溯法判断回溯很简单，拿到一个问题，你感觉如果不穷举一下就没法知道答案，那就可以开始回溯了。一般回溯的问题有三种： Find a path to success 有没有解 Find all paths to success 求所有解 求所有解的个数 求所有解的具体信息 Find the best path to success 求最优解 回溯法是一个剪枝了的二叉树。我们要得到的结果是可以 good leaf，如果不满足 good leaf 就继续向下搜索，搜索的时候需要满足一定的条件。从上面的图片中我们可以很明显的看到，最后五条画黑线的就是最终的结果，其中左分支都是添加左括号，右分支都是添加右括号。那么我们在什么情况下添加左括号呢？很明显，最多能添加 n 个左括号，在递归调用的时候，在能传递到最底层的共用字符串中先添加 ”(“ ，然后 left-1，递归调用就可以。那什么时候添加右括号呢？当左括号个数大于右括号的个数时添加右括号。总之，向下搜索要满足两个条件： 插入数量不超过n 可以插入 ） 的前提是 ( 的数量大于 ） 回溯法的代码套路是使用两个变量： res 和 path，res 表示最终的结果，path 保存已经走过的路径。如果搜到一个状态满足题目要求，就把 path 放到 res 中。代码后面的判断条件都是 if，而不是 elif，因为是满足两个条件的任意一个就可以继续向下搜索，而不是同时只能满足其中的一个。 12345678910111213141516171819202122/** * @param {number} n * @return {string[]} */var generateParenthesis = function(n) { // 保存所有有效路径 let res = []; dfs(res, n, n, ''); return res;};function dfs(res, left, right, path) { if (right === 0) { return res.push(path); } if (left &gt; 0) { dfs(res, left - 1, right , path + '('); } if (right &gt; left) { dfs(res, left, right - 1 , path + ')'); }} 动态规划什么是动态规划？在此题中，动态规划的思想类似于数学归纳法，当知道所有 i&lt;n 的情况时，我们可以通过某种算法算出 i=n 的情况。 123dp递推公式：dp[i]=&quot;(&quot;+dp[m]+&quot;)&quot;+dp[k]其中m+k=i-1 本题最核心的思想是，考虑 i=n 时相比 n-1 组括号增加的那一组括号的位置。当我们清楚所有 i&lt;n 时括号的可能生成排列后，对与 i=n 的情况，我们考虑整个括号排列中最左边的括号。它一定是一个左括号，那么它可以和它对应的右括号组成一组完整的括号 “( )”，我们认为这一组是相比 n-1 增加进来的括号。那么，剩下 n-1 组括号有可能在哪呢？剩下的括号要么在这一组新增的括号内部，要么在这一组新增括号的外部（右侧）。既然知道了 i&lt;n 的情况，那我们就可以对所有情况进行遍历：“(“ + 【i=p时所有括号的排列组合】 + “)” + 【i=q时所有括号的排列组合】其中 p + q = n-1，且 p q 均为非负整数。事实上，当上述 p 从 0 取到 n-1，q 从 n-1 取到 0 后，所有情况就遍历完了。注：上述遍历是没有重复情况出现的，即当 (p1,q1)≠(p2,q2) 时，按上述方式取的括号组合一定不同。 123456789101112131415161718192021222324/** * @param {number} n * @return {string[]} */var generateParenthesis = function (n) { const cache = []; cache[0] = [&quot;&quot;]; cache[1] = [&quot;()&quot;]; for (let i = 2; i &lt;= n; i++) { const temp = []; for (let j = 0; j &lt; i; j++) { const list1 = cache[j]; const list2 = cache[i - 1 - j]; for (let k1 of list1) { for (let k2 of list2) { temp.push(&quot;(&quot; + k1 + &quot;)&quot; + k2); } } } cache.push(temp); } return cache[n];}; 原文链接：[https://leetcode-cn.com/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/](https://leetcode-cn.com/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/)原文链接：[https://leetcode-cn.com/problems/generate-parentheses](https://leetcode-cn.com/problems/generate-parentheses)原文链接：[https://leetcode-cn.com/problems/generate-parentheses/solution/ru-men-ji-bie-de-hui-su-fa-xue-hui-tao-lu-miao-don/](https://leetcode-cn.com/problems/generate-parentheses/solution/ru-men-ji-bie-de-hui-su-fa-xue-hui-tao-lu-miao-don/)","link":"/2021/04/02/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E9%A2%98%E8%A7%A3-%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"","text":"JavaScript 深入之头疼的类型转换(上)在 JavaScript 中，有一部分内容，情况复杂，容易出错，饱受争议但又应用广泛，这便是类型转换。 前言将值从一种类型转换为另一种类型通常称为类型转换。 ES6 前，JavaScript 共有六种数据类型：Undefined、Null、Boolean、Number、String、Object。 我们先捋一捋基本类型之间的转换。 原始值转布尔我们使用 Boolean 函数将类型转换成布尔类型，在 JavaScript 中，只有 6 种值可以被转换成 false，其他都会被转换成 true。 12345678910console.log(Boolean()) // falseconsole.log(Boolean(false)) // falseconsole.log(Boolean(undefined)) // falseconsole.log(Boolean(null)) // falseconsole.log(Boolean(+0)) // falseconsole.log(Boolean(-0)) // falseconsole.log(Boolean(NaN)) // falseconsole.log(Boolean(&quot;&quot;)) // false 注意，当 Boolean 函数不传任何参数时，会返回 false。 原始值转数字我们可以使用 Number 函数将类型转换成数字类型，如果参数无法被转换为数字，则返回 NaN。 在看例子之前，我们先看 ES5 规范 15.7.1.1 中关于 Number 的介绍： 根据规范，如果 Number 函数不传参数，返回 +0，如果有参数，调用 ToNumber(value)。 注意这个 ToNumber 表示的是一个底层规范实现上的方法，并没有直接暴露出来。 而 ToNumber 则直接给了一个对应的结果表。表如下： 参数类型 结果 Undefined NaN Null +0 Boolean 如果参数是 true，返回 1。参数为 false，返回 +0 Number 返回与之相等的值 String 这段比较复杂，看例子 让我们写几个例子验证一下： 12345678910111213141516171819202122console.log(Number()) // +0console.log(Number(undefined)) // NaNconsole.log(Number(null)) // +0console.log(Number(false)) // +0console.log(Number(true)) // 1console.log(Number(&quot;123&quot;)) // 123console.log(Number(&quot;-123&quot;)) // -123console.log(Number(&quot;1.2&quot;)) // 1.2console.log(Number(&quot;000123&quot;)) // 123console.log(Number(&quot;-000123&quot;)) // -123console.log(Number(&quot;0x11&quot;)) // 17console.log(Number(&quot;&quot;)) // 0console.log(Number(&quot; &quot;)) // 0console.log(Number(&quot;123 123&quot;)) // NaNconsole.log(Number(&quot;foo&quot;)) // NaNconsole.log(Number(&quot;100a&quot;)) // NaN 如果通过 Number 转换函数传入一个字符串，它会试图将其转换成一个整数或浮点数，而且会忽略所有前导的 0，如果有一个字符不是数字，结果都会返回 NaN，鉴于这种严格的判断，我们一般还会使用更加灵活的 parseInt 和 parseFloat 进行转换。 parseInt 只解析整数，parseFloat 则可以解析整数和浮点数，如果字符串前缀是 “0x” 或者 “0X”，parseInt 将其解释为十六进制数，parseInt 和 parseFloat 都会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容。如果第一个非空格字符是非法的数字直接量，将最终返回 NaN： 123456console.log(parseInt(&quot;3 abc&quot;)) // 3console.log(parseFloat(&quot;3.14 abc&quot;)) // 3.14console.log(parseInt(&quot;-12.34&quot;)) // -12console.log(parseInt(&quot;0xFF&quot;)) // 255console.log(parseFloat(&quot;.1&quot;)) // 0.1console.log(parseInt(&quot;0.1&quot;)) // 0 原始值转字符我们使用 String 函数将类型转换成字符串类型，依然先看 规范 15.5.1.1中有关 String 函数的介绍： 如果 String 函数不传参数，返回空字符串，如果有参数，调用 ToString(value)，而 ToString 也给了一个对应的结果表。表如下： 参数类型 结果 Undefined “undefined” Null “null” Boolean 如果参数是 true，返回 “true”。参数为 false，返回 “false” Number 又是比较复杂，可以看例子 String 返回与之相等的值 让我们写几个例子验证一下： 1234567891011121314console.log(String()) // 空字符串console.log(String(undefined)) // undefinedconsole.log(String(null)) // nullconsole.log(String(false)) // falseconsole.log(String(true)) // trueconsole.log(String(0)) // 0console.log(String(-0)) // 0console.log(String(NaN)) // NaNconsole.log(String(Infinity)) // Infinityconsole.log(String(-Infinity)) // -Infinityconsole.log(String(1)) // 1 注意这里的 ToString 和上一节的 ToNumber 都是底层规范实现的方法，并没有直接暴露出来。 原始值转对象原始值到对象的转换非常简单，原始值通过调用 String()、Number() 或者 Boolean() 构造函数，转换为它们各自的包装对象。 null 和 undefined 属于例外，当将它们用在期望是一个对象的地方都会造成一个类型错误 (TypeError) 异常，而不会执行正常的转换。 1234var a = 1;console.log(typeof a); // numbervar b = new Number(a);console.log(typeof b); // object 对象转布尔值对象到布尔值的转换非常简单：所有对象 (包括数组和函数) 都转换为 true。对于包装对象也是这样，举个例子： 1console.log(Boolean(new Boolean(false))) // true 对象转字符串和数字对象到字符串和对象到数字的转换都是通过调用待转换对象的一个方法来完成的。而 JavaScript 对象有两个不同的方法来执行转换，一个是 toString，一个是 valueOf。注意这个跟上面所说的 ToString 和 ToNumber 是不同的，这两个方法是真实暴露出来的方法。 所有的对象除了 null 和 undefined 之外的任何值都具有 toString 方法，通常情况下，它和使用 String 方法返回的结果一致。toString 方法的作用在于返回一个反映这个对象的字符串，然而这才是情况复杂的开始。 在《JavaScript 专题之类型判断 (上)》中讲到过 Object.prototype.toString 方法会根据这个对象的[[class]]内部属性，返回由 “[object “和 class 和”]” 三个部分组成的字符串。举个例子： 123Object.prototype.toString.call({a: 1}) // &quot;[object Object]&quot;({a: 1}).toString() // &quot;[object Object]&quot;({a: 1}).toString === Object.prototype.toString // true 我们可以看出当调用对象的 toString 方法时，其实调用的是 Object.prototype 上的 toString 方法。 然而 JavaScript 下的很多类根据各自的特点，定义了更多版本的 toString 方法。例如: 数组的 toString 方法将每个数组元素转换成一个字符串，并在元素之间添加逗号后合并成结果字符串。 函数的 toString 方法返回源代码字符串。 日期的 toString 方法返回一个可读的日期和时间字符串。 RegExp 的 toString 方法返回一个表示正则表达式直接量的字符串。 读文字太抽象？我们直接写例子： 12345678console.log(({}).toString()) // [object Object]console.log([].toString()) // &quot;&quot;console.log([0].toString()) // 0console.log([1, 2, 3].toString()) // 1,2,3console.log((function(){var a = 1;}).toString()) // function (){var a = 1;}console.log((/\\d+/g).toString()) // /\\d+/gconsole.log((new Date(2010, 0, 1)).toString()) // Fri Jan 01 2010 00:00:00 GMT+0800 (CST) 而另一个转换对象的函数是 valueOf，表示对象的原始值。默认的 valueOf 方法返回这个对象本身，数组、函数、正则简单的继承了这个默认方法，也会返回对象本身。日期是一个例外，它会返回它的一个内容表示: 1970 年 1 月 1 日以来的毫秒数。 12var date = new Date(2017, 4, 21);console.log(date.valueOf()) // 1495296000000 对象接着转字符串和数字了解了 toString 方法和 valueOf 方法，我们分析下从对象到字符串是如何转换的。看规范 ES5 9.8，其实就是 ToString 方法的对应表，只是这次我们加上 Object 的转换规则： 参数类型 结果 Object 1. primValue = ToPrimitive(input, String) 2. 返回 ToString(primValue). 所谓的 ToPrimitive 方法，其实就是输入一个值，然后返回一个一定是基本类型的值。 我们总结一下，当我们用 String 方法转化一个值的时候，如果是基本类型，就参照 “原始值转字符” 这一节的对应表，如果不是基本类型，我们会将调用一个 ToPrimitive 方法，将其转为基本类型，然后再参照 “原始值转字符” 这一节的对应表进行转换。 其实，从对象到数字的转换也是一样： 参数类型 结果 Object 1. primValue = ToPrimitive(input, Number) 2. 返回 ToNumber(primValue)。 虽然转换成基本值都会使用 ToPrimitive 方法，但传参有不同，最后的处理也有不同，转字符串调用的是 ToString，转数字调用 ToNumber。 ToPrimitive那接下来就要看看 ToPrimitive 了，在了解了 toString 和 valueOf 方法后，这个也很简单。 让我们看规范 9.1，函数语法表示如下： 1ToPrimitive(input[, PreferredType]) 第一个参数是 input，表示要处理的输入值。 第二个参数是 PreferredType，非必填，表示希望转换成的类型，有两个值可以选，Number 或者 String。 当不传入 PreferredType 时，如果 input 是日期类型，相当于传入 String，否则，都相当于传入 Number。 如果传入的 input 是 Undefined、Null、Boolean、Number、String 类型，直接返回该值。 如果是 ToPrimitive(obj, Number)，处理步骤如下： 如果 obj 为 基本类型，直接返回 否则，调用 valueOf 方法，如果返回一个原始值，则 JavaScript 将其返回。 否则，调用 toString 方法，如果返回一个原始值，则 JavaScript 将其返回。 否则，JavaScript 抛出一个类型错误异常。 如果是 ToPrimitive(obj, String)，处理步骤如下： 如果 obj 为 基本类型，直接返回 否则，调用 toString 方法，如果返回一个原始值，则 JavaScript 将其返回。 否则，调用 valueOf 方法，如果返回一个原始值，则 JavaScript 将其返回。 否则，JavaScript 抛出一个类型错误异常。 对象转字符串所以总结下，对象转字符串 (就是 Number() 函数) 可以概括为： 如果对象具有 toString 方法，则调用这个方法。如果他返回一个原始值，JavaScript 将这个值转换为字符串，并返回这个字符串结果。 如果对象没有 toString 方法，或者这个方法并不返回一个原始值，那么 JavaScript 会调用 valueOf 方法。如果存在这个方法，则 JavaScript 调用它。如果返回值是原始值，JavaScript 将这个值转换为字符串，并返回这个字符串的结果。 否则，JavaScript 无法从 toString 或者 valueOf 获得一个原始值，这时它将抛出一个类型错误异常。 对象转数字对象转数字的过程中，JavaScript 做了同样的事情，只是它会首先尝试 valueOf 方法 如果对象具有 valueOf 方法，且返回一个原始值，则 JavaScript 将这个原始值转换为数字并返回这个数字 否则，如果对象具有 toString 方法，且返回一个原始值，则 JavaScript 将其转换并返回。 否则，JavaScript 抛出一个类型错误异常。 举个例子： 12345678910console.log(Number({})) // NaNconsole.log(Number({a : 1})) // NaNconsole.log(Number([])) // 0console.log(Number([0])) // 0console.log(Number([1, 2, 3])) // NaNconsole.log(Number(function(){var a = 1;})) // NaNconsole.log(Number(/\\d+/g)) // NaNconsole.log(Number(new Date(2010, 0, 1))) // 1262275200000console.log(Number(new Error('a'))) // NaN 注意，在这个例子中，[] 和 [0] 都返回了 0，而 [1, 2, 3] 却返回了一个 NaN。我们分析一下原因： 当我们 Number([]) 的时候，先调用 [] 的 valueOf 方法，此时返回 []，因为返回了一个对象而不是原始值，所以又调用了 toString 方法，此时返回一个空字符串，接下来调用 ToNumber 这个规范上的方法，参照对应表，转换为 0, 所以最后的结果为 0。 而当我们 Number([1, 2, 3]) 的时候，先调用 [1, 2, 3] 的 valueOf 方法，此时返回 [1, 2, 3]，再调用 toString 方法，此时返回 1,2,3，接下来调用 ToNumber，参照对应表，因为无法转换为数字，所以最后的结果为 NaN。 JSON.stringify值得一提的是：JSON.stringify() 方法可以将一个 JavaScript 值转换为一个 JSON 字符串，实现上也是调用了 toString 方法，也算是一种类型转换的方法。下面讲一讲 JSON.stringify 的注意要点： 处理基本类型时，与使用 toString 基本相同，结果都是字符串，除了 undefined 12345console.log(JSON.stringify(null)) // nullconsole.log(JSON.stringify(undefined)) // undefined，注意这个undefined不是字符串的undefinedconsole.log(JSON.stringify(true)) // trueconsole.log(JSON.stringify(42)) // 42console.log(JSON.stringify(&quot;42&quot;)) // &quot;42&quot; 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。 1JSON.stringify([new Number(1), new String(&quot;false&quot;), new Boolean(false)]); // &quot;[1,&quot;false&quot;,false]&quot; 3.undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。 12345JSON.stringify({x: undefined, y: Object, z: Symbol(&quot;&quot;)}); // &quot;{}&quot;JSON.stringify([undefined, Object, Symbol(&quot;&quot;)]); // &quot;[null,null,null]&quot; 4.JSON.stringify 有第二个参数 replacer，它可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除。 123456789101112function replacer(key, value) { if (typeof value === &quot;string&quot;) { return undefined; } return value;}var foo = {foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 45, transport: &quot;car&quot;, month: 7};var jsonString = JSON.stringify(foo, replacer);console.log(jsonString)// {&quot;week&quot;:45,&quot;month&quot;:7} 123var foo = {foundation: &quot;Mozilla&quot;, model: &quot;box&quot;, week: 45, transport: &quot;car&quot;, month: 7};console.log(JSON.stringify(foo, ['week', 'month']));// {&quot;week&quot;:45,&quot;month&quot;:7} 如果一个被序列化的对象拥有 toJSON 方法，那么该 toJSON 方法就会覆盖该对象默认的序列化行为：不是那个对象被序列化，而是调用 toJSON 方法后的返回值会被序列化，例如： 12345678var obj = { foo: 'foo', toJSON: function () { return 'bar'; }};JSON.stringify(obj); // '&quot;bar&quot;'JSON.stringify({x: obj}); // '{&quot;x&quot;:&quot;bar&quot;}'","link":"/2021/04/02/JS/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/JavaScript%20%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%A4%B4%E7%96%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2(%E4%B8%8A)/"},{"title":"","text":"JavaScript 深入之浮点数精度前言0.1 + 0.2 是否等于 0.3 作为一道经典的面试题，已经广外熟知，说起原因，大家能回答出这是浮点数精度问题导致，也能辩证的看待这并非是 ECMAScript 这门语言的问题，今天就是具体看一下背后的原因。 数字类型ECMAScript 中的 Number 类型使用 IEEE754 标准来表示整数和浮点数值。所谓 IEEE754 标准，全称 IEEE 二进制浮点数算术标准，这个标准定义了表示浮点数的格式等内容。 在 IEEE754 中，规定了四种表示浮点数值的方式：单精确度（32 位）、双精确度（64 位）、延伸单精确度、与延伸双精确度。像 ECMAScript 采用的就是双精确度，也就是说，会用 64 位字节来储存一个浮点数。 浮点数转二进制我们来看下 1020 用十进制的表示： 1020 = 1 * 10^3 + 0 * 10^2 + 2 * 10^1 + 0 * 10^0 所以 1020 用十进制表示就是 1020……(哈哈) 如果 1020 用二进制来表示呢？ 1020 = 1 * 2^9 + 1 * 2^8 + 1 * 2^7 + 1 * 2^6 + 1 * 2^5 + 1 * 2^4 + 1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 0 * 2^0 所以 1020 的二进制为 1111111100 那如果是 0.75 用二进制表示呢？同理应该是： 0.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + … 因为使用的是二进制，这里的 abcd…… 的值的要么是 0 要么是 1。 那怎么算出 abcd…… 的值呢，我们可以两边不停的乘以 2 算出来，解法如下： 0.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4… 两边同时乘以 2 1 + 0.5 = a * 2^0 + b * 2^-1 + c * 2^-2 + d * 2^-3… (所以 a = 1) 剩下的： 0.5 = b * 2^-1 + c * 2^-2 + d * 2^-3… 再同时乘以 2 1 + 0 = b * 2^0 + c * 2^-2 + d * 2^-3… (所以 b = 1) 所以 0.75 用二进制表示就是 0.ab，也就是 0.11 然而不是所有的数都像 0.75 这么好算，我们来算下 0.1： 12345678910110.1 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + ...0 + 0.2 = a * 2^0 + b * 2^-1 + c * 2^-2 + ... (a = 0)0 + 0.4 = b * 2^0 + c * 2^-1 + d * 2^-2 + ... (b = 0)0 + 0.8 = c * 2^0 + d * 2^-1 + e * 2^-2 + ... (c = 0)1 + 0.6 = d * 2^0 + e * 2^-1 + f * 2^-2 + ... (d = 1)1 + 0.2 = e * 2^0 + f * 2^-1 + g * 2^-2 + ... (e = 1)0 + 0.4 = f * 2^0 + g * 2^-1 + h * 2^-2 + ... (f = 0)0 + 0.8 = g * 2^0 + h * 2^-1 + i * 2^-2 + ... (g = 0)1 + 0.6 = h * 2^0 + i * 2^-1 + j * 2^-2 + ... (h = 1).... 然后你就会发现，这个计算在不停的循环，所以 0.1 用二进制表示就是 0.00011001100110011…… 浮点数的存储虽然 0.1 转成二进制时是一个无限循环的数，但计算机总要储存吧，我们知道 ECMAScript 使用 64 位字节来储存一个浮点数，那具体是怎么储存的呢？这就要说回 IEEE754 这个标准了，毕竟是这个标准规定了存储的方式。 这个标准认为，一个浮点数 (Value) 可以这样表示： Value = sign * exponent * fraction 看起来很抽象的样子，简单理解就是科学计数法…… 比如 -1020，用科学计数法表示就是: -1 * 10^3 * 1.02 sign 就是 -1，exponent 就是 10^3，fraction 就是 1.02 对于二进制也是一样，以 0.1 的二进制 0.00011001100110011…… 这个数来说： 可以表示为： 1 * 2^-4 * 1.1001100110011…… 其中 sign 就是 1，exponent 就是 2^-4，fraction 就是 1.1001100110011…… 而当只做二进制科学计数法的表示时，这个 Value 的表示可以再具体一点变成： V = (-1)^S * (1 + Fraction) * 2^E (如果所有的浮点数都可以这样表示，那么我们存储的时候就把这其中会变化的一些值存储起来就好了) 我们来一点点看： (-1)^S 表示符号位，当 S = 0，V 为正数；当 S = 1，V 为负数。 再看 (1 + Fraction)，这是因为所有的浮点数都可以表示为 1.xxxx * 2^xxx 的形式，前面的一定是 1.xxx，那干脆我们就不存储这个 1 了，直接存后面的 xxxxx 好了，这也就是 Fraction 的部分。 最后再看 2^E 如果是 1020.75，对应二进制数就是 1111111100.11，对应二进制科学计数法就是 1 * 1.11111110011 * 2^9，E 的值就是 9，而如果是 0.1 ，对应二进制是 1 * 1.1001100110011…… * 2^-4， E 的值就是 -4，也就是说，E 既可能是负数，又可能是正数，那问题就来了，那我们该怎么储存这个 E 呢？ 我们这样解决，假如我们用 8 位字节来存储 E 这个数，如果只有正数的话，储存的值的范围是 0 ~ 254，而如果要储存正负数的话，值的范围就是 -127~127，我们在存储的时候，把要存储的数字加上 127，这样当我们存 -127 的时候，我们存 0，当存 127 的时候，存 254，这样就解决了存负数的问题。对应的，当取值的时候，我们再减去 127。 所以呢，真到实际存储的时候，我们并不会直接存储 E，而是会存储 E + bias，当用 8 个字节的时候，这个 bias 就是 127。 所以，如果要存储一个浮点数，我们存 S 和 Fraction 和 E + bias 这三个值就好了，那具体要分配多少个字节位来存储这些数呢？IEEE754 给出了标准： 在这个标准下： 我们会用 1 位存储 S，0 表示正数，1 表示负数。 用 11 位存储 E + bias，对于 11 位来说，bias 的值是 2^(11-1) - 1，也就是 1023。 用 52 位存储 Fraction。 举个例子，就拿 0.1 来看，对应二进制是 1 * 1.1001100110011…… * 2^-4， Sign 是 0，E + bias 是 -4 + 1023 = 1019，1019 用二进制表示是 1111111011，Fraction 是 1001100110011…… 对应 64 个字节位的完整表示就是： 0 01111111011 1001100110011001100110011001100110011001100110011010 同理, 0.2 表示的完整表示是： 0 01111111100 1001100110011001100110011001100110011001100110011010 所以当 0.1 存下来的时候，就已经发生了精度丢失，当我们用浮点数进行运算的时候，使用的其实是精度丢失后的数。 浮点数的运算关于浮点数的运算，一般由以下五个步骤完成：对阶、尾数运算、规格化、舍入处理、溢出判断。我们来简单看一下 0.1 和 0.2 的计算。 首先是对阶，所谓对阶，就是把阶码调整为相同，比如 0.1 是 1.1001100110011…… * 2^-4，阶码是 -4，而 0.2 就是 1.10011001100110...* 2^-3，阶码是 -3，两个阶码不同，所以先调整为相同的阶码再进行计算，调整原则是小阶对大阶，也就是 0.1 的 -4 调整为 -3，对应变成 0.11001100110011…… * 2^-3 接下来是尾数计算: 1234 0.1100110011001100110011001100110011001100110011001101+ 1.1001100110011001100110011001100110011001100110011010———————————————————————————————————————————————————————— 10.0110011001100110011001100110011001100110011001100111 我们得到结果为 10.0110011001100110011001100110011001100110011001100111 * 2^-3 将这个结果处理一下，即结果规格化，变成 1.0011001100110011001100110011001100110011001100110011(1) * 2^-2 括号里的 1 意思是说计算后这个 1 超出了范围，所以要被舍弃了。 再然后是舍入，四舍五入对应到二进制中，就是 0 舍 1 入，因为我们要把括号里的 1 丢了，所以这里会进一，结果变成 1.0011001100110011001100110011001100110011001100110100 * 2^-2 本来还有一个溢出判断，因为这里不涉及，就不讲了。 所以最终的结果存成 64 位就是 0 01111111101 0011001100110011001100110011001100110011001100110100 将它转换为 10 进制数就得到 0.30000000000000004440892098500626 因为两次存储时的精度丢失加上一次运算时的精度丢失，最终导致了 0.1 + 0.2 !== 0.3 其他12345678910111213// 十进制转二进制parseFloat(0.1).toString(2);=&gt; &quot;0.0001100110011001100110011001100110011001100110011001101&quot;// 二进制转十进制parseInt(1100100,2)=&gt; 100// 以指定的精度返回该数值对象的字符串表示(0.1 + 0.2).toPrecision(21)=&gt; &quot;0.300000000000000044409&quot;(0.3).toPrecision(21)=&gt; &quot;0.299999999999999988898&quot; 参考 why is 0.1+0.2 not equal to 0.3 in most programming languages IEEE-754 标准与浮点数运算 深入系列JavaScript 深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript 深入系列预计写十五篇左右，旨在帮大家捋顺 JavaScript 底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。","link":"/2021/04/02/JS/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/JavaScript%20%E6%B7%B1%E5%85%A5%E4%B9%8B%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6/"},{"title":"","text":"JavaScript深入之bind的模拟实现bind一句话介绍 bind: bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN ) 由此我们可以首先得出 bind 函数的两个特点： 返回一个函数 可以传入参数 返回函数的模拟实现从第一个特点开始，我们举个例子： 123456789101112var foo = { value: 1};function bar() { console.log(this.value);}// 返回了一个函数var bindFoo = bar.bind(foo); bindFoo(); // 1 关于指定 this 的指向，我们可以使用 call 或者 apply 实现，关于 call 和 apply 的模拟实现，可以查看《JavaScript 深入之 call 和 apply 的模拟实现》。我们来写第一版的代码： 12345678// 第一版Function.prototype.bind2 = function (context) { var self = this; return function () { return self.apply(context); }} 此外，之所以 return self.apply(context)，是考虑到绑定函数可能是有返回值的，依然是这个例子： 1234567891011var foo = { value: 1};function bar() { return this.value;}var bindFoo = bar.bind(foo);console.log(bindFoo()); // 1 传参的模拟实现接下来看第二点，可以传入参数。这个就有点让人费解了，我在 bind 的时候，是否可以传参呢？我在执行 bind 返回的函数的时候，可不可以传参呢？让我们看个例子： 12345678910111213141516var foo = { value: 1};function bar(name, age) { console.log(this.value); console.log(name); console.log(age);}var bindFoo = bar.bind(foo, 'daisy');bindFoo('18');// 1// daisy// 18 函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age! 这可咋办？不急，我们用 arguments 进行处理： 1234567891011121314// 第二版Function.prototype.bind2 = function (context) { var self = this; // 获取bind2函数从第二个参数到最后一个参数 var args = Array.prototype.slice.call(arguments, 1); return function () { // 这个时候的arguments是指bind返回的函数传入的参数 var bindArgs = Array.prototype.slice.call(arguments); return self.apply(context, args.concat(bindArgs)); }} 构造函数效果的模拟实现完成了这两点，最难的部分到啦！因为 bind 还有一个特点，就是 一个绑定函数也能使用 new 操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子： 12345678910111213141516171819202122232425var value = 2;var foo = { value: 1};function bar(name, age) { this.habit = 'shopping'; console.log(this.value); console.log(name); console.log(age);}bar.prototype.friend = 'kevin';var bindFoo = bar.bind(foo, 'daisy');var obj = new bindFoo('18');// undefined// daisy// 18console.log(obj.habit);console.log(obj.friend);// shopping// kevin 注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。 (哈哈，我这是为我的下一篇文章《JavaScript 深入系列之 new 的模拟实现》打广告)。 所以我们可以通过修改返回的函数的原型来实现，让我们写一下： 12345678910111213141516// 第三版Function.prototype.bind2 = function (context) { var self = this; var args = Array.prototype.slice.call(arguments, 1); var fBound = function () { var bindArgs = Array.prototype.slice.call(arguments); // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值 // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性 // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs)); } // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值 fBound.prototype = this.prototype; return fBound;} 如果对原型链稍有困惑，可以查看《JavaScript 深入之从原型到原型链》。 构造函数效果的优化实现但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转： 1234567891011121314151617// 第四版Function.prototype.bind2 = function (context) { var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () {}; var fBound = function () { var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); } fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;} 到此为止，大的问题都已经解决，给自己一个赞！o(￣▽￣)ｄ 三个小问题接下来处理些小问题: 1.apply 这段代码跟 MDN 上的稍有不同 在 MDN 中文版讲 bind 的模拟实现时，apply 这里的代码是： 1self.apply(this instanceof self ? this : context || this, args.concat(bindArgs)) 多了一个关于 context 是否存在的判断，然而这个是错误的！ 举个例子： 1234567891011var value = 2;var foo = { value: 1, bar: bar.bind(null)};function bar() { console.log(this.value);}foo.bar() // 2 以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1！ 所以这里不应该进行 context 的判断，大家查看 MDN 同样内容的英文版，就不存在这个判断！ (2018 年 3 月 27 日更新，中文版已经改了😀) 2. 调用 bind 的不是函数咋办？ 不行，我们要报错！ 123if (typeof this !== &quot;function&quot;) { throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);} 3. 我要在线上用 那别忘了做个兼容： 123Function.prototype.bind = Function.prototype.bind || function () { ……}; 当然最好是用 es5-shim 啦。 最终代码所以最最后的代码就是： 1234567891011121314151617181920Function.prototype.bind2 = function (context) { if (typeof this !== &quot;function&quot;) { throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;); } var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () {}; var fBound = function () { var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); } fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;}","link":"/2021/04/02/JS/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8Bbind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"},{"title":"","text":"JavaScript深入之call和apply的模拟实现call一句话介绍 call： call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。 举个例子： 123456789var foo = { value: 1};function bar() { console.log(this.value);}bar.call(foo); // 1 注意两点： call 改变了 this 的指向，指向到 foo bar 函数执行了 模拟实现第一步那么我们该怎么模拟实现这两个效果呢？ 试想当调用 call 的时候，把 foo 对象改造成如下： 12345678var foo = { value: 1, bar: function() { console.log(this.value) }};foo.bar(); // 1 这个时候 this 就指向了 foo，是不是很简单呢？ 但是这样却给 foo 对象本身添加了一个属性，这可不行呐！ 不过也不用担心，我们用 delete 再删除它不就好了~ 所以我们模拟的步骤可以分为： 将函数设为对象的属性 执行该函数 删除该函数 以上个例子为例，就是： 123456// 第一步foo.fn = bar// 第二步foo.fn()// 第三步delete foo.fn fn 是对象的属性名，反正最后也要删除它，所以起成什么都无所谓。 根据这个思路，我们可以尝试着去写第一版的 call2 函数： 123456789101112131415161718// 第一版Function.prototype.call2 = function(context) { // 首先要获取调用call的函数，用this可以获取 context.fn = this; context.fn(); delete context.fn;}// 测试一下var foo = { value: 1};function bar() { console.log(this.value);}bar.call2(foo); // 1 正好可以打印 1 哎！是不是很开心！(～￣▽￣)～ 模拟实现第二步最一开始也讲了，call 函数还能给定参数执行函数。举个例子： 1234567891011121314var foo = { value: 1};function bar(name, age) { console.log(name) console.log(age) console.log(this.value);}bar.call(foo, 'kevin', 18);// kevin// 18// 1 注意：传入的参数并不确定，这可咋办？ 不急，我们可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里。 比如这样： 1234567891011121314// 以上个例子为例，此时的arguments为：// arguments = {// 0: foo,// 1: 'kevin',// 2: 18,// length: 3// }// 因为arguments是类数组对象，所以可以用for循环var args = [];for(var i = 1, len = arguments.length; i &lt; len; i++) { args.push('arguments[' + i + ']');}// 执行后 args为 [&quot;arguments[1]&quot;, &quot;arguments[2]&quot;, &quot;arguments[3]&quot;] 不定长的参数问题解决了，我们接着要把这个参数数组放到要执行的函数的参数里面去。 1234// 将数组里的元素作为多个参数放进函数的形参里context.fn(args.join(','))// (O_o)??// 这个方法肯定是不行的啦！！！ 也许有人想到用 ES6 的方法，不过 call 是 ES3 的方法，我们为了模拟实现一个 ES3 的方法，要用到 ES6 的方法，好像……，嗯，也可以啦。但是我们这次用 eval 方法拼成一个函数，类似于这样： 1eval('context.fn(' + args +')') 这里 args 会自动调用 Array.toString() 这个方法。 所以我们的第二版克服了两个大问题，代码如下： 1234567891011121314151617181920212223242526// 第二版Function.prototype.call2 = function(context) { context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) { args.push('arguments[' + i + ']'); } eval('context.fn(' + args +')'); delete context.fn;}// 测试一下var foo = { value: 1};function bar(name, age) { console.log(name) console.log(age) console.log(this.value);}bar.call2(foo, 'kevin', 18); // kevin// 18// 1 (๑•̀ㅂ•́)و✧ 模拟实现第三步模拟代码已经完成 80%，还有两个小点要注意： 1.this 参数可以传 null，当为 null 的时候，视为指向 window 举个例子： 1234567var value = 1;function bar() { console.log(this.value);}bar.call(null); // 1 虽然这个例子本身不使用 call，结果依然一样。 2. 函数是可以有返回值的！ 举个例子： 123456789101112131415161718var obj = { value: 1}function bar(name, age) { return { value: this.value, name: name, age: age }}console.log(bar.call(obj, 'kevin', 18));// Object {// value: 1,// name: 'kevin',// age: 18// } 不过都很好解决，让我们直接看第三版也就是最后一版的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041// 第三版Function.prototype.call2 = function (context) { var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) { args.push('arguments[' + i + ']'); } var result = eval('context.fn(' + args +')'); delete context.fn return result;}// 测试一下var value = 2;var obj = { value: 1}function bar(name, age) { console.log(this.value); return { value: this.value, name: name, age: age }}bar.call2(null); // 2console.log(bar.call2(obj, 'kevin', 18));// 1// Object {// value: 1,// name: 'kevin',// age: 18// } 到此，我们完成了 call 的模拟实现，给自己一个赞 ｂ（￣▽￣）ｄ apply 的模拟实现apply 的实现跟 call 类似，在这里直接给代码，代码来自于知乎 @郑航的实现： 12345678910111213141516171819Function.prototype.apply = function (context, arr) { var context = Object(context) || window; context.fn = this; var result; if (!arr) { result = context.fn(); } else { var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) { args.push('arr[' + i + ']'); } result = eval('context.fn(' + args + ')') } delete context.fn return result;}","link":"/2021/04/02/JS/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8Bcall%E5%92%8Capply%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"},{"title":"","text":"JavaScript深入之new的模拟实现new一句话介绍 new: new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一 也许有点难懂，我们在模拟 new 之前，先看看 new 实现了哪些功能。 举个例子： 12345678910111213141516171819202122// Otaku 御宅族，简称宅function Otaku (name, age) { this.name = name; this.age = age; this.habit = 'Games';}// 因为缺乏锻炼的缘故，身体强度让人担忧Otaku.prototype.strength = 60;Otaku.prototype.sayYourName = function () { console.log('I am ' + this.name);}var person = new Otaku('Kevin', '18');console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // 60person.sayYourName(); // I am Kevin 从这个例子中，我们可以看到，实例 person 可以： 访问到 Otaku 构造函数里的属性 访问到 Otaku.prototype 中的属性 接下来，我们可以尝试着模拟一下了。 因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 objectFactory，来模拟 new 的效果。用的时候是这样的： 12345678function Otaku () { ……}// 使用 newvar person = new Otaku(……);// 使用 objectFactoryvar person = objectFactory(Otaku, ……) 初步实现分析： 因为 new 的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，假设这个对象叫 obj，因为 obj 会具有 Otaku 构造函数里的属性，想想经典继承的例子，我们可以使用 Otaku.apply(obj, arguments) 来给 obj 添加新的属性。 在 JavaScript 深入系列第一篇中，我们便讲了原型与原型链，我们知道实例的 proto 属性会指向构造函数的 prototype，也正是因为建立起这样的关系，实例可以访问原型上的属性。 现在，我们可以尝试着写第一版了： 1234567891011121314// 第一版代码function objectFactory() { var obj = new Object(), Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; Constructor.apply(obj, arguments); return obj;}; 在这一版中，我们： 用 new Object() 的方式新建了一个对象 obj 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数 将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性 返回 obj 更多关于： 原型与原型链，可以看《JavaScript 深入之从原型到原型链》 apply，可以看《JavaScript 深入之 call 和 apply 的模拟实现》 经典继承，可以看《JavaScript 深入之继承》 复制以下的代码，到浏览器中，我们可以做一下测试： 12345678910111213141516171819202122232425262728function Otaku (name, age) { this.name = name; this.age = age; this.habit = 'Games';}Otaku.prototype.strength = 60;Otaku.prototype.sayYourName = function () { console.log('I am ' + this.name);}function objectFactory() { var obj = new Object(), Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; Constructor.apply(obj, arguments); return obj;};var person = objectFactory(Otaku, 'Kevin', '18')console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // 60person.sayYourName(); // I am Kevin []** 返回值效果实现接下来我们再来看一种情况，假如构造函数有返回值，举个例子： 12345678910111213141516function Otaku (name, age) { this.strength = 60; this.age = age; return { name: name, habit: 'Games' }}var person = new Otaku('Kevin', '18');console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // undefinedconsole.log(person.age) // undefined 在这个例子中，构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。 而且还要注意一点，在这里我们是返回了一个对象，假如我们只是返回一个基本类型的值呢？ 再举个例子： 12345678910111213function Otaku (name, age) { this.strength = 60; this.age = age; return 'handsome boy';}var person = new Otaku('Kevin', '18');console.log(person.name) // undefinedconsole.log(person.habit) // undefinedconsole.log(person.strength) // 60console.log(person.age) // 18 结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。 所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。 再来看第二版的代码，也是最后一版的代码： 1234567891011121314// 第二版的代码function objectFactory() { var obj = new Object(), Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; var ret = Constructor.apply(obj, arguments); return typeof ret === 'object' ? ret : obj;};","link":"/2021/04/02/JS/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8Bnew%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"},{"title":"","text":"JavaScript深入之从ECMAScript规范解读this前言在《JavaScript 深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码 (executable code) 时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性 变量对象 (Variable object，VO) 作用域链 (Scope chain) this 今天重点讲讲 this，然而不好讲。 …… 因为我们要从 ECMASciript5 规范开始讲起。 先奉上 ECMAScript 5.1 规范地址： 英文版：http://es5.github.io/#x15.1 中文版：http://yanhaijing.com/es5/#115 让我们开始了解规范吧！ Types首先是第 8 章 Types： Types are further subclassified into ECMAScript language types and specification types. An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object. A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types are Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, and Environment Record. 我们简单的翻译一下： ECMAScript 的类型分为语言类型和规范类型。 ECMAScript 语言类型是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的 Undefined, Null, Boolean, String, Number, 和 Object。 而规范类型相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的。规范类型包括：Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, 和 Environment Record。 没懂？没关系，我们只要知道在 ECMAScript 规范中还有一种只存在于规范中的类型，它们的作用是用来描述语言底层行为逻辑。 今天我们要讲的重点是便是其中的 Reference 类型。它与 this 的指向有着密切的关联。 Reference那什么又是 Reference ？ 让我们看 8.7 章 The Reference Specification Type： The Reference type is used to explain the behaviour of such operators as delete, typeof, and the assignment operators. 所以 Reference 类型就是用来解释诸如 delete、typeof 以及赋值等操作行为的。 抄袭尤雨溪大大的话，就是： 这里的 Reference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中。 再看接下来的这段具体介绍 Reference 的内容： A Reference is a resolved name binding. A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag. The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1). A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String. 这段讲述了 Reference 的构成，由三个组成部分，分别是： base value referenced name strict reference 可是这些到底是什么呢？ 我们简单的理解的话： base value 就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。 referenced name 就是属性的名称。 举个例子： 12345678var foo = 1;// 对应的Reference是：var fooReference = { base: EnvironmentRecord, name: 'foo', strict: false}; 再举个例子： 1234567891011121314var foo = { bar: function () { return this; }}; foo.bar(); // foo// bar对应的Reference是：var BarReference = { base: foo, propertyName: 'bar', strict: false}; 而且规范中还提供了获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。 这两个方法很简单，简单看一看： 1.GetBase GetBase(V). Returns the base value component of the reference V. 返回 reference 的 base value。 2.IsPropertyReference IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false. 简单的理解：如果 base value 是一个对象，就返回 true。 GetValue除此之外，紧接着在 8.7.1 章规范中就讲了一个用于从 Reference 类型获取对应值的方法： GetValue。 简单模拟 GetValue 的使用： 123456789var foo = 1;var fooReference = { base: EnvironmentRecord, name: 'foo', strict: false};GetValue(fooReference) // 1; GetValue 返回对象属性真正的值，但是要注意： 调用 GetValue，返回的将是具体的值，而不再是一个 Reference 这个很重要，这个很重要，这个很重要。 如何确定 this 的值关于 Reference 讲了那么多，为什么要讲 Reference 呢？到底 Reference 跟本文的主题 this 有哪些关联呢？如果你能耐心看完之前的内容，以下开始进入高能阶段： 看规范 11.2.3 Function Calls： 这里讲了当函数调用的时候，如何确定 this 的取值。 只看第一步、第六步、第七步： 1.Let ref be the result of evaluating MemberExpression. 6.If Type(ref) is Reference, then 1a.If IsPropertyReference(ref) is true, then 1i.Let thisValue be GetBase(ref). 1b.Else, the base of ref is an Environment Record 1i.Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref). 7.Else, Type(ref) is not Reference. 1a. Let thisValue be undefined. 让我们描述一下： 计算 MemberExpression 的结果赋值给 ref 判断 ref 是不是一个 Reference 类型 123452.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref)2.3 如果 ref 不是 Reference，那么 this 的值为 undefined 具体分析让我们一步一步看： 计算 MemberExpression 的结果赋值给 ref 什么是 MemberExpression？看规范 11.2 Left-Hand-Side Expressions： MemberExpression : PrimaryExpression // 原始表达式 可以参见《JavaScript 权威指南第四章》 FunctionExpression // 函数定义表达式 MemberExpression [ Expression ] // 属性访问表达式 MemberExpression . IdentifierName // 属性访问表达式 new MemberExpression Arguments // 对象创建表达式 举个例子： 123456789101112131415161718192021function foo() { console.log(this)}foo(); // MemberExpression 是 foofunction foo() { return function() { console.log(this) }}foo()(); // MemberExpression 是 foo()var foo = { bar: function () { return this; }}foo.bar(); // MemberExpression 是 foo.bar 所以简单理解 MemberExpression 其实就是 () 左边的部分。 判断 ref 是不是一个 Reference 类型。 关键就在于看规范是如何处理各种 MemberExpression，返回的结果是不是一个 Reference 类型。 举最后一个例子： 12345678910111213141516171819var value = 1;var foo = { value: 2, bar: function () { return this.value; }}//示例1console.log(foo.bar());//示例2console.log((foo.bar)());//示例3console.log((foo.bar = foo.bar)());//示例4console.log((false || foo.bar)());//示例5console.log((foo.bar, foo.bar)()); foo.bar()在示例 1 中，MemberExpression 计算的结果是 foo.bar，那么 foo.bar 是不是一个 Reference 呢？ 查看规范 11.2.1 Property Accessors，这里展示了一个计算的过程，什么都不管了，就看最后一步： Return a value of type Reference whose base value is baseValue and whose referenced name is propertyNameString, and whose strict mode flag is strict. 我们得知该表达式返回了一个 Reference 类型！ 根据之前的内容，我们知道该值为： 12345var Reference = { base: foo, name: 'bar', strict: false}; 接下来按照 2.1 的判断流程走： 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 该值是 Reference 类型，那么 IsPropertyReference(ref) 的结果是多少呢？ 前面我们已经铺垫了 IsPropertyReference 方法，如果 base value 是一个对象，结果返回 true。 base value 为 foo，是一个对象，所以 IsPropertyReference(ref) 结果为 true。 这个时候我们就可以确定 this 的值了： GetBase 也已经铺垫了，获得 base value 值，这个例子中就是 foo，所以 this 的值就是 foo ，示例 1 的结果就是 2！ 唉呀妈呀，为了证明 this 指向 foo，真是累死我了！但是知道了原理，剩下的就更快了。 (foo.bar)()看示例 2： 1console.log((foo.bar)()); foo.bar 被 () 包住，查看规范 11.1.6 The Grouping Operator 直接看结果部分： Return the result of evaluating Expression. This may be of type Reference. NOTE This algorithm does not apply GetValue to the result of evaluating Expression. 实际上 () 并没有对 MemberExpression 进行计算，所以其实跟示例 1 的结果是一样的。 (foo.bar = foo.bar)()看示例 3，有赋值操作符，查看规范 11.13.1 Simple Assignment (=): 计算的第三步： 3.Let rval be GetValue(rref). 因为使用了 GetValue，所以返回的值不是 Reference 类型， 按照之前讲的判断逻辑： 2.3 如果 ref 不是 Reference，那么 this 的值为 undefined this 为 undefined，非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象。 (false || foo.bar)()看示例 4，逻辑与算法，查看规范 11.11 Binary Logical Operators： 计算第二步： 2.Let lval be GetValue(lref). 因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined (foo.bar, foo.bar)()看示例 5，逗号操作符，查看规范 11.14 Comma Operator (,) 计算第二步： 2.Call GetValue(lref). 因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined 揭晓结果所以最后一个例子的结果是： 12345678910111213141516171819var value = 1;var foo = { value: 2, bar: function () { return this.value; }}//示例1console.log(foo.bar()); // 2//示例2console.log((foo.bar)()); // 2//示例3console.log((foo.bar = foo.bar)()); // 1//示例4console.log((false || foo.bar)()); // 1//示例5console.log((foo.bar, foo.bar)()); // 1 注意：以上是在非严格模式下的结果，严格模式下因为 this 返回 undefined，所以示例 3 会报错。 补充最最后，忘记了一个最最普通的情况： 12345function foo() { console.log(this)}foo(); MemberExpression 是 foo，解析标识符，查看规范 10.3.1 Identifier Resolution，会返回一个 Reference 类型的值： 12345var fooReference = { base: EnvironmentRecord, name: 'foo', strict: false}; 接下来进行判断： 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 因为 base value 是 EnvironmentRecord，并不是一个 Object 类型，还记得前面讲过的 base value 的取值可能吗？ 只可能是 undefined, an Object, a Boolean, a String, a Number, 和 an environment record 中的一种。 IsPropertyReference(ref) 的结果为 false，进入下个判断： 2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么 this 的值为 ImplicitThisValue(ref) base value 正是 Environment Record，所以会调用 ImplicitThisValue(ref) 查看规范 10.2.1.1.6，ImplicitThisValue 方法的介绍：该函数始终返回 undefined。 所以最后 this 的值就是 undefined。 多说一句尽管我们可以简单的理解 this 为调用函数的对象，如果是这样的话，如何解释下面这个例子呢？ 123456789var value = 1;var foo = { value: 2, bar: function () { return this.value; }}console.log((false || foo.bar)()); // 1 此外，又如何确定调用函数的对象是谁呢？在写文章之初，我就面临着这些问题，最后还是放弃从多个情形下给大家讲解 this 指向的思路，而是追根溯源的从 ECMASciript 规范讲解 this 的指向，尽管从这个角度写起来和读起来都比较吃力，但是一旦多读几遍，明白原理，绝对会给你一个全新的视角看待 this 。而你也就能明白，尽管 foo() 和 (foo.bar = foo.bar)() 最后结果都指向了 undefined，但是两者从规范的角度上却有着本质的区别。 此篇讲解执行上下文的 this，即便不是很理解此篇的内容，依然不影响大家了解执行上下文这个主题下其他的内容。所以，依然可以安心的看下一篇文章。","link":"/2021/04/02/JS/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BB%8EECMAScript%E8%A7%84%E8%8C%83%E8%A7%A3%E8%AF%BBthis/"},{"title":"","text":"JavaScript深入之从原型到原型链构造函数创建对象我们先使用构造函数创建一个对象： 123456function Person() {}var person = new Person();person.name = 'Kevin';console.log(person.name) // Kevin 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。 很简单吧，接下来进入正题： prototype每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如： 12345678910function Person() {}// 虽然写在注释里，但是你要注意：// prototype是函数才会有的属性Person.prototype.name = 'Kevin';var person1 = new Person();var person2 = new Person();console.log(person1.name) // Kevinconsole.log(person2.name) // Kevin 那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？ 其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。 那什么是原型呢？你可以这样理解：每一个 JavaScript 对象 (null 除外) 在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型 “继承” 属性。 让我们用一张图表示构造函数和实例原型之间的关系： 在这张图中我们用 Object.prototype 表示实例原型。 那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性： proto这是每一个 JavaScript 对象 (除了 null) 都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。 为了证明这一点, 我们可以在火狐或者谷歌中输入： 12345function Person() {}var person = new Person();console.log(person.__proto__ === Person.prototype); // true 于是我们更新下关系图： 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。 为了验证这一点，我们可以尝试： 1234function Person() {}console.log(Person === Person.prototype.constructor); // true 所以再更新下关系图： 综上我们已经得出： 12345678910function Person() {}var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系： 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 举个例子： 12345678910111213function Person() {}Person.prototype.name = 'Kevin';var person = new Person();person.name = 'Daisy';console.log(person.name) // Daisydelete person.name;console.log(person.name) // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。 但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.proto ，也就是 Person.prototype 中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 但是万一还没有找到呢？原型的原型又是什么呢？ 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是： 123var obj = new Object();obj.name = 'Kevin'console.log(obj.name) // Kevin 其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 proto 指向构造函数的 prototype ，所以我们再更新下关系图： 原型链那 Object.prototype 的原型呢？ null，我们可以打印： 1console.log(Object.prototype.__proto__ === null) // true 然而 null 究竟代表了什么呢？ 引用阮一峰老师的 《undefined 与 null 的区别》 就是： null 表示 “没有对象”，即该处不应该有值。 所以 Object.prototype.proto 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。 所以查找属性的时候查到 Object.prototype 就可以停止查找了。 最后一张关系图也可以更新为： 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充最后，补充三点大家可能不会注意的地方： constructor首先是 constructor 属性，我们看个例子： 12345function Person() {}var person = new Person();console.log(person.constructor === Person); // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性, 当不能读取到 constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以： 1person.constructor === Person.prototype.constructor proto其次是 proto ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.proto 时，可以理解成返回了 Object.getPrototypeOf(obj)。 真的是继承吗？最后是关于继承，前面我们讲到 “每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的 JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。","link":"/2021/04/02/JS/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"title":"","text":"JavaScript深入之作用域链前言在《JavaScript 深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码 (executable code) 时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象 (Variable object，VO) 作用域链 (Scope chain) this 今天重点讲讲作用域链。 作用域链在《JavaScript 深入之变量对象》中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级 (词法层面上的父级) 执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 下面，让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。 函数创建在《JavaScript 深入之词法作用域和动态作用域》中讲到，函数的作用域在函数定义的时候就决定了。 这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！ 举个例子： 123456 function foo() { function bar() { ... }} 函数创建时，各自的[[scope]]为： 12345678foo.[[scope]] = [ globalContext.VO];bar.[[scope]] = [ fooContext.AO, globalContext.VO]; 函数激活当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。 这时候执行上下文的作用域链，我们命名为 Scope： 1Scope = [AO].concat([[Scope]]); 至此，作用域链创建完毕。 捋一捋以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程： 123456var scope = &quot;global scope&quot;;function checkscope(){ var scope2 = 'local scope'; return scope2;}checkscope(); 执行过程如下： 1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]] 123checkscope.[[scope]] = [ globalContext.VO]; 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1234ECStack = [ checkscopeContext, globalContext]; 3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链 123checkscopeContext = { Scope: checkscope.[[scope]],} 第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明 123456789checkscopeContext = { AO: { arguments: { length: 0 }, scope2: undefined }， Scope: checkscope.[[scope]],} 第三步：将活动对象压入 checkscope 作用域链顶端 123456789checkscopeContext = { AO: { arguments: { length: 0 }, scope2: undefined }, Scope: [AO, [[Scope]]]} 准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值 123456789checkscopeContext = { AO: { arguments: { length: 0 }, scope2: 'local scope' }, Scope: [AO, [[Scope]]]} 查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出 123ECStack = [ globalContext];","link":"/2021/04/02/JS/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%20(1)/"},{"title":"","text":"JavaScript深入之作用域链前言在《JavaScript 深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码 (executable code) 时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象 (Variable object，VO) 作用域链 (Scope chain) this 今天重点讲讲作用域链。 作用域链在《JavaScript 深入之变量对象》中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级 (词法层面上的父级) 执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 下面，让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。 函数创建在《JavaScript 深入之词法作用域和动态作用域》中讲到，函数的作用域在函数定义的时候就决定了。 这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！ 举个例子： 123456 function foo() { function bar() { ... }} 函数创建时，各自的[[scope]]为： 12345678foo.[[scope]] = [ globalContext.VO];bar.[[scope]] = [ fooContext.AO, globalContext.VO]; 函数激活当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。 这时候执行上下文的作用域链，我们命名为 Scope： 1Scope = [AO].concat([[Scope]]); 至此，作用域链创建完毕。 捋一捋以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程： 123456var scope = &quot;global scope&quot;;function checkscope(){ var scope2 = 'local scope'; return scope2;}checkscope(); 执行过程如下： 1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]] 123checkscope.[[scope]] = [ globalContext.VO]; 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1234ECStack = [ checkscopeContext, globalContext]; 3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链 123checkscopeContext = { Scope: checkscope.[[scope]],} 第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明 123456789checkscopeContext = { AO: { arguments: { length: 0 }, scope2: undefined }， Scope: checkscope.[[scope]],} 第三步：将活动对象压入 checkscope 作用域链顶端 123456789checkscopeContext = { AO: { arguments: { length: 0 }, scope2: undefined }, Scope: [AO, [[Scope]]]} 准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值 123456789checkscopeContext = { AO: { arguments: { length: 0 }, scope2: 'local scope' }, Scope: [AO, [[Scope]]]} 查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出 123ECStack = [ globalContext];","link":"/2021/04/02/JS/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"},{"title":"","text":"JavaScript深入之创建对象的多种方式以及优缺点写在前面这篇文章讲解创建对象的各种方式，以及优缺点。 但是注意： 这篇文章更像是笔记，因为《JavaScript 高级程序设计》写得真是太好了！ 1. 工厂模式1234567891011function createPerson(name) { var o = new Object(); o.name = name; o.getName = function () { console.log(this.name); }; return o;}var person1 = createPerson('kevin'); 缺点：对象无法识别，因为所有的实例都指向一个原型 2. 构造函数模式12345678function Person(name) { this.name = name; this.getName = function () { console.log(this.name); };}var person1 = new Person('kevin'); 优点：实例可以识别为一个特定的类型 缺点：每次创建实例时，每个方法都要被创建一次 2.1 构造函数模式优化12345678910function Person(name) { this.name = name; this.getName = getName;}function getName() { console.log(this.name);}var person1 = new Person('kevin'); 优点：解决了每个方法都要被重新创建的问题 缺点：这叫啥封装…… 3. 原型模式12345678910function Person(name) {}Person.prototype.name = 'keivn';Person.prototype.getName = function () { console.log(this.name);};var person1 = new Person(); 优点：方法不会重新创建 缺点：1. 所有的属性和方法都共享 2. 不能初始化参数 3.1 原型模式优化123456789101112function Person(name) {}Person.prototype = { name: 'kevin', getName: function () { console.log(this.name); }};var person1 = new Person(); 优点：封装性好了一点 缺点：重写了原型，丢失了 constructor 属性 3.2 原型模式优化12345678910111213function Person(name) {}Person.prototype = { constructor: Person, name: 'kevin', getName: function () { console.log(this.name); }};var person1 = new Person(); 优点：实例可以通过 constructor 属性找到所属构造函数 缺点：原型模式该有的缺点还是有 4. 组合模式构造函数模式与原型模式双剑合璧。 123456789101112function Person(name) { this.name = name;}Person.prototype = { constructor: Person, getName: function () { console.log(this.name); }};var person1 = new Person(); 优点：该共享的共享，该私有的私有，使用最广泛的方式 缺点：有的人就是希望全部都写在一起，即更好的封装性 4.1 动态原型模式12345678910function Person(name) { this.name = name; if (typeof this.getName != &quot;function&quot;) { Person.prototype.getName = function () { console.log(this.name); } }}var person1 = new Person(); 注意：使用动态原型模式时，不能用对象字面量重写原型 解释下为什么： 1234567891011121314151617181920function Person(name) { this.name = name; if (typeof this.getName != &quot;function&quot;) { Person.prototype = { constructor: Person, getName: function () { console.log(this.name); } } }}var person1 = new Person('kevin');var person2 = new Person('daisy');// 报错 并没有该方法person1.getName();// 注释掉上面的代码，这句是可以执行的。person2.getName(); 为了解释这个问题，假设开始执行var person1 = new Person('kevin')。 如果对 new 和 apply 的底层执行过程不是很熟悉，可以阅读底部相关链接中的文章。 我们回顾下 new 的实现步骤： 首先新建一个对象 然后将对象的原型指向 Person.prototype 然后 Person.apply(obj) 返回这个对象 注意这个时候，回顾下 apply 的实现步骤，会执行 obj.Person 方法，这个时候就会执行 if 语句里的内容，注意构造函数的 prototype 属性指向了实例的原型，使用字面量方式直接覆盖 Person.prototype，并不会更改实例的原型的值，person1 依然是指向了以前的原型，而不是 Person.prototype。而之前的原型是没有 getName 方法的，所以就报错了！ 如果你就是想用字面量方式写代码，可以尝试下这种： 12345678910111213141516171819function Person(name) { this.name = name; if (typeof this.getName != &quot;function&quot;) { Person.prototype = { constructor: Person, getName: function () { console.log(this.name); } } return new Person(name); }}var person1 = new Person('kevin');var person2 = new Person('daisy');person1.getName(); // kevinperson2.getName(); // daisy 5.1 寄生构造函数模式123456789101112131415function Person(name) { var o = new Object(); o.name = name; o.getName = function () { console.log(this.name); }; return o;}var person1 = new Person('kevin');console.log(person1 instanceof Person) // falseconsole.log(person1 instanceof Object) // true 寄生构造函数模式，我个人认为应该这样读： 寄生 - 构造函数 - 模式，也就是说寄生在构造函数的一种方法。 也就是说打着构造函数的幌子挂羊头卖狗肉，你看创建的实例使用 instanceof 都无法指向构造函数！ 这样方法可以在特殊情况下使用。比如我们想创建一个具有额外方法的特殊数组，但是又不想直接修改 Array 构造函数，我们可以这样写： 12345678910111213141516171819202122function SpecialArray() { var values = new Array(); for (var i = 0, len = arguments.length; i &lt; len; i++) { values.push(arguments[i]); } values.toPipedString = function () { return this.join(&quot;|&quot;); }; return values;}var colors = new SpecialArray('red', 'blue', 'green');var colors2 = SpecialArray('red2', 'blue2', 'green2');console.log(colors);console.log(colors.toPipedString()); // red|blue|greenconsole.log(colors2);console.log(colors2.toPipedString()); // red2|blue2|green2 你会发现，其实所谓的寄生构造函数模式就是比工厂模式在创建对象的时候，多使用了一个 new，实际上两者的结果是一样的。 但是作者可能是希望能像使用普通 Array 一样使用 SpecialArray，虽然把 SpecialArray 当成函数也一样能用，但是这并不是作者的本意，也变得不优雅。 在可以使用其他模式的情况下，不要使用这种模式。 但是值得一提的是，上面例子中的循环： 123for (var i = 0, len = arguments.length; i &lt; len; i++) { values.push(arguments[i]);} 可以替换成： 1values.push.apply(values, arguments); 5.2 稳妥构造函数模式1234567891011121314151617function person(name){ var o = new Object(); o.sayName = function(){ console.log(name); }; return o;}var person1 = person('kevin');person1.sayName(); // kevinperson1.name = &quot;daisy&quot;;person1.sayName(); // kevinconsole.log(person1.name); // daisy 所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。 与寄生构造函数模式有两点不同： 新创建的实例方法不引用 this 不使用 new 操作符调用构造函数 稳妥对象最适合在一些安全的环境中。 稳妥构造函数模式也跟工厂模式一样，无法识别对象所属类型。","link":"/2021/04/02/JS/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/"},{"title":"","text":"JavaScript深入之参数按值传递定义在《JavaScript 高级程序设计》第三版 4.1.3，讲到传递参数： ECMAScript 中所有函数的参数都是按值传递的。 什么是按值传递呢？ 也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。 按值传递举个简单的例子： 1234567var value = 1;function foo(v) { v = 2; console.log(v); //2}foo(value);console.log(value) // 1 很好理解，当传递 value 到函数 foo 中，相当于拷贝了一份 value，假设拷贝的这份叫 _value，函数中修改的都是 _value 的值，而不会影响原来的 value 值。 引用传递？拷贝虽然很好理解，但是当值是一个复杂的数据结构的时候，拷贝就会产生性能上的问题。 所以还有另一种传递方式叫做按引用传递。 所谓按引用传递，就是传递对象的引用，函数内部对参数的任何改变都会影响该对象的值，因为两者引用的是同一个对象。 举个例子： 123456789var obj = { value: 1};function foo(o) { o.value = 2; console.log(o.value); //2}foo(obj);console.log(obj.value) // 2 哎，不对啊，连我们的红宝书都说了 ECMAScript 中所有函数的参数都是按值传递的，这怎么能按 “引用传递” 成功呢？ 而这究竟是不是引用传递呢？ 第三种传递方式不急，让我们再看个例子： 123456789var obj = { value: 1};function foo(o) { o = 2; console.log(o); //2}foo(obj);console.log(obj.value) // 1 如果 JavaScript 采用的是引用传递，外层的值也会被修改呐，这怎么又没被改呢？所以真的不是引用传递吗？ 这就要讲到其实还有第三种传递方式，叫按共享传递。 而共享传递是指，在传递对象的时候，传递对象的引用的副本。 注意： 按引用传递是传递对象的引用，而按共享传递是传递对象的引用的副本！ 所以修改 o.value，可以通过引用找到原值，但是直接修改 o，并不会修改原值。所以第二个和第三个例子其实都是按共享传递。 最后，你可以这样理解： 参数如果是基本类型是按值传递，如果是引用类型按共享传递。 但是因为拷贝副本也是一种值的拷贝，所以在高程中也直接认为是按值传递了。 所以，高程，谁叫你是红宝书嘞！","link":"/2021/04/02/JS/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%8F%82%E6%95%B0%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/"},{"title":"","text":"JavaScript深入之变量对象前言在上篇《JavaScript 深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码 (executable code) 时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象 (Variable object，VO) 作用域链 (Scope chain) this 今天重点讲讲创建变量对象的过程。 变量对象变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。 因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象。 全局上下文我们先了解一个概念，叫全局对象。在 W3School 中也有介绍： 全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。 在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。 例如，当 JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。 如果看的不是很懂的话，容我再来介绍下全局对象: 可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。 全局对象是由 Object 构造函数实例化的一个对象。 1console.log(this instanceof Object); 预定义了一堆，嗯，一大堆函数和属性。 123// 都能生效console.log(Math.random());console.log(this.Math.random()); 作为全局变量的宿主。 12var a = 1;console.log(this.a); 客户端 JavaScript 中，全局对象有 window 属性指向自身。 12345var a = 1;console.log(window.a);this.window.b = 2;console.log(this.b); 花了一个大篇幅介绍全局对象，其实就想说： 全局上下文中的变量对象就是全局对象呐！ 函数上下文在函数上下文中，我们用活动对象 (activation object, AO) 来表示变量对象。 活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。 活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。 执行过程执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做： 进入执行上下文 代码执行 进入执行上下文当进入执行上下文时，这时候还没有执行代码， 变量对象会包括： 函数的所有形参 (如果是函数上下文) 由名称和对应值组成的一个变量对象的属性被创建 没有实参，属性值设为 undefined 函数声明 由名称和对应值（函数对象 (function-object)）组成一个变量对象的属性被创建 如果变量对象已经存在相同名称的属性，则完全替换这个属性 变量声明 由名称和对应值（undefined）组成一个变量对象的属性被创建； 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性 举个例子： 12345678910function foo(a) { var b = 2; function c() {} var d = function() {}; b = 3;}foo(1); 在进入执行上下文后，这时候的 AO 是： 12345678910AO = { arguments: { 0: 1, length: 1 }, a: 1, b: undefined, c: reference to function c(){}, d: undefined} 代码执行在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值 还是上面的例子，当代码执行完后，这时候的 AO 是： 12345678910AO = { arguments: { 0: 1, length: 1 }, a: 1, b: 3, c: reference to function c(){}, d: reference to FunctionExpression &quot;d&quot;} 到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说： 全局上下文的变量对象初始化是全局对象 函数上下文的变量对象初始化只包括 Arguments 对象 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值 在代码执行阶段，会再次修改变量对象的属性值 思考题最后让我们看几个例子： 第一题 123456789101112function foo() { console.log(a); a = 1;}foo(); // ???function bar() { a = 1; console.log(a);}bar(); // ??? 第一段会报错：Uncaught ReferenceError: a is not defined。 第二段会打印：1。 这是因为函数中的 “a” 并没有通过 var 关键字声明，所有不会被存放在 AO 中。 第一段执行 console 的时候， AO 的值是： 12345AO = { arguments: { length: 0 }} 没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。 当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。 第二题 1234567console.log(foo);function foo(){ console.log(&quot;foo&quot;);}var foo = 1; 会打印函数，而不是 undefined 。 这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。","link":"/2021/04/02/JS/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"},{"title":"","text":"JavaScript深入之头疼的类型转换(下)前言举个例子： 在 JavaScript 中，这是完全可以运行的，不过你有没有好奇，为什么 1 和 ‘1’ 分属不同的数据类型，为什么就可以进行运算呢？ 这其实是因为 JavaScript 自动的将数据类型进行了转换，我们通常称为隐式类型转换。但是我们都知道，+运算符既可以用于数字加法，也能用于字符串拼接，那在这个例子中，是将数字 1 转成字符串 '1'，进行拼接运算？还是将字符串 '1' 转成数字 1，进行加法运算呢？ 先卖个关子，虽然估计你也知道答案。今天，我们就常见的隐式类型转化的场景进行介绍。 一元操作符 +当 + 运算符作为一元操作符的时候，查看 ES5 规范 1.4.6，会调用 ToNumber 处理该值，相当于 Number('1')，最终结果返回数字 1。 那么下面的这些结果呢？ 1234console.log(+[]);console.log(+['1']);console.log(+['1', '2', '3']);console.log(+{}); 既然是调用 ToNumber 方法，回想《JavaScript 深入之头疼的类型转换 (上)》中的内容，当输入的值是对象的时候，先调用 ToPrimitive(input, Number) 方法，执行的步骤是： 如果 obj 为基本类型，直接返回 否则，调用 valueOf 方法，如果返回一个原始值，则 JavaScript 将其返回。 否则，调用 toString 方法，如果返回一个原始值，则JavaScript 将其返回。 否则，JavaScript 抛出一个类型错误异常。 以 +[] 为例，[] 调用 valueOf 方法，返回一个空数组，因为不是原始值，调用 toString 方法，返回 &quot;&quot;。 得到返回值后，然后再调用 ToNumber 方法，&quot;&quot; 对应的返回值是 0，所以最终返回 0。 剩下的例子以此类推。结果是： 123console.log(+['1']); // 1console.log(+['1', '2', '3']); // NaNconsole.log(+{}); // NaN 二元操作符 +规范现在 + 运算符又变成了二元操作符，毕竟它也是加减乘除中的加号 1 + '1' 我们知道答案是 ‘11’，那 null + 1、[] + []、[] + {}、{} + {} 呢？ 如果要了解这些运算的结果，不可避免的我们要从规范下手。 规范地址：http://es5.github.io/#x11.6.1 不过这次就不直接大段大段的引用规范了，直接给大家讲简化后的内容。 到底当执行 + 运算的时候，会执行怎样的步骤呢？让我们根据规范11.6.1 来捋一捋： 当计算 value1 + value2 时： lprim = ToPrimitive(value1) rprim = ToPrimitive(value2) 如果 lprim 是字符串或者 rprim 是字符串，那么返回 ToString(lprim) 和 ToString(rprim) 的拼接结果 返回 ToNumber(lprim) 和 ToNumber(rprim) 的运算结果 规范的内容就这样结束了。没有什么新的内容，ToString、ToNumber、ToPrimitive都是在《JavaScript 深入之头疼的类型转换 (上)》中讲到过的内容，所以我们直接进分析阶段： 让我们来举几个例子： 1.Null 与数字按照规范的步骤进行分析： lprim = ToPrimitive(null) 因为 null 是基本类型，直接返回，所以 lprim = null rprim = ToPrimitive(1) 因为 1 是基本类型，直接返回，所以 rprim = null lprim 和 rprim 都不是字符串 返回 ToNumber(null) 和 ToNumber(1) 的运算结果 接下来： ToNumber(null) 的结果为 0，(回想上篇 Number(null))，ToNumber(1) 的结果为 1 所以，null + 1 相当于 0 + 1，最终的结果为数字 1。 这个还算简单，看些稍微复杂的： 2. 数组与数组依然按照规范： lprim = ToPrimitive([])，[]是数组，相当于 ToPrimitive([], Number)，先调用 valueOf 方法，返回对象本身，因为不是原始值，调用 toString 方法，返回空字符串 “” rprim 类似。 lprim 和 rprim 都是字符串，执行拼接操作 所以，[] + []相当于 &quot;&quot;+&quot;&quot;，最终的结果是空字符串&quot;&quot;。 看个更复杂的： 3. 数组与对象123// 两者结果一致console.log([] + {});console.log({} + []); 按照规范： lprim = ToPrimitive([])，lprim = “” rprim = ToPrimitive({})，相当于调用 ToPrimitive({}, Number)，先调用 valueOf 方法，返回对象本身，因为不是原始值，调用 toString 方法，返回 “[object Object]” lprim 和 rprim 都是字符串，执行拼接操作 所以，[] + {} 相当于 &quot;&quot;+&quot;[object Object]&quot;，最终的结果是 “[object Object]”。 下面的例子，可以按照示例类推出结果： 123console.log(1 + true);console.log({} + {});console.log(new Date(2017, 04, 21) + 1) // 这个知道是数字还是字符串类型就行 结果是： 123console.log(1 + true); // 2console.log({} + {}); // &quot;[object Object][object Object]&quot;console.log(new Date(2017, 04, 21) + 1) // &quot;Sun May 21 2017 00:00:00 GMT+0800 (CST)1&quot; 注意以上的运算都是在 console.log 中进行，如果你直接在 Chrome 或者 Firebug 开发工具中的命令行直接输入，你也许会惊讶的看到一些结果的不同，比如： 我们刚才才说过 {} + [] 的结果是 &quot;[object Object]&quot; 呐，这怎么变成了 0 了？ 不急，我们尝试着加一个括号： 结果又变成了正确的值，这是为什么呢？ 其实，在不加括号的时候，{} 被当成了一个独立的空代码块，所以 {} + [] 变成了 +[]，结果就变成了 0 同样的问题还出现在 {} + {} 上，而且火狐和谷歌的结果还不一样： 123&gt; {} + {}// 火狐： NaN// 谷歌： &quot;[object Object][object Object]&quot; 如果 {} 被当成一个独立的代码块，那么这句话相当于 +{}，相当于 Number({})，结果自然是 NaN，可是 Chrome 却在这里返回了正确的值。 那为什么这里就返回了正确的值呢？我也不知道，欢迎解答~ == 相等规范&quot;==&quot; 用于比较两个值是否相等，当要比较的两个值类型不一样的时候，就会发生类型的转换。 关于使用 “==” 进行比较的时候，具体步骤可以查看规范 11.9.5： 当执行 x == y 时： 如果 x 与 y 是同一类型： x 是 Undefined，返回 true x 是 Null，返回 true x 是数字： x 是 NaN，返回 false y 是 NaN，返回 false x 与 y 相等，返回 true x 是 + 0，y 是 - 0，返回 true x 是 - 0，y 是 + 0，返回 true 返回 false x 是字符串，完全相等返回 true, 否则返回 false x 是布尔值，x 和 y 都是 true 或者 false，返回 true，否则返回 false x 和 y 指向同一个对象，返回 true，否则返回 false x 是 null 并且 y 是 undefined，返回 true x 是 undefined 并且 y 是 null，返回 true x 是数字，y 是字符串，判断 x == ToNumber(y) x 是字符串，y 是数字，判断 ToNumber(x) == y x 是布尔值，判断 ToNumber(x) == y y 是布尔值，判断 x ==ToNumber(y) x 不是字符串或者数字，y 是对象，判断 x == ToPrimitive(y) x 是对象，y 不是字符串或者数字，判断 ToPrimitive(x) == y 返回 false 觉得看规范判断太复杂？我们来分几种情况来看： 1. null 和 undefined1console.log(null == undefined); 看规范第 2、3 步： x 是 null 并且 y 是 undefined，返回 true x 是 undefined 并且 y 是 null，返回 true 所以例子的结果自然为 true。 这时候，我们可以回想在《JavaScript 专题之类型判断 (上)》中见过的一段 demo，就是编写判断对象的类型 type 函数时，如果输入值是 undefined，就返回字符串 undefined，如果是 null，就返回字符串 null。 如果是你，你会怎么写呢？ 下面是 jQuery 的写法： 123456function type(obj) { if (obj == null) { return obj + ''; } ...} 2. 字符串与数字结果肯定是 true，问题在于是字符串转化成了数字和数字比较还是数字转换成了字符串和字符串比较呢？ 看规范第 4、5 步： 4.x 是数字，y 是字符串，判断 x == ToNumber(y) 5.x 是字符串，y 是数字，判断 ToNumber(x) == y 结果很明显，都是转换成数字后再进行比较 3. 布尔值和其他类型当要判断的一方出现 false 的时候，往往最容易出错，比如上面这个例子，凭直觉应该是 true，毕竟 Boolean('2') 的结果可是 true，但这道题的结果却是 false。 归根到底，还是要看规范，规范第 6、7 步： 6.x 是布尔值，判断 ToNumber(x) == y 7.y 是布尔值，判断 x ==ToNumber(y) 当一方出现布尔值的时候，就会对这一方的值进行 ToNumber 处理，也就是说 true 会被转化成 1， true == '2' 就相当于 1 == '2' 就相当于 1 == 2，结果自然是 false。 所以当一方是布尔值的时候，会对布尔值进行转换，因为这种特性，所以尽量少使用 xx == true 和 xx == false 的写法。 比如: 1234567// 不建议if (a == true) {}// 建议if (a) {}// 更好if (!!a) {} 4. 对象与非对象1console.log( 42 == ['42']) 看规范第 8、9 步： x 不是字符串或者数字，y 是对象，判断 x == ToPrimitive(y) x 是对象，y 不是字符串或者数字，判断 ToPrimitive(x) == y 以这个例子为例，会使用 ToPrimitive 处理 ['42']，调用valueOf，返回对象本身，再调用 toString，返回 '42'，所以 42 == ['42'] 相当于 42 == '42' 相当于42 == 42，结果为 true。 到此为止，我们已经看完了第 2、3、4、5、6、7、8、9 步，其他的一概返回 false。 其他再多举几个例子进行分析： 1console.log(false == undefined) false == undefined 相当于 0 == undefined 不符合上面的情形，执行最后一步 返回 false false == [] 相当于 0 == [] 相当于 0 == '' 相当于 0 == 0，结果返回 true 首先会执行 ![] 操作，转换成 false，相当于 [] == false 相当于 [] == 0 相当于 '' == 0 相当于 0 == 0，结果返回 true 最后再举一些会让人踩坑的例子： 123456789101112console.log(false == &quot;0&quot;)console.log(false == 0)console.log(false == &quot;&quot;)console.log(&quot;&quot; == 0)console.log(&quot;&quot; == [])console.log([] == 0)console.log(&quot;&quot; == [null])console.log(0 == &quot;\\n&quot;)console.log([] == 0) 以上均返回 true 其他除了这两种情形之外，其实还有很多情形会发生隐式类型转换，比如if、? :、&amp;&amp;等情况，但相对来说，比较简单，就不再讲解。","link":"/2021/04/02/JS/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%A4%B4%E7%96%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2(%E4%B8%8B)/"},{"title":"","text":"JavaScript深入之执行上下文在《JavaScript 深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码 (executable code) 时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象 (Variable object，VO) 作用域链 (Scope chain) this 然后分别在《JavaScript 深入之变量对象》、《JavaScript 深入之作用域链》、《JavaScript 深入之从 ECMAScript 规范解读 this》中讲解了这三个属性。 阅读本文前，如果对以上的概念不是很清楚，希望先阅读这些文章。 因为，这一篇，我们会结合着所有内容，讲讲执行上下文的具体处理过程。 思考题在《JavaScript 深入之词法作用域和动态作用域》中，提出这样一道思考题： 123456789var scope = &quot;global scope&quot;;function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f();}checkscope(); 123456789var scope = &quot;global scope&quot;;function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f;}checkscope()(); 两段代码都会打印’local scope’。虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 紧接着就在下一篇《JavaScript 深入之执行上下文栈》中，讲到了两者的区别在于执行上下文栈的变化不一样，然而，如果是这样笼统的回答，依然显得不够详细，本篇就会详细的解析执行上下文栈和执行上下文的具体变化过程。 具体执行分析我们分析第一段代码： 123456789var scope = &quot;global scope&quot;;function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f();}checkscope(); 执行过程如下： 执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈 123ECStack = [ globalContext]; 全局上下文初始化 12345globalContext = { VO: [global], Scope: [globalContext.VO], this: globalContext.VO} 初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]] 123checkscope.[[scope]] = [ globalContext.VO]; 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1234ECStack = [ checkscopeContext, globalContext]; 4.checkscope 函数执行上下文初始化： 复制函数 [[scope]] 属性创建作用域链， 用 arguments 创建活动对象， 初始化活动对象，即加入形参、函数声明、变量声明， 将活动对象压入 checkscope 作用域链顶端。 同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]] 1234567891011checkscopeContext = { AO: { arguments: { length: 0 }, scope: undefined, f: reference to function f(){} }, Scope: [AO, globalContext.VO], this: undefined} 执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈 12345ECStack = [ fContext, checkscopeContext, globalContext]; 6.f 函数执行上下文初始化, 以下跟第 4 步相同： 复制函数 [[scope]] 属性创建作用域链 用 arguments 创建活动对象 初始化活动对象，即加入形参、函数声明、变量声明 将活动对象压入 f 作用域链顶端 123456789fContext = { AO: { arguments: { length: 0 } }, Scope: [AO, checkscopeContext.AO, globalContext.VO], this: undefined} 7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值 8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 1234ECStack = [ checkscopeContext, globalContext]; 9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 123ECStack = [ globalContext]; 第二段代码就留给大家去尝试模拟它的执行过程。 123456789var scope = &quot;global scope&quot;;function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f;}checkscope()(); 不过，在下一篇《JavaScript 深入之闭包》中也会提及这段代码的执行过程。","link":"/2021/04/02/JS/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"},{"title":"","text":"JavaScript深入之执行上下文栈顺序执行？如果要问到 JavaScript 代码执行顺序的话，想必写过 JavaScript 的开发者都会有个直观的印象，那就是顺序执行，毕竟： 123456789101112131415var foo = function () { console.log('foo1');}foo(); // foo1var foo = function () { console.log('foo2');}foo(); // foo2 然而去看这段代码： 123456789101112131415function foo() { console.log('foo1');}foo(); // foo2function foo() { console.log('foo2');}foo(); // foo2 打印的结果却是两个 foo2。 刷过面试题的都知道这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个 “准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。 但是本文真正想让大家思考的是：这个 “一段一段” 中的 “段” 究竟是怎么划分的呢？ 到底 JavaScript 引擎遇到一段怎样的代码时才会做 “准备工作” 呢？ 可执行代码这就要说到 JavaScript 的可执行代码 (executable code) 的类型有哪些了？ 其实很简单，就三种，全局代码、函数代码、eval 代码。 举个例子，当执行到一个函数的时候，就会进行准备工作，这里的 “准备工作”，让我们用个更专业一点的说法，就叫做 “执行上下文 (execution context)”。 执行上下文栈接下来问题来了，我们写的函数多了去了，如何管理创建的那么多执行上下文呢？ 所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文 为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组： 试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext： 123ECStack = [ globalContext]; 现在 JavaScript 遇到下面的这段代码了： 12345678910111213function fun3() { console.log('fun3')}function fun2() { fun3();}function fun1() { fun2();}fun1(); 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码： 123456789101112131415161718192021// 伪代码// fun1()ECStack.push(&lt;fun1&gt; functionContext);// fun1中竟然调用了fun2，还要创建fun2的执行上下文ECStack.push(&lt;fun2&gt; functionContext);// 擦，fun2还调用了fun3！ECStack.push(&lt;fun3&gt; functionContext);// fun3执行完毕ECStack.pop();// fun2执行完毕ECStack.pop();// fun1执行完毕ECStack.pop();// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext 解答思考题好啦，现在我们已经了解了执行上下文栈是如何处理执行上下文的，所以让我们看看上篇文章《JavaScript 深入之词法作用域和动态作用域》最后的问题： 123456789var scope = &quot;global scope&quot;;function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f();}checkscope(); 123456789var scope = &quot;global scope&quot;;function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f;}checkscope()(); 两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 答案就是执行上下文栈的变化不一样。 让我们模拟第一段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop(); 让我们模拟第二段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.pop();ECStack.push(&lt;f&gt; functionContext);ECStack.pop(); 是不是有些不同呢？ 当然了，这样概括的回答执行上下文栈的变化不同，是不是依然有一种意犹未尽的感觉呢，为了更详细讲解两个函数执行上的区别，我们需要探究一下执行上下文到底包含了哪些内容，所以欢迎阅读下一篇《JavaScript 深入之变量对象》。","link":"/2021/04/02/JS/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"},{"title":"","text":"JavaScript深入之类数组对象与arguments类数组对象所谓的类数组对象: 拥有一个 length 属性和若干索引属性的对象 举个例子： 12345678var array = ['name', 'age', 'sex'];var arrayLike = { 0: 'name', 1: 'age', 2: 'sex', length: 3} 即便如此，为什么叫做类数组对象呢？ 那让我们从读写、获取长度、遍历三个方面看看这两个对象。 读写12345console.log(array[0]); // nameconsole.log(arrayLike[0]); // namearray[0] = 'new name';arrayLike[0] = 'new name'; 长度12console.log(array.length); // 3console.log(arrayLike.length); // 3 遍历123456for(var i = 0, len = array.length; i &lt; len; i++) { ……}for(var i = 0, len = arrayLike.length; i &lt; len; i++) { ……} 是不是很像？ 那类数组对象可以使用数组的方法吗？比如： 然而上述代码会报错: arrayLike.push is not a function 所以终归还是类数组呐…… 调用数组方法如果类数组就是任性的想用数组的方法怎么办呢？ 既然无法直接调用，我们可以用 Function.call 间接调用： 1234567891011var arrayLike = {0: 'name', 1: 'age', 2: 'sex', length: 3 }Array.prototype.join.call(arrayLike, '&amp;'); // name&amp;age&amp;sexArray.prototype.slice.call(arrayLike, 0); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] // slice可以做到类数组转数组Array.prototype.map.call(arrayLike, function(item){ return item.toUpperCase();}); // [&quot;NAME&quot;, &quot;AGE&quot;, &quot;SEX&quot;] 类数组转数组在上面的例子中已经提到了一种类数组转数组的方法，再补充三个： 123456789var arrayLike = {0: 'name', 1: 'age', 2: 'sex', length: 3 }// 1. sliceArray.prototype.slice.call(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] // 2. spliceArray.prototype.splice.call(arrayLike, 0); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] // 3. ES6 Array.fromArray.from(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] // 4. applyArray.prototype.concat.apply([], arrayLike) 那么为什么会讲到类数组对象呢？以及类数组有什么应用吗？ 要说到类数组对象，Arguments 对象就是一个类数组对象。在客户端 JavaScript 中，一些 DOM 方法 (document.getElementsByTagName() 等)也返回类数组对象。 Arguments 对象接下来重点讲讲 Arguments 对象。 Arguments 对象只定义在函数体中，包括了函数的参数和其他属性。在函数体中，arguments 指代该函数的 Arguments 对象。 举个例子： 12345function foo(name, age, sex) { console.log(arguments);}foo('name', 'age', 'sex') 打印结果如下： 我们可以看到除了类数组的索引属性和 length 属性之外，还有一个 callee 属性，接下来我们一个一个介绍。 length 属性Arguments 对象的 length 属性，表示实参的长度，举个例子： 12345678910function foo(b, c, d){ console.log(&quot;实参的长度为：&quot; + arguments.length)}console.log(&quot;形参的长度为：&quot; + foo.length)foo(1)// 形参的长度为：3// 实参的长度为：1 callee 属性Arguments 对象的 callee 属性，通过它可以调用函数自身。 讲个闭包经典面试题使用 callee 的解决方法： 123456789101112131415var data = [];for (var i = 0; i &lt; 3; i++) { (data[i] = function () { console.log(arguments.callee.i) }).i = i;}data[0]();data[1]();data[2]();// 0// 1// 2 接下来讲讲 arguments 对象的几个注意要点： arguments 和对应参数的绑定12345678910111213141516171819202122232425262728function foo(name, age, sex, hobbit) { console.log(name, arguments[0]); // name name // 改变形参 name = 'new name'; console.log(name, arguments[0]); // new name new name // 改变arguments arguments[1] = 'new age'; console.log(age, arguments[1]); // new age new age // 测试未传入的是否会绑定 console.log(sex); // undefined sex = 'new sex'; console.log(sex, arguments[2]); // new sex undefined arguments[3] = 'new hobbit'; console.log(hobbit, arguments[3]); // undefined new hobbit}foo('name', 'age') 传入的参数，实参和 arguments 的值会共享，当没有传入时，实参与 arguments 值不会共享 除此之外，以上是在非严格模式下，如果是在严格模式下，实参和 arguments 是不会共享的。 传递参数将参数从一个函数传递到另一个函数 123456789// 使用 apply 将 foo 的参数传递给 barfunction foo() { bar.apply(this, arguments);}function bar(a, b, c) { console.log(a, b, c);}foo(1, 2, 3) 强大的 ES6使用 ES6 的 … 运算符，我们可以轻松转成数组。 12345function func(...arguments) { console.log(arguments); // [1, 2, 3]}func(1, 2, 3); 应用arguments 的应用其实很多，在下个系列，也就是 JavaScript 专题系列中，我们会在 jQuery 的 extend 实现、函数柯里化、递归等场景看见 arguments 的身影。这篇文章就不具体展开了。 如果要总结这些场景的话，暂时能想到的包括： 参数不定长 函数柯里化 递归调用 函数重载… 欢迎留言回复。","link":"/2021/04/02/JS/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%8Earguments/"},{"title":"","text":"JavaScript深入之继承的多种方式和优缺点写在前面本文讲解 JavaScript 各种继承方式和优缺点。 但是注意： 这篇文章更像是笔记，哎，再让我感叹一句：《JavaScript 高级程序设计》写得真是太好了！ 1. 原型链继承1234567891011121314151617function Parent () { this.name = 'kevin';}Parent.prototype.getName = function () { console.log(this.name);}function Child () {}Child.prototype = new Parent();var child1 = new Child();console.log(child1.getName()) // kevin 问题： 引用类型的属性被所有实例共享，举个例子： 12345678910111213141516171819function Parent () { this.names = ['kevin', 'daisy'];}function Child () {}Child.prototype = new Parent();var child1 = new Child();child1.names.push('yayu');console.log(child1.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]var child2 = new Child();console.log(child2.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;] 在创建 Child 的实例时，不能向 Parent 传参 2. 借用构造函数 (经典继承)1234567891011121314151617function Parent () { this.names = ['kevin', 'daisy'];}function Child () { Parent.call(this);}var child1 = new Child();child1.names.push('yayu');console.log(child1.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]var child2 = new Child();console.log(child2.names); // [&quot;kevin&quot;, &quot;daisy&quot;] 优点： 避免了引用类型的属性被所有实例共享 可以在 Child 中向 Parent 传参 举个例子： 123456789101112131415function Parent (name) { this.name = name;}function Child (name) { Parent.call(this, name);}var child1 = new Child('kevin');console.log(child1.name); // kevinvar child2 = new Child('daisy');console.log(child2.name); // daisy 缺点： 方法都在构造函数中定义，每次创建实例都会创建一遍方法。 3. 组合继承原型链继承和经典继承双剑合璧。 123456789101112131415161718192021222324252627282930313233function Parent (name) { this.name = name; this.colors = ['red', 'blue', 'green'];}Parent.prototype.getName = function () { console.log(this.name)}function Child (name, age) { Parent.call(this, name); this.age = age;}Child.prototype = new Parent();Child.prototype.constructor = Child;var child1 = new Child('kevin', '18');child1.colors.push('black');console.log(child1.name); // kevinconsole.log(child1.age); // 18console.log(child1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]var child2 = new Child('daisy', '20');console.log(child2.name); // daisyconsole.log(child2.age); // 20console.log(child2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;] 优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。 4. 原型式继承12345function createObj(o) { function F(){} F.prototype = o; return new F();} 就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。 缺点： 包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。 12345678910111213var person = { name: 'kevin', friends: ['daisy', 'kelly']}var person1 = createObj(person);var person2 = createObj(person);person1.name = 'person1';console.log(person2.name); // kevinperson1.firends.push('taylor');console.log(person2.friends); // [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;] 注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = 'person1'，给person1添加了 name 值，并非修改了原型上的 name 值。 5. 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。 1234567function createObj (o) { var clone = Object.create(o); clone.sayName = function () { console.log('hi'); } return clone;} 缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。 6. 寄生组合式继承为了方便大家阅读，在这里重复一下组合继承的代码： 12345678910111213141516171819function Parent (name) { this.name = name; this.colors = ['red', 'blue', 'green'];}Parent.prototype.getName = function () { console.log(this.name)}function Child (name, age) { Parent.call(this, name); this.age = age;}Child.prototype = new Parent();var child1 = new Child('kevin', '18');console.log(child1) 组合继承最大的缺点是会调用两次父构造函数。 一次是设置子类型实例的原型的时候： 1Child.prototype = new Parent(); 一次在创建子类型实例的时候： 1var child1 = new Child('kevin', '18'); 回想下 new 的模拟实现，其实在这句中，我们会执行： 在这里，我们又会调用了一次 Parent 构造函数。 所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为colors，属性值为['red', 'blue', 'green']。 那么我们该如何精益求精，避免这一次重复调用呢？ 如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？ 看看如何实现： 12345678910111213141516171819202122232425function Parent (name) { this.name = name; this.colors = ['red', 'blue', 'green'];}Parent.prototype.getName = function () { console.log(this.name)}function Child (name, age) { Parent.call(this, name); this.age = age;}// 关键的三步var F = function () {};F.prototype = Parent.prototype;Child.prototype = new F();var child1 = new Child('kevin', '18');console.log(child1); 最后我们封装一下这个继承方法： 1234567891011121314function object(o) { function F() {} F.prototype = o; return new F();}function prototype(child, parent) { var prototype = object(parent.prototype); prototype.constructor = child; child.prototype = prototype;}// 当我们使用的时候：prototype(Child, Parent); 引用《JavaScript 高级程序设计》中对寄生组合式继承的夸赞就是： 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。","link":"/2021/04/02/JS/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9/"},{"title":"","text":"JavaScript深入之词法作用域和动态作用域作用域作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域 (lexical scoping)，也就是静态作用域。 静态作用域与动态作用域因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。 让我们认真看个例子就能明白之间的区别： 1234567891011121314var value = 1;function foo() { console.log(value);}function bar() { var value = 2; foo();}bar();// 结果是 ??? 假设 JavaScript 采用静态作用域，让我们分析下执行过程： 执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。 假设 JavaScript 采用动态作用域，让我们分析下执行过程： 执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。 前面我们已经说了，JavaScript 采用的是静态作用域，所以这个例子的结果是 1。 动态作用域也许你会好奇什么语言是动态作用域？ bash 就是动态作用域，不信的话，把下面的脚本存成例如 scope.bash，然后进入相应的目录，用命令行执行 bash ./scope.bash，看看打印的值是多少。 123456789value=1function foo () { echo $value;}function bar () { local value=2; foo;}bar 这个文件也可以在 Github 博客仓库中找到。 思考题最后，让我们看一个《JavaScript 权威指南》中的例子： 123456789var scope = &quot;global scope&quot;;function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f();}checkscope(); 123456789var scope = &quot;global scope&quot;;function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f;}checkscope()(); 猜猜两段代码各自的执行结果是多少？ 这里直接告诉大家结果，两段代码都会打印：local scope。 原因也很简单，因为 JavaScript 采用的是词法作用域，函数的作用域基于函数创建的位置。 而引用《JavaScript 权威指南》的回答就是： JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。 但是在这里真正想让大家思考的是： 虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 如果要回答这个问题，就要牵涉到很多的内容，词法作用域只是其中的一小部分，让我们期待下一篇文章————《JavaScript 深入之执行上下文栈》。","link":"/2021/04/02/JS/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"title":"","text":"JavaScript深入之闭包定义MDN 对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 那什么是自由变量呢？ 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 由此，我们可以看出闭包共有两部分组成： 闭包 = 函数 + 函数能够访问的自由变量 举个例子： 1234567var a = 1;function foo() { console.log(a);}foo(); foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。 那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛…… 还真是这样的！ 所以在《JavaScript 权威指南》中就讲到：从技术的角度讲，所有的 JavaScript 函数都是闭包。 咦，这怎么跟我们平时看到的讲到的闭包不一样呢！？ 别着急，这是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义： ECMAScript 中，闭包指的是： 从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。 从实践角度：以下函数才算是闭包： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 接下来就来讲讲实践上的闭包。 分析让我们先写个例子，例子依然是来自《JavaScript 权威指南》，稍微做点改动： 1234567891011var scope = &quot;global scope&quot;;function checkscope(){ var scope = &quot;local scope&quot;; function f(){ return scope; } return f;}var foo = checkscope();foo(); 首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。 另一个与这段代码相似的例子，在《JavaScript 深入之执行上下文》中有着非常详细的分析。如果看不懂以下的执行过程，建议先阅读这篇文章。 这里直接给出简要的执行过程： 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈 checkscope 执行上下文初始化，创建变量对象、作用域链、this 等 checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈 f 执行上下文初始化，创建变量对象、作用域链、this 等 f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 了解到这个过程，我们应该思考一个问题，那就是： 当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊 (即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？ 以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。(这段我问的 PHP 同事……) 然而 JavaScript 却是可以的！ 当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链： 123fContext = { Scope: [AO, checkscopeContext.AO, globalContext.VO],} 对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。 所以，让我们再看一遍实践角度上闭包的定义： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 在这里再补充一个《JavaScript 权威指南》英文原版对闭包的定义: This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature. 闭包在计算机科学中也只是一个普通的概念，大家不要去想得太复杂。 必刷题接下来，看这道刷题必刷，面试必考的闭包题： 1234567891011var data = [];for (var i = 0; i &lt; 3; i++) { data[i] = function () { console.log(i); };}data[0]();data[1]();data[2](); 答案是都是 3，让我们分析一下原因： 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext = { VO: { data: [...], i: 3 }} 当执行 data[0] 函数的时候，data[0] 函数的作用域链为： 123data[0]Context = { Scope: [AO, globalContext.VO]} data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。 data[1] 和 data[2] 是一样的道理。 所以让我们改成闭包看看： 12345678910111213var data = [];for (var i = 0; i &lt; 3; i++) { data[i] = (function (i) { return function(){ console.log(i); } })(i);}data[0]();data[1]();data[2](); 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext = { VO: { data: [...], i: 3 }} 跟没改之前一模一样。 当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变： 123data[0]Context = { Scope: [AO, 匿名函数Context.AO globalContext.VO]} 匿名函数执行上下文的 AO 为： 123456789匿名函数Context = { AO: { arguments: { 0: 0, length: 1 }, i: 0 }} data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值 (值为 3)，所以打印的结果就是 0。 data[1] 和 data[2] 是一样的道理。","link":"/2021/04/02/JS/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E9%97%AD%E5%8C%85/"},{"title":"Git分支合并详解","text":"“合并前文件还在的，合并后就不见了”、“我遇到 Git 合并的 bug 了” 是两句经常听到的话，但真的是 Git 的 bug 么？或许只是你的预期不对。本文通过讲解三向合并和 Git 的合并策略，step by step 介绍 Git 是怎么做一个合并的，让大家对 Git 的合并结果有一个准确的预期，并且避免发生合并事故。 ** 故事时间在开始正文之前，先来听一下这个故事。如下图，小明从节点 A 拉了一条 dev 分支出来，在节点 B 中新增了一个文件 http.js，并且合并到 master 分支，合并节点为 E。这个时候发现会引起线上 bug，赶紧撤回这个合并，新增一个 revert 节点 E’。过了几天小明继续在 dev 分支上面开发新增了一个文件 main.js，并在这个文件中 import 了 http.js 里面的逻辑，在 dev 分支上面一切运行正常。可当他将此时的 dev 分支合并到 master 时候却发现，http.js 文件不见了，导致 main.js 里面的逻辑运行报错了。但这次合并并没有任何冲突。他又得重新做了一下 revert，并且迷茫的怀疑是 Git 的 bug。两句经常听到的话：—— ”合并前文件还在的，合并后就不见了“—— ”我遇到 Git 的 bug 了“相信很多同学或多或少在不熟悉 Git 合并策略的时候都会发生过类似上面的事情，明明在合并前文件还在的，为什么合并后文件就不在了么？一度还怀疑是 Git 的 bug。这篇文章的目的就是想跟大家讲清楚 Git 是怎么去合并分支的，以及一些底层的基础概念，从而避免发生如故事中的问题，并对 Git 的合并结果有一个准确的预期。 ** 如何合并两个文件在看怎么合并两个分支之前，我们先来看一下怎么合并两个文件，因为两个文件的合并是两个分支合并的基础。大家应该都听说过“三向合并”这个词，不知道大家有没有思考过为什么两个文件的合并需要三向合并，只有二向是否可以自动完成合并。如下图很明显答案是不能，如上图的例子，Git 没法确定这一行代码是我修改的，还是对方修改的，或者之前就没有这行代码，是我们俩同时新增的。此时 Git 没办法帮我们做自动合并。所以我们需要三向合并，所谓三向合并，就是找到两个文件的一个合并 base，如下图，这样子 Git 就可以很清楚的知道说，对方修改了这一行代码，而我们没有修改，自动帮我们合并这两个文件为 Print(“hello”)。接下来我们了解一下什么是冲突？冲突简单的来说就是三向合并中的三方都互不相同，即参考合并 base，我们的分支和别人的分支都对同个地方做了修改。 ** Git 的合并策略了解完怎么合并两个文件之后，我们来看一个使用 git merge 来做分支合并。如上图，将 master 分支合并到 feature 分支上，会新增一个 commit 节点来记录这次合并。Git 会有很多合并策略，其中常见的是 Fast-forward、Recursive 、Ours、Theirs、Octopus。下面分别介绍不同合并策略的原理以及应用场景。默认 Git 会帮你自动挑选合适的合并策略，如果你需要强制指定，使用git merge -s &lt;策略名字&gt;了解 Git 合并策略的原理可以让你对 Git 的合并结果有一个准确的预期。#### Fast-forwardFast-forward 是最简单的一种合并策略，如上图中将 some feature 分支合并进 master 分支，Git 只需要将 master 分支的指向移动到最后一个 commit 节点上。Fast-forward 是 Git 在合并两个没有分叉的分支时的默认行为，如果不想要这种表现，想明确记录下每次的合并，可以使用git merge –no-ff。#### RecursiveRecursive 是 Git 分支合并策略中最重要也是最常用的策略，是 Git 在合并两个有分叉的分支时的默认行为。其算法可以简单描述为：递归寻找路径最短的唯一共同祖先节点，然后以其为 base 节点进行递归三向合并。说起来有点绕，下面通过例子来解释。如下图这种简单的情况，圆圈里面的英文字母为当前 commit 的文件内容，当我们要合并中间两个节点的时候，找到他们的共同祖先节点（左边第一个），接着进行三向合并得到结果为 B。（因为合并的 base 是“A”，下图靠下的分支没有修改内容仍为“A”，下图靠上的分支修改成了“B”，所以合并结果为“B”）。但现实情况总是复杂得多，会出现历史记录链互相交叉等情况，如下图：当 Git 在寻找路径最短的共同祖先节点的时候，可以找到两个节点的，如果 Git 选用下图这一个节点，那么 Git 将无法自动的合并。因为根据三向合并，这里是是有冲突的，需要手动解决。（base 为“A“，合并的两个分支内容为”C“和”B“）而如果 Git 选用的是下图这个节点作为合并的 base 时，根据三向合并，Git 就可以直接自动合并得出结果“C”。（base 为“B“，合并的两个分支内容为”C“和”B“）作为人类，在这个例子里面我们很自然的就可以看出来合并的结果应该是“C”（如下图，节点 4、5 都已经是“B”了，节点 6 修改成“C”，所以合并的预期为“C”）那怎么保证 Git 能够找到正确的合并 base 节点，尽可能的减少冲突呢？答案就是，Git 在寻找路径最短的共同祖先节点时，如果满足条件的祖先节点不唯一，那么 Git 会继续递归往下寻找直至唯一。还是以刚刚这个例子图解。如下图所示，我们想要合并节点 5 和节点 6，Git 找到路径最短的祖先节点 2 和 3。因为共同祖先节点不唯一，所以 Git 递归以节点 2 和节点 3 为我们要合并的节点，寻找他们的路径最短的共同祖先，找到唯一的节点 1。接着 Git 以节点 1 为 base，对节点 2 和节点 3 做三向合并，得到一个临时节点，根据三向合并的结果，这个节点的内容为“B”。再以这个临时节点为 base，对节点 5 和节点 6 做三向合并，得到合并节点 7，根据三向合并的结果，节点 7 的内容为“C”至此 Git 完成递归合并，自动合并节点 5 和节点 6，结果为“C”，没有冲突。Recursive 策略已经被大量的场景证明它是一个尽量减少冲突的合并策略，我们可以看到有趣的一点是，对于两个合并分支的中间节点（如上图节点 4，5），只参与了 base 的计算，而最终真正被三向合并拿来做合并的节点，只包括末端以及 base 节点。需要注意 Git 只是使用这些策略尽量的去帮你减少冲突，如果冲突不可避免，那 Git 就会提示冲突，需要手工解决。（也就是真正意义上的冲突）。#### Ours &amp; TheirsOurs 和 Theirs 这两种合并策略也是比较简单的，简单来说就是保留双方的历史记录，但完全忽略掉这一方的文件变更。如下图在 master 分支里面执行git merge -s ours dev，会产生蓝色的这一个合并节点，其内容跟其上一个节点（master 分支方向上的）完全一样，即 master 分支合并前后项目文件没有任何变动。而如果使用 theirs 则完全相反，完全抛弃掉当前分支的文件内容，直接采用对方分支的文件内容。这两种策略的一个使用场景是比如现在要实现同一功能，你同时尝试了两个方案，分别在分支是 dev1 和 dev2 上，最后经过测试你选用了 dev2 这个方案。但你不想丢弃 dev1 的这样一个尝试，希望把它合入主干方便后期查看，这个时候你就可以在 dev2 分支中执行git merge -s ours dev1。 Octopus这种合并策略比较神奇，一般来说我们的合并节点都只有两个 parent（即合并两条分支），而这种合并策略可以做两个以上分支的合并，这也是 git merge 两个以上分支时的默认行为。比如在 dev1 分支上执行git merge dev2 dev3。他的一个使用场景是在测试环境或预发布环境，你需要将多个开发分支修改的内容合并在一起，如果不用这个策略，你每次只能合并一个分支，这样就会导致大量的合并节点产生。而使用 Octopus 这种合并策略就可以用一个合并节点将他们全部合并进来。 ** Git rebasegit rebase 也是一种经常被用来做合并的方法，其与 git merge 的最大区别是，他会更改变更历史对应的 commit 节点。如下图，当在 feature 分支中执行 rebase master 时，Git 会以 master 分支对应的 commit 节点为起点，新增两个全新的 commit 代替 feature 分支中的 commit 节点。其原因是新的 commit 指向的 parent 变了，所以对应的 SHA1 值也会改变，所以没办法复用原 feature 分支中的 commit。（这句话的理解需要这篇文章的基础知识）对于合并时候要使用 git merge 还是 git rebase 的争论，我个人的看法是没有银弹，根据团队和项目习惯选择就可以。git rebase 可以给我们带来清晰的历史记录，git merge 可以保留真实的提交时间等信息，并且不容易出问题，处理冲突也比较方便。唯一有一点需要注意的是，不要对已经处于远端的多人共用分支做 rebase 操作。我个人的一个习惯是：对于本地的分支或者确定只有一个人使用的远端分支用 rebase，其余情况用 merge。rebase 还有一个非常好用的东西叫 interactive 模式，使用方法是git rebase -i。可以实现压缩几个 commit，修改 commit 信息，抛弃某个 commit 等功能。比如说我要压缩下图 260a12a5、956e1d18，将他们与 9dae0027 合并为一个 commit，我只需将 260a12a5、956e1d18 前面的 pick 改成“s”，然后保存就可以了。限于篇幅，git rebase -i 还有很多实用的功能暂不展开，感兴趣的同学可以自己研究一下。 ** 总结现在我们再来看一下文章开头的例子，我们就可以理解为什么最后一次 merge 会导致 http.js 文件不见了。根据 Git 的合并策略，在合并两个有分叉的分支（上图中的 D、E‘）时，Git 默认会选择 Recursive 策略。找到 D 和 E’的最短路径共同祖先节点 B，以 B 为 base，对 D，E‘做三向合并。B 中有 http.js，D 中有 http.js 和 main.js，E’中什么都没有。根据三向合并，B、D 中都有 http.js 且没有变更，E‘删除了 http.js，所以合并结果就是没有 http.js，没有冲突，所以 http.js 文件不见了。这个例子理解原理之后解决方法有很多，这里简单带过两个方法：1. revert 节点 E’之后，此时的 dev 分支要抛弃删除掉，重新从 E’节点拉出分支继续工作，而不是在原 dev 分支上继续开发节点 D；2. 在节点 D 合并回 E’节点时，先 revert 一下 E‘节点生成 E’‘（即 revert 的 revert），再将节点 D 合并进来。Git 有很多种分支合并策略，本文介绍了 Fast-forward、Recursive、Ours/Theirs、Octopus 合并策略以及三向合并。掌握这些合并策略以及他们的使用场景可以让你避免发生一些合并问题，并对合并结果有一个准确的预期。希望这篇文章对大家有用，感兴趣的同学可以逛一逛我的博客www.lzane.com 或看看我的其他文章。参考 三向合并 http://blog.plasticscm.com/2016/02/three-way-merging-look-under-hood.html Recursive 合并【视频】https://www.youtube.com/watch?v=Lg1igaCtAck 书籍 Scott Chacon, Ben Straub - Pro Git-Apress (2014) 书籍 Jon Loeliger, Matthew McCullough - Version Control with Git, 2nd Edition - O’Reilly Media (2012) 原文 https://www.jiqizhixin.com/articles/2020-05-28-8","link":"/2021/04/02/Git/Git%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E8%AF%A6%E8%A7%A3/"},{"title":"web性能优化的15条实用技巧","text":"javascript 在浏览器中运行的性能，可以认为是开发者所面临的最严重的可用性问题。这个问题因为 javascript 的阻塞性而变得复杂，事实上，多数浏览器使用单一进程来处理用户界面和 js 脚本执行，所以同一时刻只能做一件事。js 执行过程耗时越久，浏览器等待响应的时间越长。 加载和执行 一. 提高加载性能 1.IE8,FF,3.5,Safari 4 和 Chrome 都允许并行下载 js 文件，当 script 下载资源时不会阻塞其他 script 的下载。但是 js 下载仍然会阻塞其他资源的下载，如图片。尽管脚本下载不会互相影响，但页面仍然必须等待所有 js 代码下载并执行完才能继续。因此仍然存在脚本阻塞问题. 推荐将所有 js 文件放在 body 标签底部以减少对整个页面的影响。 2. 减少页面外链脚本文件的数量将会提高页面性能： http 请求会带来额外的开销，因此下载单个 300k 的文件将比下载 10 个 30k 的文件效率更高。 3. 动态脚本加载技术： 无论何时启动下载，文件的下载和执行都不会阻塞页面其他进程。 12345678910111213141516171819202122232425262728function laodScript(url, callback) { var script = document.createElement(&quot;script&quot;); script.type = &quot;text/javascript&quot;; if (script.readyState) { script.onreadystatechange = function () { if (script.readyState == &quot;loaded&quot; || script.readyState == &quot;complete&quot;) { script.onreadystatechange = null; callback(); } }; } else { script.onload = function () { callback(); }; } script.src = url; document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);}// 使用loadScript(&quot;./a.js&quot;, function () { loadScript(&quot;./b.js&quot;, function () { loadScript(&quot;./c.js&quot;, function () { console.log(&quot;加载完成&quot;); }); });}); 无阻塞加载类库——LABjs, 使用方法如下： 1234567891011121314&lt;script src=&quot;lab.js&quot;&gt;&lt;/script&gt;// 链式调用时文件逐个下载，.wait()用来指定文件下载并执行完毕后所调用的函数$LAB.script('./a.js') .script('./b.js') .wait(function(){ App.init();})// 为了保证执行顺序，可以这么做,此时a必定在b前执行$LAB.script('./a.js').wait() .script('./b.js') .wait(function(){ App.init();}) 二. 数据存取与 JS 性能 1. 在 js 中，数据存储的位置会对代码整体性能产生重大影响。数据存储共有 4 种方式：字面量，变量，数组项，对象成员。他们有着各自的性能特点。 2. 访问字面量和局部变量的速度最快，相反，访问数组和对象相对较慢 3. 由于局部变量存在于作用域链的起始位置，因此访问局部变量的比访问跨域作用变量更快 4. 嵌套的对象成员会明显影响性能，应尽量避免 5. 属性和方法在原型链位置越深，访问他的速度越慢 6. 通常我们可以把需要多次使用的对象成员，数组元素，跨域变量保存在局部变量中来改善 js 性能 三. DOM 编程1. 访问 DOM 会影响浏览器性能，修改 DOM 则更耗费性能，因为他会导致浏览器重新计算页面的几何变化。**&lt; 通常的做法是减少访问 DOM 的次数，把运算尽量留在 JS 这一端。** 注：如过在一个对性能要求比较高的操作中更新一段 HTML，推荐使用 innerHTML，因为它在绝大多数浏览器中运行的都很快。但对于大多数日常操作而言，并没有太大区别，所以你更应该根据可读性，稳定性，团队习惯，代码风格来综合决定使用 innerHTML 还是 createElement() HTML 集合优化 HTML 集合包含了 DOM 节点引用的类数组对象，一直与文档保持连接，每次你需要最新的信息时，都会重复执行查询操作，哪怕只是获取集合里元素的个数。 ① 优化一——集合转数组 collToArr 123456function collToArr(coll) { for (var i = 0, a = [], len = coll.length; i &lt; len; i++) { a.push(coll[i]); } return a;} ② 缓存集合 length ③ 访问集合元素时使用局部变量（即将重复的集合访问缓存到局部变量中，用局部变量来操作） 遍历 DOM ① 使用只返回元素节点的 API 遍历 DOM, 因为这些 API 的执行效率比自己实现的效率更高： | 属性名 | 被替代属性 || children | childNodes || childElementCount | childNodes.length || firstElementChild | firstChild || lastElementChild | lastChild || nextElementSibling | nextSibling || previousElementSibling | previousSibling | ② 选择器 API——querySelectorAll() querySelectorAll() 方法使用 css 选择器作为参数并返回一个 NodeList——包含着匹配节点的类数组对象，该方法不会返回 HTML 集合，因此返回的节点不会对应实时文档结构，着也避免了 HTML 集合引起的性能问题。 1let arr = document.querySelectorAll(&quot;div.warning, div.notice &gt; p&quot;); 4. 重绘和重排 浏览器在下载完页面的所有组件——html,js,css, 图片等之后，会解析并生成两个内部数据结构—— DOM 树，渲染树. 一旦 DOM 树和渲染树构建完成，浏览器就开始绘制页面元素（paint）. ① 重排发生的条件： 添加或删除可见的 DOM 元素位置变化 元素尺寸改变 内容改变 页面渲染器初始化 浏览器窗口尺寸变化 出现滚动条时会触发整个页面的重排 重排必定重绘 5. 渲染树变化的排列和刷新 大多数浏览器通过队列化修改并批量执行来优化重排过程，然而获取布局信息的操作会导致队列强制刷新。 `offsetTop,offsetWidth...``scrollTop,scrollHeight...``clientTop,clientHeight...``getComputedStyle()` 一些优化建议：将设置样式的操作和获取样式的操作分开： 123456// 设置样式body.style.color = &quot;red&quot;;body.style.fontSize = &quot;24px&quot;;// 读取样式let color = body.style.color;let fontSize = body.style.fontSize; 另外，获取计算属性的兼容写法： 1234function getComputedStyle(el){ var computed = (document.body.currentStyle ? el.currentStyle : document.defaultView.getComputedStyle(el,''); return computed} 6. 最小化重绘和重排 ①. 批量改变样式 12/* 使用cssText */el.style.cssText = 'border-left: 1px; border-right: 2px; padding: 20px'; ②. 批量修改 dom 的优化方案——使元素脱离文档流 - 对其应用多重改变 - 把元素带回文档 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function appendDataToEl(option){ var targetEl = option.target || document.body, createEl, data = option.data || []; var targetEl_display = targetEl.style.display; targetEl.style.display = 'none'; var fragment = document.createDocumentFragment(); for(var i=0, max = data.length; i&lt; max; i++){ createEl = document.createElement(option.createEl); for(var item in data[i]){ if(item.toString() === 'text'){ createEl.appendChild(document.createTextNode(data[i][item])); continue; } if(item.toString() === 'html'){ createEl.innerHTML = item,data[i][item]; continue; } createEl.setAttribute(item,data[i][item]); } fragment.appendChild(createEl); } targetEl.appendChild(fragment); targetEl.style.display = targetEl_display;}// 使用var wrap = document.querySelectorAll('.wrap')[0];var data = [ {name: 'xujaing',text: '选景', title: 'xuanfij'}, {name: 'xujaing',text: '选景', title: 'xuanfij'}, {name: 'xujaing',text: '选景', title: 'xuanfij'}];appendDataToEl({ target: wrap, createEl: 'div', data: data}); 上面的优化方法使用了文档片段: 当我们把文档片段插入到节点中时，实际上被添加的只是该片段的子节点，而不是片段本身。可以使得 dom 操作更有效率。 ③. 缓存布局信息 1234567//缓存布局信息let current = el.offsetLeft;current++;el.style.left = current + &quot;px&quot;;if (current &gt; 300) { stop();} ④. 慎用: hover 如果有大量元素使用: hover, 那么会降低相应速度，CPU 升高 ⑤. 使用事件委托（通过事件冒泡实现）来减少事件 处理器的数量，减少内存和处理时间 12345678910111213141516171819202122function delegation(e, selector, callback) { e = e || window.event; var target = e.target || e.srcElement; if ( target.nodeName !== selector || target.className !== selector || target.id !== selector ) { return; } if (typeof e.preventDefault === &quot;function&quot;) { e.preventDefault(); e.stopPropagation(); } else { e.returnValue = false; e.cancelBubble = true; } callback();} 四. 算法和流程控制 1. 循环中减少属性查找并反转 (可以提升 50%-60% 的性能) 123456789// for 循环for(var i=item.length; i--){ process(item[i]);}// while循环var j = item.length;while(j--){ process(item[i]);} 2. 使用 Duff 装置来优化循环（该方法在后面的文章中会详细介绍） 3. 基于函数的迭代（比基于循环的迭代慢） 123items.forEach(function(value,index,array){ process(value);}) 4. 通常情况下 switch 总比 if-else 快，但是不是最佳方案 五. 字符串和正则表达式 1. 除了 IE 外，其他浏览器会尝试为表达式左侧的字符串分配更多的内存，然后简单的将第二个字符串拷贝到他的末尾，如果在一个循环中，基础字符串位于最左侧，就可以避免重复拷贝一个逐渐变大的基础字符串。2. 使用[\\s\\S]来匹配任意字符串 3. 去除尾部空白的常用做法： 12345if (!String.prototype.trim) { String.prototype.trim = function () { return this.replace(/^\\s+/, &quot;&quot;).replace(/\\s\\s*$/, &quot;&quot;); };} 六. 快速响应的用户界面 1. 浏览器的 UI 线程：用于执行 javascript 和更新用户界面的进程。 2. 在 windows 系统中定时器分辨率为 15 毫秒，因此设置小于 15 毫秒将会使 IE 锁定，延时的最小值建议为 25ms. 3. 用延时数组分割耗时任务： 1234567891011121314function multistep(steps, args, callback) { var tasks = steps.concat(); setTimeout(function () { var task = tasks.shift(); task.apply(null, args || []); if (tasks.length &gt; 0) { setTimeout(arguments.callee, 25); } else { callback(); } }, 25);} 4. 记录代码运行时间批处理任务： 1234567891011121314151617function timeProcessArray(items, process, callback) { var todo = item.concat(); setTimeout(function () { var start = +new Date(); do { process(todo.shift()); } while (todo.length &gt; 0 &amp;&amp; +new Date() - start &lt; 50); if (todo.length &gt; 0) { setTimeout(arguments.callee, 25); } else { callback(items); } }, 25);} 5. 使用 Web Worker：它引入了一个接口，能使代码运行且不占用浏览器 UI 线程的时间。一个 Worker 由如下部分组成： ① 一个 navigator 对象，包括 appName,appVersion,user Agent 和 platform. ② 一个 location 对象，只读。 ③ 一个 self 对象，指向全局 worker 对象 ④ 一个 importScripts() 方法，用来加载 worker 所用到的外部 js 文件 ⑤ 所有的 ECMAScript 对象。如 object,Array,Date 等 ⑥ XMLHttpRequest 构造器 ⑦ setTimeout()，setInterval() ⑧ 一个 close() 方法，它能立刻停止 worker 运行 应用场景 编码 / 解码大字符串 2. 复杂数学运算（包括图像，视屏处理） 3. 大数组排序 1234567891011121314151617var worker = new Worker('code.js');worker.onmessage = function(event){ console.log(event.data);}worker.postMessage('hello');importScripts('a.js','b.js');self.onmessage = function(event){ self.postMessage('hello' + event.data);} 七. ajax 优化1. 向服务器请求数据的五种方式： ① XMLHttpRequest ② Dynamic script tag insertion 动态脚本注入 ③ iframes ④ Comet（基于 http 长连接的服务端推送技术） ⑤ Multipart XHR（允许客户端只用一个 http 请求就可以从服务器向客户端传送多个资源） 2. 单纯向服务端发送数据（beacons 方法）——信标 123456789101112131415// 唯一缺点是接收到的响应类型是有限的var url = '/req.php';var params = ['step=2','time=123'];(new Image()).src = url + '?' + params.join('&amp;');// 如果向监听服务端发送回的数据，可以在onload中实现var beacon = new Image();beacon.src = ...;beacon.onload = function(){ ...}beacon.onerror = function(){ ...} 3.ajax 性能的一些建议 缓存数据 1. 在服务端设置 Expires 头信息确保浏览器缓存多久响应（必须 GET 请求） 2. 客户端把获取到的信息缓存到本地，避免再次请求 八. 编程实践 1. 避免重复工作 12345678910111213// 1.延迟加载var a = (x, y) =&gt; { if (x &gt; 4) { a = 0; } else { a = 1; }};// 需要使用时调用a();// 2.条件预加载（适用于函数马上执行并频繁操作的场景）var b = a &gt; 0 ? &quot;4&quot; : &quot;0&quot;; 2. 使用 Object/Array 字面量 3. 多用原生方法 九. 构建与部署高性能的 js 应用 1.js 的 http 压缩 当 web 浏览器请求一个资源时，它通常会发送一个 Accept-Encoding HTTP 头来告诉 Web 服务器它支持那种编码转换类型。这个信息主要用来压缩文档以获取更快的下载，从而改善用户体验。Accept-Encoding 可用的值包括：gzip,compress,deflate,identity. 如果 Web 服务器在请求中看到这些信息头，他会选择最合适的编码方式，并通过 Content-Encoding HTTP 头通知 WEB 浏览器它的决定。 2. 使用 H5 离线缓存 3. 使用内容分发网络 CDN 4. 对页面进行性能分析 123456789101112131415// 检测代码运行时间var Timer = { _data: {}, start: function (key) { Timer._data[key] = new Date(); }, stop: function (key) { var time = Timer._data[key]; if (time) { Timer._data[key] = new Date() - time; } console.log(Timer._data[key]); return Timer._data[key]; },}; 十. 浏览器缓存 1. 添加 Expires 头 2. 使用 cache-control cache-ontrol 详解 浏览器缓存机制 十一. 压缩组件 1.web 客户端可以通过 http 请求中的 Accept-Encoding 头来表示对压缩的支持 1234Accept-Encoding: gzipContent-Encoding: gzip 2. 压缩能将响应的数据量减少将近 70%，因此可考虑对 html, 脚本，样式，图片进行压缩 十二. 白屏现象的原因 浏览器（如 IE）在样式表没有完全下载完成之前不会呈现页面，导致页面白屏。如果样式表放在页面底部，那么浏览器会花费更长的时间下载样式表，因此会出现白屏，所以最好把样式表放在 head 内。白屏是浏览器对 “无样式闪烁” 的修缮。如果浏览器不采用 “白屏” 机制，将页面内容逐步显示（如 Firefox），则后加载的样式表将导致页面重绘重排，将会承担页面闪烁的风险。 十三. css 表达式使用一次性表达式 (但最好避免 css 表达式) 使用 css 表达式时执行函数重写自身 12345678// cssp{ background-color: expression(altBgcolor(this))}// jsfunction altBgcolor(el){ el.style.backgroundColor = (new Date()).getHours() % 2 ? &quot;#fff&quot; : &quot;#06c&quot;;} 十四. 减少 DNS 查找DNS 缓存和 TTL 1.DNS查找可以被缓存起来以提高性能：DNS信息会留在操作系统的DNS缓存中（Microsoft Windows上的“DNS Client服务”,之后对该主机名的请求无需进行过多的查找2.TTL(time to live): 该值告诉客户端可以对记录缓存多久。建议将TTL值设置为一天// 客户端收到DNS记录的平均TTL只有最大TTL值的一半因为DNS解析器返回的时间是其记录的TTL的剩余时间，对于给定的主机名，每次执行DNS查找时接收的TTL值都会变化3.通过使用Keep-Alive和较少的域名来减少DNS查找4.一般建议将页面组件分别放到至少2个，但不要超过4个主机名下复制代码 十五. 避免重定向这块需要前后端共同配合，对页面路由进行统一规范。 最后欢迎一起探索打造高性能的 web 应用，在公众号《趣谈前端》加入前端大家庭，和我们一起讨论吧！ 汇总系列推荐 前端必不可少的 Git 使用技巧 《javascript 高级程序设计》核心知识总结 前端开发中不可忽视的知识点汇总（一） css3 实战汇总（附源码） 让你瞬间提高工作效率的常用 js 函数汇总 (持续更新) 欢迎关注下方公众号，获取更多前端知识精粹和学习社群： 回复 学习路径，将获取笔者多年从业经验的前端学习路径的思维导图 回复 lodash，将获得本人亲自翻译的 lodash API 中文思维导图 趣谈前端 Vue、React、小程序、Node 前端算法 | 性能 | 架构 | 安全https://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA%3D%3D&amp;chksm=fc531be6cb2492f04475bac0fecbd1a9f9781ca67f35bd30c320964b24a8cbc2ca3d7bbd5345&amp;idx=1&amp;mid=2247483933&amp;scene=21&amp;sn=c2729ef1fd4a28f4707bb923a5ffae79#wechat_redirect","link":"/2021/04/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%8415%E6%9D%A1%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"title":"一篇文章让你彻底掌握 Shell","text":"由于 bash 是 Linux 标准默认的 shell 解释器，可以说 bash 是 shell 编程的基础。 本文主要介绍 bash 的语法，对于 linux 指令不做任何介绍。 📦 本文已归档到：『blog』💻 本文的源码已归档到『 linux-tutorial』 12345███████╗██╗ ██╗███████╗██╗ ██╗██╔════╝██║ ██║██╔════╝██║ ██║███████╗███████║█████╗ ██║ ██║╚════██║██╔══██║██╔══╝ ██║ ██║███████║██║ ██║███████╗███████╗███████╗ 简介什么是 shell Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。 Shell 既是一种命令语言，又是一种程序设计语言。 Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问 Linux 内核的服务。 Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。 什么是 shell 脚本Shell 脚本（shell script），是一种为 shell 编写的脚本程序，一般文件后缀为 .sh。 业界所说的 shell 通常都是指 shell 脚本，但 shell 和 shell script 是两个不同的概念。 Shell 环境Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 Shell 的解释器种类众多，常见的有： sh - 即 Bourne Shell。sh 是 Unix 标准默认的 shell。 bash - 即 Bourne Again Shell。bash 是 Linux 标准默认的 shell。 fish - 智能和用户友好的命令行 shell。 xiki - 使 shell 控制台更友好，更强大。 zsh - 功能强大的 shell 与脚本语言。 指定脚本解释器在 shell 脚本，#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。#! 被称作shebang（也称为 Hashbang ）。 所以，你应该会在 shell 中，见到诸如以下的注释： 指定 sh 解释器 1#!/bin/sh 指定 bash 解释器 1#!/bin/bash 注意 上面的指定解释器的方式是比较常见的，但有时候，你可能也会看到下面的方式： 1#!/usr/bin/env bash 这样做的好处是，系统会自动在 PATH 环境变量中查找你指定的程序（本例中的bash）。相比第一种写法，你应该尽量用这种写法，因为程序的路径是不确定的。这样写还有一个好处，操作系统的PATH变量有可能被配置为指向程序的另一个版本。比如，安装完新版本的bash，我们可能将其路径添加到PATH中，来“隐藏”老版本。如果直接用#!/bin/bash，那么系统会选择老版本的bash来执行脚本，如果用#!/usr/bin/env bash，则会使用新版本。 模式shell 有交互和非交互两种模式。 交互模式 简单来说，你可以将 shell 的交互模式理解为执行命令行。 看到形如下面的东西，说明 shell 处于交互模式下： 1user@host:~$ 接着，便可以输入一系列 Linux 命令，比如 ls，grep，cd，mkdir，rm 等等。 非交互模式 简单来说，你可以将 shell 的非交互模式理解为执行 shell 脚本。 在非交互模式下，shell 从文件或者管道中读取命令并执行。 当 shell 解释器执行完文件中的最后一个命令，shell 进程终止，并回到父进程。 可以使用下面的命令让 shell 以非交互模式运行： 1234sh /path/to/script.shbash /path/to/script.shsource /path/to/script.sh./path/to/script.sh 上面的例子中，script.sh是一个包含 shell 解释器可以识别并执行的命令的普通文本文件，sh和bash是 shell 解释器程序。你可以使用任何喜欢的编辑器创建script.sh（vim，nano，Sublime Text, Atom 等等）。 其中，source /path/to/script.sh 和 ./path/to/script.sh 是等价的。 除此之外，你还可以通过chmod命令给文件添加可执行的权限，来直接执行脚本文件： 12chmod +x /path/to/script.sh #使脚本具有执行权限/path/to/test.sh 这种方式要求脚本文件的第一行必须指明运行该脚本的程序，比如： 💻 『示例源码』 12#!/usr/bin/env bashecho &quot;Hello, world!&quot; 上面的例子中，我们使用了一个很有用的命令echo来输出字符串到屏幕上。 基本语法解释器前面虽然两次提到了#! ，但是本着重要的事情说三遍的精神，这里再强调一遍： 在 shell 脚本，#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。#! 被称作shebang（也称为 Hashbang ）。 #! 决定了脚本可以像一个独立的可执行文件一样执行，而不用在终端之前输入sh, bash, python, php等。 123# 以下两种方式都可以指定 shell 解释器为 bash，第二种方式更好#!/bin/bash#!/usr/bin/env bash 注释注释可以说明你的代码是什么作用，以及为什么这样写。 shell 语法中，注释是特殊的语句，会被 shell 解释器忽略。 单行注释 - 以 # 开头，到行尾结束。 多行注释 - 以 :&lt;&lt;EOF 开头，到 EOF 结束。 💻 『示例源码』 1234567891011121314#--------------------------------------------# shell 注释示例# author：zp#--------------------------------------------# echo '这是单行注释'########## 这是分割线 ##########:&lt;&lt;EOFecho '这是多行注释'echo '这是多行注释'echo '这是多行注释'EOF echoecho 用于字符串的输出。 输出普通字符串： 12echo &quot;hello, world&quot;# Output: hello, world 输出含变量的字符串： 12echo &quot;hello, \\&quot;zp\\&quot;&quot;# Output: hello, &quot;zp&quot; 输出含变量的字符串： 123name=zpecho &quot;hello, \\&quot;${name}\\&quot;&quot;# Output: hello, &quot;zp&quot; 输出含换行符的字符串： 12345678# 输出含换行符的字符串echo &quot;YES\\nNO&quot;# Output: YES\\nNOecho -e &quot;YES\\nNO&quot; # -e 开启转义# Output:# YES# NO 输出含不换行符的字符串： 12345678910echo &quot;YES&quot;echo &quot;NO&quot;# Output:# YES# NOecho -e &quot;YES\\c&quot; # -e 开启转义 \\c 不换行echo &quot;NO&quot;# Output:# YESNO 输出重定向至文件 1echo &quot;test&quot; &gt; test.txt 输出执行结果 12echo `pwd`# Output:(当前目录路径) 💻 『示例源码』 123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env bash# 输出普通字符串echo &quot;hello, world&quot;# Output: hello, world# 输出含变量的字符串echo &quot;hello, \\&quot;zp\\&quot;&quot;# Output: hello, &quot;zp&quot;# 输出含变量的字符串name=zpecho &quot;hello, \\&quot;${name}\\&quot;&quot;# Output: hello, &quot;zp&quot;# 输出含换行符的字符串echo &quot;YES\\nNO&quot;# Output: YES\\nNOecho -e &quot;YES\\nNO&quot; # -e 开启转义# Output:# YES# NO# 输出含不换行符的字符串echo &quot;YES&quot;echo &quot;NO&quot;# Output:# YES# NOecho -e &quot;YES\\c&quot; # -e 开启转义 \\c 不换行echo &quot;NO&quot;# Output:# YESNO# 输出内容定向至文件echo &quot;test&quot; &gt; test.txt# 输出执行结果echo `pwd`# Output:(当前目录路径) printfprintf 用于格式化输出字符串。 默认，printf 不会像 echo 一样自动添加换行符，如果需要换行可以手动添加 \\n。 💻 『示例源码』 12345678910111213141516171819202122232425262728293031323334353637383940# 单引号printf '%d %s\\n' 1 &quot;abc&quot;# Output:1 abc# 双引号printf &quot;%d %s\\n&quot; 1 &quot;abc&quot;# Output:1 abc# 无引号printf %s abcdef# Output: abcdef(并不会换行)# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出printf &quot;%s\\n&quot; abc def# Output:# abc# defprintf &quot;%s %s %s\\n&quot; a b c d e f g h i j# Output:# a b c# d e f# g h i# j# 如果没有参数，那么 %s 用 NULL 代替，%d 用 0 代替printf &quot;%s and %d \\n&quot;# Output:# and 0# 格式化输出printf &quot;%-10s %-8s %-4s\\n&quot; 姓名 性别 体重kgprintf &quot;%-10s %-8s %-4.2f\\n&quot; 郭靖 男 66.1234printf &quot;%-10s %-8s %-4.2f\\n&quot; 杨过 男 48.6543printf &quot;%-10s %-8s %-4.2f\\n&quot; 郭芙 女 47.9876# Output:# 姓名 性别 体重kg# 郭靖 男 66.12# 杨过 男 48.65# 郭芙 女 47.99 printf 的转义符 序列 说明 \\a 警告字符，通常为 ASCII 的 BEL 字符 \\b 后退 \\c 抑制（不显示）输出结果中任何结尾的换行字符（只在%b 格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略 \\f 换页（formfeed） \\n 换行 \\r 回车（Carriage return） \\t 水平制表符 \\v 垂直制表符 \\\\ 一个字面上的反斜杠字符 \\ddd 表示 1 到 3 位数八进制值的字符。仅在格式字符串中有效 \\0ddd 表示 1 到 3 位的八进制值字符 变量跟许多程序设计语言一样，你可以在 bash 中创建变量。 Bash 中没有数据类型，bash 中的变量可以保存一个数字、一个字符、一个字符串等等。同时无需提前声明变量，给变量赋值会直接创建变量。 变量命名原则 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用 bash 里的关键字（可用 help 命令查看保留关键字）。 声明变量访问变量的语法形式为：${var} 和 $var 。 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，所以推荐加花括号。 123word=&quot;hello&quot;echo ${word}# Output: hello 只读变量使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 1234rword=&quot;hello&quot;echo ${rword}readonly rword# rword=&quot;bye&quot; # 如果放开注释，执行时会报错 删除变量使用 unset 命令可以删除变量。变量被删除后不能再次使用。unset 命令不能删除只读变量。 1234567dword=&quot;hello&quot; # 声明变量echo ${dword} # 输出变量值# Output: hellounset dword # 删除变量echo ${dword}# Output: （空） 变量类型 局部变量 - 局部变量是仅在某个脚本内部有效的变量。它们不能被其他的程序和脚本访问。 环境变量 - 环境变量是对当前 shell 会话内所有的程序或脚本都可见的变量。创建它们跟创建局部变量类似，但使用的是 export 关键字，shell 脚本也可以定义环境变量。 常见的环境变量： 变量 描述 $HOME 当前用户的用户目录 $PATH 用分号分隔的目录列表，shell 会到这些目录中查找命令 $PWD 当前工作目录 $RANDOM 0 到 32767 之间的整数 $UID 数值类型，当前用户的用户 ID $PS1 主要系统输入提示符 $PS2 次要系统输入提示符 这里 有一张更全面的 Bash 环境变量列表。 💻 『示例源码』 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/env bash################### 声明变量 ###################name=&quot;world&quot;echo &quot;hello ${name}&quot;# Output: hello world################### 输出变量 ###################folder=$(pwd)echo &quot;current path: ${folder}&quot;################### 只读变量 ###################rword=&quot;hello&quot;echo ${rword}# Output: helloreadonly rword# rword=&quot;bye&quot; # 如果放开注释，执行时会报错################### 删除变量 ###################dword=&quot;hello&quot; # 声明变量echo ${dword} # 输出变量值# Output: hellounset dword # 删除变量echo ${dword}# Output: （空）################### 系统变量 ###################echo &quot;UID:$UID&quot;echo LOGNAME:$LOGNAMEecho User:$USERecho HOME:$HOMEecho PATH:$PATHecho HOSTNAME:$HOSTNAMEecho SHELL:$SHELLecho LANG:$LANG################### 自定义变量 ###################days=10user=&quot;admin&quot;echo &quot;$user logged in $days days age&quot;days=5user=&quot;root&quot;echo &quot;$user logged in $days days age&quot;# Output:# admin logged in 10 days age# root logged in 5 days age################### 从变量读取列表 ###################colors=&quot;Red Yellow Blue&quot;colors=$colors&quot; White Black&quot;for color in $colorsdo echo &quot; $color&quot;done 字符串单引号和双引号shell 字符串可以用单引号 ''，也可以用双引号 “”，也可以不用引号。 单引号的特点 单引号里不识别变量 单引号里不能出现单独的单引号（使用转义符也不行），但可成对出现，作为字符串拼接使用。 双引号的特点 双引号里识别变量 双引号里可以出现转义字符 综上，推荐使用双引号。 拼接字符串123456789101112131415# 使用单引号拼接name1='white'str1='hello, '${name1}''str2='hello, ${name1}'echo ${str1}_${str2}# Output:# hello, white_hello, ${name1}# 使用双引号拼接name2=&quot;black&quot;str3=&quot;hello, &quot;${name2}&quot;&quot;str4=&quot;hello, ${name2}&quot;echo ${str3}_${str4}# Output:# hello, black_hello, black 获取字符串长度1234text=&quot;12345&quot;echo ${#text}# Output:# 5 截取子字符串1234text=&quot;12345&quot;echo ${text:2:2}# Output:# 34 从第 3 个字符开始，截取 2 个字符 查找子字符串12345678#!/usr/bin/env bashtext=&quot;hello&quot;echo `expr index &quot;${text}&quot; ll`# Execute: ./str-demo5.sh# Output:# 3 查找 ll 子字符在 hello 字符串中的起始位置。 💻 『示例源码』 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#!/usr/bin/env bash################### 使用单引号拼接字符串 ###################name1='white'str1='hello, '${name1}''str2='hello, ${name1}'echo ${str1}_${str2}# Output:# hello, white_hello, ${name1}################### 使用双引号拼接字符串 ###################name2=&quot;black&quot;str3=&quot;hello, &quot;${name2}&quot;&quot;str4=&quot;hello, ${name2}&quot;echo ${str3}_${str4}# Output:# hello, black_hello, black################### 获取字符串长度 ###################text=&quot;12345&quot;echo &quot;${text} length is: ${#text}&quot;# Output:# 12345 length is: 5# 获取子字符串text=&quot;12345&quot;echo ${text:2:2}# Output:# 34################### 查找子字符串 ###################text=&quot;hello&quot;echo `expr index &quot;${text}&quot; ll`# Output:# 3################### 判断字符串中是否包含子字符串 ###################result=$(echo &quot;${str}&quot; | grep &quot;feature/&quot;)if [[ &quot;$result&quot; != &quot;&quot; ]]; then echo &quot;feature/ 是 ${str} 的子字符串&quot;else echo &quot;feature/ 不是 ${str} 的子字符串&quot;fi################### 截取关键字左边内容 ###################full_branch=&quot;feature/1.0.0&quot;branch=`echo ${full_branch#feature/}`echo &quot;branch is ${branch}&quot;################### 截取关键字右边内容 ###################full_version=&quot;0.0.1-SNAPSHOT&quot;version=`echo ${full_version%-SNAPSHOT}`echo &quot;version is ${version}&quot;################### 字符串分割成数组 ###################str=&quot;0.0.0.1&quot;OLD_IFS=&quot;$IFS&quot;IFS=&quot;.&quot;array=( ${str} )IFS=&quot;$OLD_IFS&quot;size=${#array[*]}lastIndex=`expr ${size} - 1`echo &quot;数组长度：${size}&quot;echo &quot;最后一个数组元素：${array[${lastIndex}]}&quot;for item in ${array[@]}do echo &quot;$item&quot;done################### 判断字符串是否为空 ####################-n 判断长度是否非零#-z 判断长度是否为零str=testingstr2=''if [[ -n &quot;$str&quot; ]]then echo &quot;The string $str is not empty&quot;else echo &quot;The string $str is empty&quot;fiif [[ -n &quot;$str2&quot; ]]then echo &quot;The string $str2 is not empty&quot;else echo &quot;The string $str2 is empty&quot;fi# Output:# The string testing is not empty# The string is empty################### 字符串比较 ###################str=hellostr2=worldif [[ $str = &quot;hello&quot; ]]; then echo &quot;str equals hello&quot;else echo &quot;str not equals hello&quot;fiif [[ $str2 = &quot;hello&quot; ]]; then echo &quot;str2 equals hello&quot;else echo &quot;str2 not equals hello&quot;fi 数组bash 只支持一维数组。 数组下标从 0 开始，下标可以是整数或算术表达式，其值应大于或等于 0。 创建数组123# 创建数组的不同方式nums=([2]=2 [0]=0 [1]=1)colors=(red yellow &quot;dark blue&quot;) 访问数组元素 访问数组的单个元素： 12echo ${nums[1]}# Output: 1 访问数组的所有元素： 12345echo ${colors[*]}# Output: red yellow dark blueecho ${colors[@]}# Output: red yellow dark blue 上面两行有很重要（也很微妙）的区别： 为了将数组中每个元素单独一行输出，我们用 printf 命令： 123456printf &quot;+ %s\\n&quot; ${colors[*]}# Output:# + red# + yellow# + dark# + blue 为什么dark和blue各占了一行？尝试用引号包起来： 123printf &quot;+ %s\\n&quot; &quot;${colors[*]}&quot;# Output:# + red yellow dark blue 现在所有的元素都在一行输出 —— 这不是我们想要的！让我们试试${colors[@]} 12345printf &quot;+ %s\\n&quot; &quot;${colors[@]}&quot;# Output:# + red# + yellow# + dark blue 在引号内，${colors[@]}将数组中的每个元素扩展为一个单独的参数；数组元素中的空格得以保留。 访问数组的部分元素： 123echo ${nums[@]:0:2}# Output:# 0 1 在上面的例子中，${array[@]} 扩展为整个数组，:0:2取出了数组中从 0 开始，长度为 2 的元素。 访问数组长度123echo ${#nums[*]}# Output:# 3 向数组中添加元素向数组中添加元素也非常简单： 1234colors=(white &quot;${colors[@]}&quot; green black)echo ${colors[@]}# Output:# white red yellow dark blue green black 上面的例子中，${colors[@]} 扩展为整个数组，并被置换到复合赋值语句中，接着，对数组colors的赋值覆盖了它原来的值。 从数组中删除元素用unset命令来从数组中删除一个元素： 1234unset nums[0]echo ${nums[@]}# Output:# 1 2 💻 『示例源码』 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/env bash################### 创建数组 ###################nums=( [ 2 ] = 2 [ 0 ] = 0 [ 1 ] = 1 )colors=( red yellow &quot;dark blue&quot; )################### 访问数组的单个元素 ###################echo ${nums[1]}# Output: 1################### 访问数组的所有元素 ###################echo ${colors[*]}# Output: red yellow dark blueecho ${colors[@]}# Output: red yellow dark blueprintf &quot;+ %s\\n&quot; ${colors[*]}# Output:# + red# + yellow# + dark# + blueprintf &quot;+ %s\\n&quot; &quot;${colors[*]}&quot;# Output:# + red yellow dark blueprintf &quot;+ %s\\n&quot; &quot;${colors[@]}&quot;# Output:# + red# + yellow# + dark blue################### 访问数组的部分元素 ###################echo ${nums[@]:0:2}# Output:# 0 1################### 获取数组长度 ###################echo ${#nums[*]}# Output:# 3################### 向数组中添加元素 ###################colors=( white &quot;${colors[@]}&quot; green black )echo ${colors[@]}# Output:# white red yellow dark blue green black################### 从数组中删除元素 ###################unset nums[ 0 ]echo ${nums[@]}# Output:# 1 2 运算符算术运算符下表列出了常用的算术运算符，假定变量 x 为 10，变量 y 为 20： 运算符 说明 举例 + 加法 expr $x + $y 结果为 30。 - 减法 expr $x - $y 结果为 -10。 * 乘法 expr $x * $y 结果为 200。 / 除法 expr $y / $x 结果为 2。 % 取余 expr $y % $x 结果为 0。 = 赋值 x=$y 将把变量 y 的值赋给 x。 == 相等。用于比较两个数字，相同则返回 true。 [ $x == $y ] 返回 false。 != 不相等。用于比较两个数字，不相同则返回 true。 [ $x != $y ] 返回 true。 注意：条件表达式要放在方括号之间，并且要有空格，例如: [$x==$y] 是错误的，必须写成 [ $x == $y ]。 💻 『示例源码』 12345678910111213141516171819202122232425262728293031323334353637x=10y=20echo &quot;x=${x}, y=${y}&quot;val=`expr ${x} + ${y}`echo &quot;${x} + ${y} = $val&quot;val=`expr ${x} - ${y}`echo &quot;${x} - ${y} = $val&quot;val=`expr ${x} \\* ${y}`echo &quot;${x} * ${y} = $val&quot;val=`expr ${y} / ${x}`echo &quot;${y} / ${x} = $val&quot;val=`expr ${y} % ${x}`echo &quot;${y} % ${x} = $val&quot;if [[ ${x} == ${y} ]]then echo &quot;${x} = ${y}&quot;fiif [[ ${x} != ${y} ]]then echo &quot;${x} != ${y}&quot;fi# Output:# x=10, y=20# 10 + 20 = 30# 10 - 20 = -10# 10 * 20 = 200# 20 / 10 = 2# 20 % 10 = 0# 10 != 20 关系运算符关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 下表列出了常用的关系运算符，假定变量 x 为 10，变量 y 为 20： 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ]返回 false。 -ne 检测两个数是否相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ]返回 true。 💻 『示例源码』 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849x=10y=20echo &quot;x=${x}, y=${y}&quot;if [[ ${x} -eq ${y} ]]; then echo &quot;${x} -eq ${y} : x 等于 y&quot;else echo &quot;${x} -eq ${y}: x 不等于 y&quot;fiif [[ ${x} -ne ${y} ]]; then echo &quot;${x} -ne ${y}: x 不等于 y&quot;else echo &quot;${x} -ne ${y}: x 等于 y&quot;fiif [[ ${x} -gt ${y} ]]; then echo &quot;${x} -gt ${y}: x 大于 y&quot;else echo &quot;${x} -gt ${y}: x 不大于 y&quot;fiif [[ ${x} -lt ${y} ]]; then echo &quot;${x} -lt ${y}: x 小于 y&quot;else echo &quot;${x} -lt ${y}: x 不小于 y&quot;fiif [[ ${x} -ge ${y} ]]; then echo &quot;${x} -ge ${y}: x 大于或等于 y&quot;else echo &quot;${x} -ge ${y}: x 小于 y&quot;fiif [[ ${x} -le ${y} ]]; then echo &quot;${x} -le ${y}: x 小于或等于 y&quot;else echo &quot;${x} -le ${y}: x 大于 y&quot;fi# Output:# x=10, y=20# 10 -eq 20: x 不等于 y# 10 -ne 20: x 不等于 y# 10 -gt 20: x 不大于 y# 10 -lt 20: x 小于 y# 10 -ge 20: x 小于 y# 10 -le 20: x 小于或等于 y 布尔运算符下表列出了常用的布尔运算符，假定变量 x 为 10，变量 y 为 20： 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 💻 『示例源码』 1234567891011121314151617181920212223242526272829303132333435x=10y=20echo &quot;x=${x}, y=${y}&quot;if [[ ${x} != ${y} ]]; then echo &quot;${x} != ${y} : x 不等于 y&quot;else echo &quot;${x} != ${y}: x 等于 y&quot;fiif [[ ${x} -lt 100 &amp;&amp; ${y} -gt 15 ]]; then echo &quot;${x} 小于 100 且 ${y} 大于 15 : 返回 true&quot;else echo &quot;${x} 小于 100 且 ${y} 大于 15 : 返回 false&quot;fiif [[ ${x} -lt 100 || ${y} -gt 100 ]]; then echo &quot;${x} 小于 100 或 ${y} 大于 100 : 返回 true&quot;else echo &quot;${x} 小于 100 或 ${y} 大于 100 : 返回 false&quot;fiif [[ ${x} -lt 5 || ${y} -gt 100 ]]; then echo &quot;${x} 小于 5 或 ${y} 大于 100 : 返回 true&quot;else echo &quot;${x} 小于 5 或 ${y} 大于 100 : 返回 false&quot;fi# Output:# x=10, y=20# 10 != 20 : x 不等于 y# 10 小于 100 且 20 大于 15 : 返回 true# 10 小于 100 或 20 大于 100 : 返回 true# 10 小于 5 或 20 大于 100 : 返回 false 逻辑运算符以下介绍 Shell 的逻辑运算符，假定变量 x 为 10，变量 y 为 20: 运算符 说明 举例 &amp;&amp; 逻辑的 AND [[ ${x} -lt 100 &amp;&amp; ${y} -gt 100 ]] 返回 false ` ` 💻 『示例源码』 1234567891011121314151617181920212223x=10y=20echo &quot;x=${x}, y=${y}&quot;if [[ ${x} -lt 100 &amp;&amp; ${y} -gt 100 ]]then echo &quot;${x} -lt 100 &amp;&amp; ${y} -gt 100 返回 true&quot;else echo &quot;${x} -lt 100 &amp;&amp; ${y} -gt 100 返回 false&quot;fiif [[ ${x} -lt 100 || ${y} -gt 100 ]]then echo &quot;${x} -lt 100 || ${y} -gt 100 返回 true&quot;else echo &quot;${x} -lt 100 || ${y} -gt 100 返回 false&quot;fi# Output:# x=10, y=20# 10 -lt 100 &amp;&amp; 20 -gt 100 返回 false# 10 -lt 100 || 20 -gt 100 返回 true 字符串运算符下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”： 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为 0，为 0 返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为 0，不为 0 返回 true。 [ -n $a ] 返回 true。 str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 💻 『示例源码』 12345678910111213141516171819202122232425262728293031323334353637383940414243x=&quot;abc&quot;y=&quot;xyz&quot;echo &quot;x=${x}, y=${y}&quot;if [[ ${x} = ${y} ]]; then echo &quot;${x} = ${y} : x 等于 y&quot;else echo &quot;${x} = ${y}: x 不等于 y&quot;fiif [[ ${x} != ${y} ]]; then echo &quot;${x} != ${y} : x 不等于 y&quot;else echo &quot;${x} != ${y}: x 等于 y&quot;fiif [[ -z ${x} ]]; then echo &quot;-z ${x} : 字符串长度为 0&quot;else echo &quot;-z ${x} : 字符串长度不为 0&quot;fiif [[ -n &quot;${x}&quot; ]]; then echo &quot;-n ${x} : 字符串长度不为 0&quot;else echo &quot;-n ${x} : 字符串长度为 0&quot;fiif [[ ${x} ]]; then echo &quot;${x} : 字符串不为空&quot;else echo &quot;${x} : 字符串为空&quot;fi# Output:# x=abc, y=xyz# abc = xyz: x 不等于 y# abc != xyz : x 不等于 y# -z abc : 字符串长度不为 0# -n abc : 字符串长度不为 0# abc : 字符串不为空 文件测试运算符文件测试运算符用于检测 Unix 文件的各种属性。 属性检测描述如下： 操作符 说明 举例 -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。 -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ]返回 false。 -p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。 -s file 检测文件是否为空（文件大小是否大于 0），不为空返回 true。 [ -s $file ] 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 💻 『示例源码』 12345678910111213141516171819202122232425262728293031323334353637383940414243444546file=&quot;/etc/hosts&quot;if [[ -r ${file} ]]; then echo &quot;${file} 文件可读&quot;else echo &quot;${file} 文件不可读&quot;fiif [[ -w ${file} ]]; then echo &quot;${file} 文件可写&quot;else echo &quot;${file} 文件不可写&quot;fiif [[ -x ${file} ]]; then echo &quot;${file} 文件可执行&quot;else echo &quot;${file} 文件不可执行&quot;fiif [[ -f ${file} ]]; then echo &quot;${file} 文件为普通文件&quot;else echo &quot;${file} 文件为特殊文件&quot;fiif [[ -d ${file} ]]; then echo &quot;${file} 文件是个目录&quot;else echo &quot;${file} 文件不是个目录&quot;fiif [[ -s ${file} ]]; then echo &quot;${file} 文件不为空&quot;else echo &quot;${file} 文件为空&quot;fiif [[ -e ${file} ]]; then echo &quot;${file} 文件存在&quot;else echo &quot;${file} 文件不存在&quot;fi# Output:(根据文件的实际情况，输出结果可能不同)# /etc/hosts 文件可读# /etc/hosts 文件可写# /etc/hosts 文件不可执行# /etc/hosts 文件为普通文件# /etc/hosts 文件不是个目录# /etc/hosts 文件不为空# /etc/hosts 文件存在 控制语句条件语句跟其它程序设计语言一样，Bash 中的条件语句让我们可以决定一个操作是否被执行。结果取决于一个包在[[ ]]里的表达式。 由[[ ]]（sh中是[ ]）包起来的表达式被称作 检测命令 或 基元。这些表达式帮助我们检测一个条件的结果。这里可以找到有关bash 中单双中括号区别的答案。 共有两个不同的条件表达式：if和case。 if（1）if 语句 if在使用上跟其它语言相同。如果中括号里的表达式为真，那么then和fi之间的代码会被执行。fi标志着条件代码块的结束。 12345678910# 写成一行if [[ 1 -eq 1 ]]; then echo &quot;1 -eq 1 result is: true&quot;; fi# Output: 1 -eq 1 result is: true# 写成多行if [[ &quot;abc&quot; -eq &quot;abc&quot; ]]then echo &quot;&quot;abc&quot; -eq &quot;abc&quot; result is: true&quot;fi# Output: abc -eq abc result is: true （2）if else 语句 同样，我们可以使用if..else语句，例如： 123456if [[ 2 -ne 1 ]]; then echo &quot;true&quot;else echo &quot;false&quot;fi# Output: true （3）if elif else 语句 有些时候，if..else不能满足我们的要求。别忘了if..elif..else，使用起来也很方便。 💻 『示例源码』 12345678910x=10y=20if [[ ${x} &gt; ${y} ]]; then echo &quot;${x} &gt; ${y}&quot;elif [[ ${x} &lt; ${y} ]]; then echo &quot;${x} &lt; ${y}&quot;else echo &quot;${x} = ${y}&quot;fi# Output: 10 &lt; 20 case如果你需要面对很多情况，分别要采取不同的措施，那么使用case会比嵌套的if更有用。使用case来解决复杂的条件判断，看起来像下面这样： 💻 『示例源码』 12345678910111213141516171819202122execcase ${oper} in &quot;+&quot;) val=`expr ${x} + ${y}` echo &quot;${x} + ${y} = ${val}&quot; ;; &quot;-&quot;) val=`expr ${x} - ${y}` echo &quot;${x} - ${y} = ${val}&quot; ;; &quot;*&quot;) val=`expr ${x} \\* ${y}` echo &quot;${x} * ${y} = ${val}&quot; ;; &quot;/&quot;) val=`expr ${x} / ${y}` echo &quot;${x} / ${y} = ${val}&quot; ;; *) echo &quot;Unknown oper!&quot; ;;esac 每种情况都是匹配了某个模式的表达式。|用来分割多个模式，)用来结束一个模式序列。第一个匹配上的模式对应的命令将会被执行。*代表任何不匹配以上给定模式的模式。命令块儿之间要用;;分隔。 循环语句循环其实不足为奇。跟其它程序设计语言一样，bash 中的循环也是只要控制条件为真就一直迭代执行的代码块。 Bash 中有四种循环：for，while，until和select。 for循环for与它在 C 语言中的姊妹非常像。看起来是这样： 1234for arg in elem1 elem2 ... elemNdo ### 语句done 在每次循环的过程中，arg依次被赋值为从elem1到elemN。这些值还可以是通配符或者大括号扩展。 当然，我们还可以把for循环写在一行，但这要求do之前要有一个分号，就像下面这样： 1for i in {1..5}; do echo $i; done 还有，如果你觉得for..in..do对你来说有点奇怪，那么你也可以像 C 语言那样使用for，比如： 123for (( i = 0; i &lt; 10; i++ )); do echo $idone 当我们想对一个目录下的所有文件做同样的操作时，for就很方便了。举个例子，如果我们想把所有的.bash文件移动到script文件夹中，并给它们可执行权限，我们的脚本可以这样写： 💻 『示例源码』 12345DIR=/home/zpfor FILE in ${DIR}/*.sh; do mv &quot;$FILE&quot; &quot;${DIR}/scripts&quot;done# 将 /home/zp 目录下所有 sh 文件拷贝到 /home/zp/scripts while循环while循环检测一个条件，只要这个条件为 _真_，就执行一段命令。被检测的条件跟if..then中使用的基元并无二异。因此一个while循环看起来会是这样： 1234while [[ condition ]]do ### 语句done 跟for循环一样，如果我们把do和被检测的条件写到一行，那么必须要在do之前加一个分号。 💻 『示例源码』 1234567891011121314151617### 0到9之间每个数的平方x=0while [[ ${x} -lt 10 ]]; do echo $((x * x)) x=$((x + 1))done# Output:# 0# 1# 4# 9# 16# 25# 36# 49# 64# 81 until循环until循环跟while循环正好相反。它跟while一样也需要检测一个测试条件，但不同的是，只要该条件为 假 就一直执行循环： 💻 『示例源码』 1234567891011x=0until [[ ${x} -ge 5 ]]; do echo ${x} x=`expr ${x} + 1`done# Output:# 0# 1# 2# 3# 4 select循环select循环帮助我们组织一个用户菜单。它的语法几乎跟for循环一致： 1234select answer in elem1 elem2 ... elemNdo ### 语句done select会打印elem1..elemN以及它们的序列号到屏幕上，之后会提示用户输入。通常看到的是$?（PS3变量）。用户的选择结果会被保存到answer中。如果answer是一个在1..N之间的数字，那么语句会被执行，紧接着会进行下一次迭代 —— 如果不想这样的话我们可以使用break语句。 💻 『示例源码』 1234567891011121314#!/usr/bin/env bashPS3=&quot;Choose the package manager: &quot;select ITEM in bower npm gem pipdoecho -n &quot;Enter the package name: &quot; &amp;&amp; read PACKAGEcase ${ITEM} in bower) bower install ${PACKAGE} ;; npm) npm install ${PACKAGE} ;; gem) gem install ${PACKAGE} ;; pip) pip install ${PACKAGE} ;;esacbreak # 避免无限循环done 这个例子，先询问用户他想使用什么包管理器。接着，又询问了想安装什么包，最后执行安装操作。 运行这个脚本，会得到如下输出： 1234567$ ./my_script1) bower2) npm3) gem4) pipChoose the package manager: 2Enter the package name: gitbook-cli break 和 continue如果想提前结束一个循环或跳过某次循环执行，可以使用 shell 的break和continue语句来实现。它们可以在任何循环中使用。 break语句用来提前结束当前循环。 continue语句用来跳过某次迭代。 💻 『示例源码』 12345678910# 查找 10 以内第一个能整除 2 和 3 的正整数i=1while [[ ${i} -lt 10 ]]; do if [[ $((i % 3)) -eq 0 ]] &amp;&amp; [[ $((i % 2)) -eq 0 ]]; then echo ${i} break; fi i=`expr ${i} + 1`done# Output: 6 💻 『示例源码』 12345678910111213# 打印10以内的奇数for (( i = 0; i &lt; 10; i ++ )); do if [[ $((i % 2)) -eq 0 ]]; then continue; fi echo ${i}done# Output:# 1# 3# 5# 7# 9 函数bash 函数定义语法如下： 1234[ function ] funname [()] { action; [return int;]} 💡 说明： 函数定义时，function 关键字可有可无。 函数返回值 - return 返回函数返回值，返回值类型只能为整数（0-255）。如果不加 return 语句，shell 默认将以最后一条命令的运行结果，作为函数返回值。 函数返回值在调用该函数后通过 $? 来获得。 所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至 shell 解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。 💻 『示例源码』 1234567891011121314151617181920212223242526272829303132#!/usr/bin/env bashcalc(){ PS3=&quot;choose the oper: &quot; select oper in + - \\* / # 生成操作符选择菜单 do echo -n &quot;enter first num: &quot; &amp;&amp; read x # 读取输入参数 echo -n &quot;enter second num: &quot; &amp;&amp; read y # 读取输入参数 exec case ${oper} in &quot;+&quot;) return $((${x} + ${y})) ;; &quot;-&quot;) return $((${x} - ${y})) ;; &quot;*&quot;) return $((${x} * ${y})) ;; &quot;/&quot;) return $((${x} / ${y})) ;; *) echo &quot;${oper} is not support!&quot; return 0 ;; esac break done}calcecho &quot;the result is: $?&quot; # $? 获取 calc 函数返回值 执行结果： 123456789$ ./function-demo.sh1) +2) -3) *4) /choose the oper: 3enter first num: 10enter second num: 10the result is: 100 位置参数位置参数是在调用一个函数并传给它参数时创建的变量。 位置参数变量表： 变量 描述 $0 脚本名称 $1 … $9 第 1 个到第 9 个参数列表 ${10} … ${N} 第 10 个到 N 个参数列表 $* or $@ 除了$0外的所有位置参数 $# 不包括$0在内的位置参数的个数 $FUNCNAME 函数名称（仅在函数内部有值） 💻 『示例源码』 1234567891011121314151617181920212223#!/usr/bin/env bashx=0if [[ -n $1 ]]; then echo &quot;第一个参数为：$1&quot; x=$1else echo &quot;第一个参数为空&quot;fiy=0if [[ -n $2 ]]; then echo &quot;第二个参数为：$2&quot; y=$2else echo &quot;第二个参数为空&quot;fiparamsFunction(){ echo &quot;函数第一个入参：$1&quot; echo &quot;函数第二个入参：$2&quot;}paramsFunction ${x} ${y} 执行结果： 1234567891011$ ./function-demo2.sh第一个参数为空第二个参数为空函数第一个入参：0函数第二个入参：0$ ./function-demo2.sh 10 20第一个参数为：10第二个参数为：20函数第一个入参：10函数第二个入参：20 执行 ./variable-demo4.sh hello world ，然后在脚本中通过 $1、$2 … 读取第 1 个参数、第 2 个参数。。。 函数处理参数另外，还有几个特殊字符用来处理参数： 参数处理 说明 $# 返回参数个数 $* 返回所有参数 $$ 脚本运行的当前进程 ID 号 $! 后台运行的最后一个进程的 ID 号 $@ 返回所有参数 $- 返回 Shell 使用的当前选项，与 set 命令功能相同。 $? 函数返回值 💻 『示例源码』 12345678910111213141516171819202122232425262728293031323334runner() { return 0}name=zpparamsFunction(){ echo &quot;函数第一个入参：$1&quot; echo &quot;函数第二个入参：$2&quot; echo &quot;传递到脚本的参数个数：$#&quot; echo &quot;所有参数：&quot; printf &quot;+ %s\\n&quot; &quot;$*&quot; echo &quot;脚本运行的当前进程 ID 号：$$&quot; echo &quot;后台运行的最后一个进程的 ID 号：$!&quot; echo &quot;所有参数：&quot; printf &quot;+ %s\\n&quot; &quot;$@&quot; echo &quot;Shell 使用的当前选项：$-&quot; runner echo &quot;runner 函数的返回值：$?&quot;}paramsFunction 1 &quot;abc&quot; &quot;hello, \\&quot;zp\\&quot;&quot;# Output:# 函数第一个入参：1# 函数第二个入参：abc# 传递到脚本的参数个数：3# 所有参数：# + 1 abc hello, &quot;zp&quot;# 脚本运行的当前进程 ID 号：26400# 后台运行的最后一个进程的 ID 号：# 所有参数：# + 1# + abc# + hello, &quot;zp&quot;# Shell 使用的当前选项：hB# runner 函数的返回值：0 Shell 扩展扩展 发生在一行命令被分成一个个的 记号（tokens） 之后。换言之，扩展是一种执行数学运算的机制，还可以用来保存命令的执行结果，等等。 感兴趣的话可以阅读关于 shell 扩展的更多细节。 大括号扩展大括号扩展让生成任意的字符串成为可能。它跟 文件名扩展 很类似，举个例子： 1echo beg{i,a,u}n ### begin began begun 大括号扩展还可以用来创建一个可被循环迭代的区间。 12echo {0..5} ### 0 1 2 3 4 5echo {00..8..2} ### 00 02 04 06 08 命令置换命令置换允许我们对一个命令求值，并将其值置换到另一个命令或者变量赋值表达式中。当一个命令被``或$()包围时，命令置换将会执行。举个例子： 12345now=`date +%T`### ornow=$(date +%T)echo $now ### 19:08:26 算数扩展在 bash 中，执行算数运算是非常方便的。算数表达式必须包在$(( ))中。算数扩展的格式为： 12result=$(( ((10 + 5*3) - 7) / 2 ))echo $result ### 9 在算数表达式中，使用变量无需带上$前缀： 12345x=4y=7echo $(( x + y )) ### 11echo $(( ++x + y++ )) ### 12echo $(( x + y )) ### 13 单引号和双引号单引号和双引号之间有很重要的区别。在双引号中，变量引用或者命令置换是会被展开的。在单引号中是不会的。举个例子： 12echo &quot;Your home: $HOME&quot; ### Your home: /Users/&lt;username&gt;echo 'Your home: $HOME' ### Your home: $HOME 当局部变量和环境变量包含空格时，它们在引号中的扩展要格外注意。随便举个例子，假如我们用echo来输出用户的输入： 123INPUT=&quot;A string with strange whitespace.&quot;echo $INPUT ### A string with strange whitespace.echo &quot;$INPUT&quot; ### A string with strange whitespace. 调用第一个echo时给了它 5 个单独的参数 —— $INPUT 被分成了单独的词，echo在每个词之间打印了一个空格。第二种情况，调用echo时只给了它一个参数（整个$INPUT 的值，包括其中的空格）。 来看一个更严肃的例子： 123FILE=&quot;Favorite Things.txt&quot;cat $FILE ### 尝试输出两个文件: `Favorite` 和 `Things.txt`cat &quot;$FILE&quot; ### 输出一个文件: `Favorite Things.txt` 尽管这个问题可以通过把 FILE 重命名成Favorite-Things.txt来解决，但是，假如这个值来自某个环境变量，来自一个位置参数，或者来自其它命令（find, cat, 等等）呢。因此，如果输入 可能 包含空格，务必要用引号把表达式包起来。 流和重定向Bash 有很强大的工具来处理程序之间的协同工作。使用流，我们能将一个程序的输出发送到另一个程序或文件，因此，我们能方便地记录日志或做一些其它我们想做的事。 管道给了我们创建传送带的机会，控制程序的执行成为可能。 学习如何使用这些强大的、高级的工具是非常非常重要的。 输入、输出流Bash 接收输入，并以字符序列或 字符流 的形式产生输出。这些流能被重定向到文件或另一个流中。 有三个文件描述符： 代码 描述符 描述 0 stdin 标准输入 1 stdout 标准输出 2 stderr 标准错误输出 重定向重定向让我们可以控制一个命令的输入来自哪里，输出结果到什么地方。这些运算符在控制流的重定向时会被用到： Operator Description &gt; 重定向输出 &amp;&gt; 重定向输出和错误输出 &amp;&gt;&gt; 以附加的形式重定向输出和错误输出 &lt; 重定向输入 &lt;&lt; Here 文档 语法 &lt;&lt;&lt; Here 字符串 以下是一些使用重定向的例子： 1234567891011### ls的结果将会被写到list.txt中ls -l &gt; list.txt### 将输出附加到list.txt中ls -a &gt;&gt; list.txt### 所有的错误信息会被写到errors.txt中grep da * 2&gt; errors.txt### 从errors.txt中读取输入less &lt; errors.txt /dev/null 文件如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null： 1$ command &gt; /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。 如果希望屏蔽 stdout 和 stderr，可以这样写： 1$ command &gt; /dev/null 2&gt;&amp;1 Debugshell 提供了用于 debug 脚本的工具。 如果想采用 debug 模式运行某脚本，可以在其 shebang 中使用一个特殊的选项： 1#!/bin/bash options options 是一些可以改变 shell 行为的选项。下表是一些可能对你有用的选项： Short Name Description -f noglob 禁止文件名展开（globbing） -i interactive 让脚本以 交互 模式运行 -n noexec 读取命令，但不执行（语法检查） -t — 执行完第一条命令后退出 -v verbose 在执行每条命令前，向stderr输出该命令 -x xtrace 在执行每条命令前，向stderr输出该命令以及该命令的扩展参数 举个例子，如果我们在脚本中指定了-x例如： 12345#!/bin/bash -xfor (( i = 0; i &lt; 3; i++ )); do echo $idone 这会向stdout打印出变量的值和一些其它有用的信息： 123456789101112131415$ ./my_script+ (( i = 0 ))+ (( i &lt; 3 ))+ echo 00+ (( i++ ))+ (( i &lt; 3 ))+ echo 11+ (( i++ ))+ (( i &lt; 3 ))+ echo 22+ (( i++ ))+ (( i &lt; 3 )) 有时我们值需要 debug 脚本的一部分。这种情况下，使用set命令会很方便。这个命令可以启用或禁用选项。使用-启用选项，+禁用选项： 💻 『示例源码』 123456789101112131415161718192021222324# 开启 debugset -xfor (( i = 0; i &lt; 3; i++ )); do printf ${i}done# 关闭 debugset +x# Output:# + (( i = 0 ))# + (( i &lt; 3 ))# + printf 0# 0+ (( i++ ))# + (( i &lt; 3 ))# + printf 1# 1+ (( i++ ))# + (( i &lt; 3 ))# + printf 2# 2+ (( i++ ))# + (( i &lt; 3 ))# + set +xfor i in {1..5}; do printf ${i}; doneprintf &quot;\\n&quot;# Output: 12345 资源 awesome-shell - shell 资源列表 awesome-bash - bash 资源列表 bash-handbook bash-guide - bash 基本用法指南 bash-it - 为你日常使用、开发以及维护 shell 脚本和自定义命令提供了一个可靠的框架 dotfiles.github.io - 上面有 bash 和其它 shell 的各种 dotfiles 集合以及 shell 框架的链接 Runoob Shell 教程 shellcheck - 一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。 最后，Stack Overflow 上 bash 标签下有很多你可以学习的问题，当你遇到问题时，也是一个提问的好地方。 https://github.com/dunwu/blog/blob/master/source/_posts/coding/shell.md","link":"/2017/11/17/linux/shell/"}],"tags":[{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"VUE","slug":"VUE","link":"/tags/VUE/"},{"name":"工程化","slug":"工程化","link":"/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"登录","slug":"登录","link":"/tags/%E7%99%BB%E5%BD%95/"},{"name":"鉴权","slug":"鉴权","link":"/tags/%E9%89%B4%E6%9D%83/"},{"name":"rollup","slug":"rollup","link":"/tags/rollup/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"shell","slug":"shell","link":"/tags/shell/"}],"categories":[{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"VUE","slug":"VUE","link":"/categories/VUE/"},{"name":"工程化","slug":"工程化","link":"/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"业务","slug":"业务","link":"/categories/%E4%B8%9A%E5%8A%A1/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"性能优化","slug":"性能优化","link":"/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"}]}