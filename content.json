{"pages":[],"posts":[{"title":"CSS 变量及其应用","text":"基本介绍自定义属性（有时候也被称作CSS变量或者级联变量）是由CSS作者定义的，它包含的值可以在整个文档中重复使用。由自定义属性标记设定值（比如： **--main-color: black;**），由var() 函数来获取值（比如： color: **var(--main-color)**;）复杂的网站都会有大量的CSS代码，通常也会有许多重复的值。举个例子，同样一个颜色值可能在成千上百个地方被使用到，如果这个值发生了变化，需要全局搜索并且一个一个替换（很麻烦哎～）。自定义属性在某个地方存储一个值，然后在其他许多地方引用它。另一个好处是语义化的标识。比如，--main-text-color 会比 #00ff00 更易理解，尤其是这个颜色值在其他上下文中也被使用到。自定义属性受级联的约束，并从其父级继承其值。 与sass less 变量的区别 sass命名是$color，less命名是@color，css命名是–color。 读取css变量，需要使用val()方法，sass和less可以直接使用。 css最大优势在于不需要编译，在运行时可以随时修改，同时应用到上下文。缺点是不兼容ie浏览器。 基本用法声明一个自定义属性，属性名需要以两个减号（--）开始，属性值则可以是任何有效的CSS值。和其他属性一样，自定义属性也是写在规则集之内的，如下： 123element { --main-bg-color: brown;} 注意，规则集所指定的选择器定义了自定义属性的可见作用域。通常的最佳实践是定义在根伪类 :root 下，这样就可以在HTML文档的任何地方访问到它了： 123:root { --main-bg-color: brown;} 然而这条规则不是绝对的，如果有理由去限制你的自定义属性，那么就应该限制。**注意：自定义属性名是大小写敏感的，--my-color 和 --My-color 会被认为是两个不同的自定义属性。如前所述，使用一个局部变量时用 var() 函数包裹以表示一个合法的属性值： 123element { background-color: var(--main-bg-color);} 使用自定义属性的第一步我们从这个简单的CSS代码开始，它将相同的颜色应用在了不同class的元素上： 12345678910111213141516171819202122232425262728293031.one { color: white; background-color: brown; margin: 10px; width: 50px; height: 50px; display: inline-block;}.two { color: white; background-color: black; margin: 10px; width: 150px; height: 70px; display: inline-block;}.three { color: white; background-color: brown; margin: 10px; width: 75px;}.four { color: white; background-color: brown; margin: 10px; width: 100px;}.five { background-color: brown;} 应用在如下HTML上： 123456&lt;div&gt; &lt;div class=&quot;one&quot;&gt;1:&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;2: Text &lt;span class=&quot;five&quot;&gt;5 - more text&lt;/span&gt;&lt;/div&gt; &lt;input class=&quot;three&quot;&gt; &lt;textarea class=&quot;four&quot;&gt;4: Lorem Ipsum&lt;/textarea&gt;&lt;/div&gt; 其呈现是：注意到在CSS代码中的重复：背景色 brown 被多处设置。对于一些CSS声明，是可以在级联关系更高的位置设置，通过CSS继承自然地解决这个重复的问题。但在一般项目中，是不可能通过这样的方式去解决。通过在 :root 伪类上设置自定义属性，然后在整个文档需要的地方使用，可以减少这样的重复性： 12345678910111213141516171819202122232425262728293031323334:root { --main-bg-color: brown;}.one { color: white; background-color: var(--main-bg-color); margin: 10px; width: 50px; height: 50px; display: inline-block;}.two { color: white; background-color: black; margin: 10px; width: 150px; height: 70px; display: inline-block;}.three { color: white; background-color: var(--main-bg-color); margin: 10px; width: 75px;}.four { color: white; background-color: var(--main-bg-color); margin: 10px; width: 100px;}.five { background-color: var(--main-bg-color);} 这里呈现的结果和前面的例子是一致的，但允许对所需属性值进行一个规范的声明。### 自定义属性的继承性自定义属性会继承。这意味着如果在一个给定的元素上，没有为这个自定义属性设置值，在其父元素上的值会被使用。看这一段HTML： 123456&lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;two&quot;&gt; &lt;div class=&quot;three&quot;&gt;&lt;/div&gt; &lt;div class=&quot;four&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 配套的CSS： 123456.two { --test: 10px;}.three { --test: 2em;} 在这个情况下， var(--test) 的结果分别是： 对于元素 class=&quot;two&quot; ：10px 对于元素 class=&quot;three&quot; ：2em 对于元素 class=&quot;four&quot; ：10px （继承自父属性） 对于元素 class=&quot;one&quot; ：_非法值_，会变成自定义属性的默认值 注意，这些是自定义属性，并不是你在其他编程语言中遇到的实际的变量。这些值仅当需要的时候才会计算，而并不会按其他规则进行保存。比如，你不能为元素设置一个属性，然后让它从兄弟或旁支子孙规则上获取值。属性仅用于匹配当前选择器及其子孙，这和通常的CSS是一样的。### 自定义属性备用值用 var() 函数可以定义多个备用值(fallback value)，当给定值未定义时将会用备用值替换。这对于 Custom Elements 和 Shadow DOM 都很有用。备用值并不是用于实现浏览器兼容性的。如果浏览器不支持CSS自定义属性，备用值也没什么用。它仅对支持CSS自定义属性的浏览器提供了一个备份机制，该机制仅当给定值未定义或是无效值的时候生效。函数的第一个参数是自定义属性的名称。如果提供了第二个参数，则表示备用值，当自定义属性值无效时生效。第二个参数可以嵌套，但是不能继续平铺展开下去了，例如： 123456789.two { color: var(--my-var, red); /* Red if --my-var is not defined */}.three { background-color: var(--my-var, var(--my-background, pink)); /* pink if --my-var and --my-background are not defined */}.three { background-color: var(--my-var, --my-background, pink); /* Invalid: &quot;--my-background, pink&quot; */} 第二个例子展示了如何处理一个以上的 fallback。该技术可能会导致性能问题，因为它花了更多的时间在处理这些变量上。注意：像自定义属性这些 fallback 语法允许使用逗号。比如 var(--foo, red, blue) 定义了一个 red, blue 的备用值——从第一个逗号到最后的全部内容，都会被作为备用值的一部分。### 有效性和值传统的CSS概念里，有效性和属性是绑定的，这对自定义属性来说并不适用。当自定义属性值被解析，浏览器不知道它们什么时候会被使用，所以必须认为这些值都是_有效的_。不幸的是，即便这些值是有效的，但当通过 var() 函数调用时，它在特定上下文环境下也可能不会奏效。属性和自定义变量会导致无效的CSS语句，这引入了一个新的概念：_计算时有效性_。### 无效变量会导致什么？当浏览器遇到无效的 var() 时，会使用继承值或初始值代替。考虑如下代码： 1&lt;p&gt;This paragraph is initial black.&lt;/p&gt; 123:root { --text-color: 16px; }p { color: blue; }p { color: var(--text-color); } 毫不意外，浏览器将 --text-color 的值替换给了 var(--text-color)，但是 16px 并不是 color 的合法属性值。代换之后，该属性不会产生任何作用。浏览器会执行如下两个步骤： 检查属性 color 是否为继承属性。是，但是 &lt;p&gt; 没有任何父元素定义了 color 属性。转到下一步。 将该值设置为它的默认初始值，比如 black。Result 段落颜色并不是蓝色，因为无效代换导致了它被替换成了默认初始值的黑色。如果你直接写n color: 16px 的话，则会导致语法错误，而前面的定义则会生效（段落显示为蓝色）。注意：当CSS属性-值对中存在语法错误，该行则会被忽略。然而如果自定义属性的值无效，它并不会被忽略，从而会导致该值被覆盖为默认值。### JavaScript 中的值在 JavaScript 中获取或者修改 CSS 变量和操作普通 CSS 属性是一样的： 123456// 获取一个 Dom 节点上的 CSS 变量element.style.getPropertyValue(&quot;--my-var&quot;);// 获取任意 Dom 节点上的 CSS 变量getComputedStyle(element).getPropertyValue(&quot;--my-var&quot;);// 修改一个 Dom 节点上的 CSS 变量element.style.setProperty(&quot;--my-var&quot;, jsVar + 4); 应用：全局样式，定义主题，快速切换。实现黑夜模式深色模式为目前网络发展的一大趋势，可以看到大量的网站为了提高网站的体验都添加了深色模式。深色模式在光线不足的情况下看起来不会那么刺眼，能够很好的保护我们的眼睛。在这边文章中主要讲如何使用CSS和JS实现深色模式和浅色模式的任意切换### 分析需求假设有这么一个页面，我们需要自由切换深色模式和浅色模式。那么就需要在不同模式使用不同的css，这里可以通过两种方式一种是直接引入不同的css文件，另外一种通过更改css变量值的方式进行更改样式，下面是浅色模式的截图### 具体实现首先定义浅色模式的变量名和变量值 1234567891011:root { --primary-bg: #eee; --primary-fg: #000; --secondary-bg: #ddd; --secondary-fg: #555; --primary-btn-bg: #000; --primary-btn-fg: #fff; --secondary-btn-bg: #ff0000; --secondary-btn-fg: #ffff00;}复制代码 当切换场景的时候需要更改css变量的值，更改如下: 1234567891011:root { --primary-bg: #282c35; --primary-fg: #fff; --secondary-bg: #1e2129; --secondary-fg: #aaa; --primary-btn-bg: #ddd; --primary-btn-fg: #222; --secondary-btn-bg: #780404; --secondary-btn-fg: #baba6a;}复制代码 可以看到当切换到深色模式的时候，变量使用了更加暗的颜色，从而实现深色模式### 更改css如何切换到暗模式有多种解决方法，在这里我们使用媒体查询，prefers-color-scheme这个媒体查询能够获取到用户的系统是否切换到了深色主题，具体如下: 1234567891011121314@media (prefers-color-scheme: dark) { :root { --primary-bg: #282c35; --primary-fg: #fff; --secondary-bg: #1e2129; --secondary-fg: #aaa; --primary-btn-bg: #ddd; --primary-btn-fg: #222; --secondary-btn-bg: #780404; --secondary-btn-fg: #baba6a; --image-opacity: 0.85; }}复制代码 如果希望用户可以通过选择系统的设置来切换浅色模式还是深色模式，那么上面这种方式就足够了。浏览的网站能够通过系统设置选择不同的样式但是上面这种方式存在一个问题，就是用户希望这个页面的模式不要跟随系统配置的更改而更改。用户可以主动更改网站的模式，那么上面这种方式就不合适了 手动选择模式思路就是通过控制js来给元素添加不同的class，不同的class拥有不同的样式。首先添加在html中添加一个按钮用于切换不同的模式 12345&lt;button id=&quot;toggle-button&quot;&gt;toggle&lt;/button&gt;&lt;script&gt; const toggleButton = document.querySelector('#toggle-button')&lt;/script&gt;复制代码 然后需要地方存储用户的偏好设置，这里使用localStorage来存储用户的选择。然后给按钮添加事件用于切换主题，下面是具体的代码 1234567891011121314151617const toggleButton = document.querySelector('#toggle-button') toggleButton.addEventListener('click', (e) =&gt; { darkMode = localStorage.getItem('theme'); if (darkMode === 'dark') { disableDarkMode(); } else { enableDarkMode(); } }); function enableDarkMode() { localStorage.setItem('theme', 'dark'); } function disableDarkMode() { localStorage.setItem('theme', 'light'); }复制代码 现在我们就可以存储这个用户的偏好设置。然后不同的主题下给body元素添加不同的class，具体如下 123456789function enableDarkMode() { document.body.classList.add(&quot;dark-mode&quot;) localStorage.setItem('theme', 'dark'); } function disableDarkMode() { document.body.classList.remove(&quot;dark-mode&quot;) localStorage.setItem('theme', 'light'); }复制代码 和媒体查询一样，在dark-mode的情况下更改css变量的属性值，具体如下: 123456789101112.dark-mode { --primary-bg: #282c35; --primary-fg: #fff; --secondary-bg: #1e2129; --secondary-fg: #aaa; --primary-btn-bg: #ddd; --primary-btn-fg: #222; --secondary-btn-bg: #780404; --secondary-btn-fg: #baba6a; --image-opacity: 0.85;}复制代码 同时在进入这个页面的时候需要获取到用户的偏好设置，从localStorage中读取 123let darkMode = localStorage.getItem(&quot;theme&quot;)if (darkMode === &quot;dark&quot;) enableDarkMode()复制代码 这次就可以在页面刷新以后仍然拿到用户的偏好设置。","link":"/2021/01/05/CSS/CSS%20%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"},{"title":"ES2020(ES11)新特性","text":"ECMAScript 2020 是 ECMAScript 语言规范的第11版，引入了以下新特性。 目录 String的matchAll方法 动态导入语句 import() import.meta export * as ns from ‘module’ Promise.allSettled 一种新的数据类型: BigInt GlobalThis Promise.allSettled 一种新的数据类型： BigInt Nullish coalescing Operator matchAllmatchAll() 方法返回一个包含所有匹配正则表达式的结果的迭代器。使用 for…of 遍历或者使用操作符 … Array.from 将其转换成数组。 1234const reg = /[0-3]/g;const data = '2020';console.log(data.matchAll(reg)); // data.matchAll 的返回值是一个迭代器console.log([...data.matchAll(reg)]); /* 0: [“2”, index: 0, input: “2020”, groups: undefined] 1: [“0”, index: 1, input: “2020”, groups: undefined] 2: [“2”, index: 2, input: “2020”, groups: undefined] 3: [“0”, index: 3, input: “2020”, groups: undefined] */ Dynamic import标准用法的 import 导入的模块是静态的，会使所有被导入的模块，在加载时就被翻译(无法做到按需编译，降低首页加载速度)。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。在 import() 之前，当我们需要根据条件导入模块时，不得不使用 require()。如： 123if(XXX){ const menu = require('./menu');} 如今可以替换为： 123if(XXX){ const menu = import('./menu');} @babel/preset-env 已经包含了 @babel/plugin-syntax-dynamic-import，因此如果要使用 import() 语法，只需要配置 @babel/preset-env 即可。**提示： 请不要滥用动态导入（只有在必要情况下采用）。静态框架能更好的初始化依赖，而且更有利于静态分析工具和 tree shaking 发挥作用。另外，import() 返回是一个 promise 对象，例如： 1234567891011//menu.jsexport default { menu: 'menu'}//index.jsif(true) { let menu = import('./menu'); console.log(menu); //Promise {&lt;pending&gt; menu.then(data =&gt; console.log(data));//Module {default: {menu: &quot;menu&quot;}, __esModule: true, Symbol(Symbol.toStringTag): &quot;Module&quot;}} else {} import.metaimport.meta 会返回一个对象，有一个 url 属性，返回当前模块的url路径，只能在模块内部使用。。 12345&lt;script src='./main.js' type=&quot;module&quot;&gt;&lt;/script&gt;//main.jsconsole.log(import.meta); //{url: &quot;http://localhost:8080/main.js&quot;} PS：使用了 http-s&lt;script src='./main.js' type=&quot;module&quot;&gt;&lt;/script&gt;//main.jsconsole.log(import.meta); //{url: &quot;http://localhost:8080/main.js&quot;} PS：使用了 http-server 启动 因为 import.meta 必须要在模块内部使用，如果不加 type=”module”，控制台会报错：Cannot use ‘import.meta’ outside a module。export * as ns from ‘module’ES2020新增了 export * as XX from ‘module’，和 import * as XX from ‘module’ 12//menu.jsexport * as ns from './info'; 可以理解为是下面两条语句合并为一句： 12import * as ns from './info';export { ns }; 不过需要注意的是 export * as ns from ‘./info’ 并不会真的将导入模块，因此在该模块(menu.js)中，我们是获取不到 ns 的。 Promise.allSettledPromise.all 或者 Promise.race 有的时候并不能满足我们的需求。比如，我们需要在所有的 Promise 都结束的时候做一些操作，而并不在乎它们是成功还是失败。在没有 Promise.allSettled之前，我们需要自已去写实现。Promise.allSettled() 方法返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果。 1234567891011const promise1 = Promise.resolve(100);const promise2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 100, 'info'));const promise3 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 200, 'name'))Promise.allSettled([promise1, promise2, promise3]). then((results) =&gt; console.log(result));/* [ { status: 'fulfilled', value: 100 }, { status: 'rejected', reason: 'info' }, { status: 'fulfilled', value: 'name' } ] 可以看到，Promise.allSettled() 的成功的结果是一个数组，该数组的每一项是一个对象，每个对象都有一个 status 属性，值为 fulfilled 或 rejected，如果 status 的值是 fulfilled，那么该对象还有一个 value 属性，其属性值是对应的 promise 成功的结果；如果 status 的值是 rejectedd，那么该对象有一个 reason 属性，其属性值是对应的 promise 失败的原因。 BigIntBigInt 是一种数字类型的数据，它可以表示任意精度格式的整数。在此之前，JS中安全的最大数字是 9009199254740091，即2^53-1，在控制台中输入 Number.MAX_SAFE_INTEGER 即可查看。超过这个值，JS 没有办法精确表示。另外，大于或等于2的1024次方的数值，JS 无法表示，会返回 Infinity。BigInt 即解决了这两个问题。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。为了和 Number 类型进行区分，BigInt类型的数据必须添加后缀 n。 123456789101112131415161718//Number类型在超过9009199254740991后，计算结果即出现问题const num1 = 90091992547409910;console.log(num1 + 1); //90091992547409900//BigInt 计算结果争取const num2 = 90091992547409910n;console.log(num2 + 1n); //90091992547409911n//Number 类型不能表示大于 2 的 1024 次方的数值let num3 = 9999;for(let i = 0; i &lt; 10; i++) { num3 = num3 * num3;}console.log(num3); //Infinity//BigInt 类型可以表示任意位数的整数let num4 = 9999n;for(let i = 0n; i &lt; 10n; i++) { num4 = num4 * num4;}console.log(num4); //一串超级长的数字，这里就不贴了 我们还可以使用 BigInt 对象来初始化 BigInt 实例： 1console.log(BigInt(999)); // 999n 注意：没有 new 关键字！！！ 需要说明的是，BigInt 和 Number 是两种数据类型，不能直接进行四则运算，不过可以进行比较操作。 123console.log(99n == 99); //trueconsole.log(99n === 99); //falseconsole.log(99n + 1);//TypeError: Cannot mix BigInt and other types, use explicit conversionss GlobalThisJS 中存在一个顶层对象，但是，顶层对象在各种实现里是不统一的。从不同的 Javascript 环境中获取全局对象需要不同的语句，在 Web 中，可以通过 window、self取到全局对象，但是在 Web Workers 中，只有 self 可以。在 Node.js 中，它们都无法获取，必须使用 global。在 globalThis 之前，我们这样去获取全局对象： 123456var getGlobal = function () { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } throw new Error('unable to locate global object');}; ES2020 中引入 globalThis 作为顶层对象，在任何环境下，都可以简单的通过 globalThis 拿到顶层对象。 Nullish coalescing OperatorES2020 新增了一个运算符 ??。当作侧的操作作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。使用 || 操作符，当左侧的操作数为0、null、undefined、NaN、false、’’时，都会使用右侧的操作符，如果使用 || 来为某些变量设置默认值，可能会遇到意料之外的行为。例如： 123jconst defaultValue = 100;let value = someValue || defaultValue;//当 someValue 转成 boolean 值为 false 时，value 的值都是 defaultValue 当 someValue 的值为 0 时，我们其实期望 value 值为 0，但是它却错误的分配成了100.??操作符可以规避以上问题，它只有在左操作数是 null 或者是 undefined时，才会返回右侧操作数。 12const defaultValue = 100;let value = someValue ?? defaultValue;//someValue 为 0 ，value 的值是 0 Optional Chaining可选链操作符？.允许读取于连接对象链深处的属性的值，而不必明确验证链中的每个引用时否有效。？.操作符的功能类似于 . 链式操作符，不同于之处在于，在引用为空 (nullish，即 null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值是 undefined。例如，我们要访问 info 对象的 animal 的 reptile 的 tortoise。但是我们不确定 animal，reptile是否存在，因此我们需要这样写： 1const tortoise = info.animal &amp;&amp; info.animal.reptile &amp;&amp; info.animal.reptile.tortoise; 因为 null.reptile 或 undefined..reptile 会抛出错误：TypeError: Cannot read property ‘reptile’ of undefined 或 TypeError: Cannot read property ‘reptile’ of null，为了避免报错，如果我们需要访问的属性更深，那么这个代码会越来越长。而有了可选链操作符？.，我们在访问 reptile 之前，不再需要校验 info.animal的值。同样，在访问 info.animal.reptile.tortoise之前，也不需要校验 info.animal.reptile的值。上面代码简化为： 1const tortoise = info.animal?.reptile?.tortoise; JS在尝试访问 info.animal.reptile 之前，会隐式检查并确定 info.animal 的值不是 null 或 undefined，如果其值是 null 或 undefined，如果其值是 null 或 undefined，那么表达式短路计算直接返回 undefined。可以看到可选链操作符 ?. 和空位合并操作符一样，都是针对的 null 和 undefined 这两个值。","link":"/2021/01/05/JS/ES2020(ES11)%E6%96%B0%E7%89%B9%E6%80%A7/"},{"title":"JS常用实现（一）","text":"debounce（防抖）防抖可以让多个顺序调用的事件合成一个，防止抖动，防止正常需要一次执行就可以的事件执行了多次。在用户停止触发事件的时候，才进行执行事件。例如在搜索引擎输入框中输入文字时，每输入一个键盘字符，搜索框会实时将输入值通过请求发送到后台。将每个用户输入的字符都发送至后台，会导致请求过于频繁，造成资源的浪费。同时用户的体验也不佳，每输入一个字符都发送请求，对于服务器的性能要求很高，因为如果请求耗时太长，就无法做到每敲一个字符，就马上出来关联的输入提示内容，需要很优秀的服务器性能来配合实现。所以一般来说，这样的输入框都需要用防抖来进行处理。除非数据检索或者代码执行耗时足够短，可以不做处理。同样适用的场景有浏览器的大小调整resize监听，滚动条滚动scroll监听，按钮点击click事件等。 123456789101112/** * 防抖 * @param func 处理函数 * @param wait 等待时长，毫秒 */const debounce = (func, wait) =&gt; { let timeout = null; return () =&gt; { clearTimeout(timeout); timeout = setTimeout(func, wait); }} 123/** 测试用例 */const testDebounce = (e) =&gt; { console.log(e) }document.addEventListener('scroll', debounce(testDebounce, 300)); 这里为什么要return一个函数，因为timeout变量存在于debounce局部作用域内，正常调用后timeout变量会被内存回收。返回一个函数，引用了timeout变量，形成了闭包，所以在返回的函数内部可以读取到局部timeout变量。 throttle（节流）节流，也可以理解为限流。让事件在每个间隔的时间里，只执行一次。和防抖不同，节流保证了在x毫秒的事件内，必然触发一次事件。例如地铁上下班时间限流，每隔5分钟才能进站一波人，这就是限流。防抖和节流，作用区别不大，在应用场景上有一定的重合，关键在于是否需要在一段时间内必须触发一次事件。 1234567891011121314151617181920/** * 节流，结合了防抖的例子 * @param func 处理函数 * @param wait 等待时长，毫秒 * @param mustRun 间隔时长，毫秒 */const throttle = (func, wait, mustRun) =&gt; { let timeout = null; let startTime = new Date(); return (...args) =&gt; { const curTime = new Date(); clearTimeout(timeout); if (curTime - startTime &gt;= mustRun) { func.apply(this, args); startTime = curTime; } else { timeout = setTimeout(func, wait); } }} 123456789101112131415/** * 节流，不使用定时器。previous变量不会被销毁，所以根据节流的特性可以这样直接调用。 * @param func 处理函数 * @param mustRun 间隔时长，毫秒 */const throttle = (func, mustRun) =&gt; { let previous = 0; return (...args) =&gt; { const curTime = new Date(); if (curTime - previous &gt;= mustRun) { func.apply(this, args); previous = curTime; } }} 1234567891011121314151617/** * 节流，使用定时器 * @param func 处理函数 * @param wait 间隔时长，毫秒 */const throttle = (func, mustRun) =&gt; { let timeout = null; return (...args) =&gt; { if (timeout) { return; } timeout = setTimeout(() =&gt; { func.apply(this, args); timeout = null; }, mustRun); }} 注意 123/** 测试用例 */const test = (e) =&gt; { console.log(e) }document.addEventListener('scroll', throttle(test, 300)); new（new运算符）new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。语法 new constructor[([arguments])]new是创建一个新实例，新实例肯定是一个对象。New操作符实际上经历以下4个步骤： 创建一个新对象 将构造函数的作用域赋给新对象（this指向新对象） 执行构造函数中的代码（为新对象添加属性） 返回新对象，如果是引用类型，返回这个引用类型对象，否则返回新创建对象 new 主要来新建实例，要理解new首先来对JS原型链有一定的认识。JS原型prototype在父类里是protoype，在实例里是[[prototype]]，可以通过__proto__访问。因此创建一个新对象，同时将新对象的__proto__设置为父类的prototype，实现继承父类。例如: 123class A {};const a = new A();a.__proto__ === A.prototype; // true 12345678910111213/** * 模拟实现new * @param parentObject 父类 * @param args 父类构造函数参数 */const newObject = (parentObject, ...args) =&gt; { // 绑定原型 const newObj= Object.create(parentObject.prototype); // 使用create方法设置新对象__proto__ // 调用构造函数 const result = parentObject.apply(newObj, args); // 返回 return result instanceof Object ? result : newObj;} deepClone (深拷贝)网上的深拷贝代码一般都有些问题的，因为对于一些特殊的对象没有进行处理，但是一般也不会出现bug，简单的深拷贝有时也能实现功能。对象有可能出现循环引用。 123const a = { name: 'ben' };const b = { a };a.b = b; 结构如下：实现一 JSON.stringify &amp;&amp; JSON.parse通过JSON的两个方法使对象重新构造成新的对象实现深拷贝，它的问题在于会丢弃对象的constructor，也不支持循环引用。同时必须保证处理的对象为能够被json数据结构表示，不符合转换规则会抛出错误。 不推荐这种实现，如果要用，需要配合错误捕获方法来使用。 12const a = {};const b = JSON.parse(JSON.stringify(a)); 实现二 递归存在问题，支持的特殊对象不是很多，但是还算优雅，解决了循环引用的问题，同时遇到已经引用过的对象，不再重复循环一遍。可以解决循环引用问题，因为遇到相同对象会从cache里直接拿出来返回，并且拿出来的是已经处理过的对象，不进入循环。 1234567891011121314151617181920212223const deepClone = (obj, cache = new WeakMap()) =&gt; { if (!obj instanceof Object) return obj; if (cache.get(obj)) return cache.get(obj); // 防止循环引用 if (obj instanceof Function) { return (...arg) =&gt; { obj.apply(this, args) } } // 支持函数 if (obj instanceof Date) return new Date(obj); // 支持日期 if (obj instanceof RegExp) return new RegExp(obj.source, obj.flags); // 支持正则对象 const res = Array.isArray(obj) ? [] : {}; cache.set(obj, res); // 缓存 copy 的对象，用于处理循环引用的情况 Object.keys(obj).forEach((key) =&gt; { if (obj[key] instanceof Object) { res[key] = deepClone(obj[key], cache); } else { res[key] = obj[key]; } }); return res;} 测试用例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 执行解释// 执行deepClone(a);// 'a对应对象'本身不在缓存里，将res设置为缓存，此时初始res = {}; 初始res同时也是递归结束后要返回的对象。// 进入循环// key等于name，不在缓存里，设置缓存。继续执行，不是对象，直接返回。此时初始res = {name: 'ben'};// key等于b，不在缓存里，设置缓存。继续执行，b值是对象。进入下一层循环。此时初始res = {name: 'ben'}; b的res是： {}// key等于a，在缓存里，拿出来返回。b的res是: { a: 初始res }。循环结束，函数返回b的res。 此时初始res = {name: 'ben', b: { a: 初始res }};// 循环结束，返回初始res {name: 'ben', b: { a: 初始res }}// 注意！当时设置'a对应对象'的缓存值是新构造的res对象，所以新拿出来的'a对应对象'的缓存值，是重新构造后的值，并不是原始的值。// 变成了新的克隆对象循环引用构造后的它自己本身的值。const a = { name: 'ben' };const b = { a };a.b = b;const deepClone = (obj, cache = new WeakMap()) =&gt; { if (!obj instanceof Object) return obj; if (cache.get(obj)) return cache.get(obj); // 防止循环引用 if (obj instanceof Function) { return (...arg) =&gt; { obj.apply(this, args) } } // 支持函数 if (obj instanceof Date) return new Date(obj); // 支持日期 if (obj instanceof RegExp) return new RegExp(obj.source, obj.flags); // 支持正则对象 const res = Array.isArray(obj) ? [] : {}; cache.set(obj, res); // 缓存 copy 的对象，用于处理循环引用的情况 Object.keys(obj).forEach((key) =&gt; { console.log(key); if (obj[key] instanceof Object) { res[key] = deepClone(obj[key], cache); } else { res[key] = obj[key]; } }); console.log(res, 'res'); return res;}const c = deepClone(a);console.log(a.b.a.b.a.b === c.b.a.b.a.b); // falsea.age = 1;c.age = 2;console.log(a);console.log(c); 输出","link":"/2021/01/05/JS/JS%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"rollup初体验","text":"进入一个目录，npm init 进行初始化，可以一路回车安装tsnpm install -D typescript 生存配置文件./node_modules/.bin/tsc –init 根目录下新建一个rollup配置文件rollup.config.js 添加以下内容 1234567891011121314151617181920212223242526272829303132333435363738import clear from 'rollup-plugin-clear'; // 转换cjsimport commonjs from 'rollup-plugin-commonjs'; // 转换cjsimport { terser } from 'rollup-plugin-terser'; // 压缩，可以判断模式，开发模式不加入到pluginsimport resolve from 'rollup-plugin-node-resolve';import babel from 'rollup-plugin-babel';import typescript from 'rollup-plugin-typescript';export default { input: 'src/index.ts', // 源文件入口 output: [ { file: 'dist/browser-version.esm.js', // package.json 中 &quot;module&quot;: &quot;dist/browser-version.esm.js&quot; format: 'esm', // es module 形式的包， 用来import 导入， 可以tree shaking sourcemap: false }, { file: 'dist/browser-version.cjs.js', // package.json 中 &quot;main&quot;: &quot;dist/browser-version.cjs.js&quot;, format: 'cjs', // commonjs 形式的包， require 导入 sourcemap: false }, { file: 'dist/browser-version.umd.js', name: 'GLWidget', format: 'umd', // umd 兼容形式的包， 可以直接应用于网页 script sourcemap: false, } ], plugins: [ clear({ targets: ['dist'] }), resolve(), babel({ exclude: 'node_modules/**' }), typescript(), commonjs(), terser(), ]} 修改packagejson 12345678910111213141516171819202122232425262728293031323334353637{ &quot;name&quot;: &quot;browser-version-tool-html&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Print tips on outdate browser. &quot;, &quot;main&quot;: &quot;dist/browser-version.cjs.js&quot;, &quot;module&quot;: &quot;dist/browser-version.esm.js&quot;, &quot;browser&quot;: &quot;dist/browser-version.umd.js&quot;, &quot;scripts&quot;: { &quot;build&quot;: &quot;rollup -c&quot;, &quot;dev&quot;: &quot;rollup -c -w&quot;, &quot;test&quot;: &quot;ts-node test/test.ts&quot;, &quot;pretest&quot;: &quot;npm run build&quot; }, &quot;author&quot;: &quot;Yenkos&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: { &quot;@babel/core&quot;: &quot;^7.12.10&quot;, &quot;@rollup/plugin-html&quot;: &quot;^0.2.0&quot;, &quot;@types/ms&quot;: &quot;^0.7.31&quot;, &quot;babel-plugin-external-helpers&quot;: &quot;^6.22.0&quot;, &quot;babel-preset-latest&quot;: &quot;^6.24.1&quot;, &quot;rollup&quot;: &quot;^2.35.1&quot;, &quot;rollup-plugin-babel&quot;: &quot;^4.4.0&quot;, &quot;rollup-plugin-clear&quot;: &quot;^2.0.7&quot;, &quot;rollup-plugin-commonjs&quot;: &quot;^10.1.0&quot;, &quot;rollup-plugin-hash&quot;: &quot;^1.3.0&quot;, &quot;rollup-plugin-node-resolve&quot;: &quot;^5.2.0&quot;, &quot;rollup-plugin-terser&quot;: &quot;^7.0.2&quot;, &quot;rollup-plugin-typescript&quot;: &quot;^1.0.1&quot;, &quot;rollup-plugin-uglify&quot;: &quot;^6.0.4&quot;, &quot;ts-node&quot;: &quot;^9.1.1&quot;, &quot;tslib&quot;: &quot;^2.0.3&quot;, &quot;typescript&quot;: &quot;^4.1.3&quot; }, &quot;types&quot;: &quot;dist/index.d.ts&quot;} npm i 安装依赖进入src/index.ts 编写代码rollup 打包npm run build 发布包到npm首先需要注册npm账号 npm addusernpm loginnpm publish","link":"/2021/01/05/%E5%B7%A5%E7%A8%8B%E5%8C%96/rollup%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"title":"package-lock.json的作用","text":"什么是package-lock.json在前端项目根目录里有一个package-lock.json文件，有同学疑惑这个文件是干嘛用，不是已经有一个package文件了吗？这个文件前身是npm-shrinkwrap.json，因为npm的依赖管理非常宽松，一个项目在同一天内都可能会安装到不同版本的依赖包，依赖包的升级可能会给项目带来bug。 这时shrinkwrap就应运而生，但是大家都懒得写，所以npm在5+版本之后，收到yarn.lock的启发，默认会在安装时生成package-loack文件。 举个例子 总结package-lock是用来严格控制版本依赖的。 package-lock.json 详细解析package-lock.json会为npm修改node_modules树或的任何操作自动生成package.json。它描述了生成的确切树，因此无论中间依赖项更新如何，后续安装都可以生成相同的树。该文件旨在提交到源存储库中，并具有多种用途： 描述依赖关系树的单个表示，这样可以确保队友，部署和持续集成安装完全相同的依赖关系。 为用户提供一种工具，使其可以“时间旅行”到以前的状态，node_modules而不必提交目录本身。 为了通过可读的源代码控制差异更好地了解树的变化。 并允许npm跳过以前安装的软件包的重复元数据解析，从而优化安装过程。 关于package-lock.json它的一个关键细节是它无法发布，并且如果在顶级软件包之外的任何地方找到它，它将被忽略。它与共享格式npm-shrinkwrap.json，该文件本质上是相同的文件，但可以发布。除非部署CLI工具或使用发布过程来生产生产软件包，否则不建议这样做。如果软件包的根目录中同时存在package-lock.json和npm-shrinkwrap.json，package-lock.json将被完全忽略。 文件格式name这是程序包锁定的程序包名称。这必须与中的内容匹配 package.json。 version这是程序包锁定的程序包版本。这必须与中的内容匹配 package.json。 lockfileVersion整数版本，1从此文档的版本号开始，在生成this时使用了其语义package-lock.json。 packageIntegrity这是从中创建的子资源完整性值package.json。package.json不应进行任何预处理。子资源完整性字符串可由类似的模块生成 ssri。 preserveSymlinks表示安装是在NODE_PRESERVE_SYMLINKS启用环境变量的情况下完成的 。安装程序应坚持使该属性的值与该环境变量匹配。 dependencies程序包名称到依赖对象的映射。依赖项对象具有以下属性：version这是一个说明符，可唯一标识此程序包，并应可用于获取其新副本。 捆绑的依赖关系：不管来源如何，这都是一个纯粹用于参考目的的版本号。 注册表源：这是一个版本号。（例如，1.2.3） git源：这是一个具有已解决承诺的git说明符。（例如，git+https://example.com/foo/bar#115311855adb0789a0466714ed48a1499ffea97e） http tarball来源：这是tarball的URL。（例如，[https://example.com/example-1.3.0.tgz](https://example.com/example-1.3.0.tgz)） 本地tarball来源：这是tarball的文件URL。（例如file:///opt/storage/example-1.3.0.tgz） 本地链接源：这是链接的文件URL。（例如file:libs/our-module） integrity这是此资源的标准子资源完整性。 对于捆绑的依赖项，无论来源如何，均不包括在内。 对于注册表源，这是integrity注册表提供的，或者如果未提供SHA1 shasum。 对于git源，这是我们从中克隆的特定提交哈希。 对于远程tarball源，这是基于文件SHA512的完整性。 对于本地tarball源：这是基于文件SHA512的完整性字段。 resolved 对于捆绑的依赖项，无论来源如何，均不包括在内。 对于注册表源，这是相对于注册表URL的压缩包的路径。如果tarball URL与注册表URL不在同一服务器上，则这是完整的URL。 bundled如果为true，则为捆绑的依赖关系，并将由父模块安装。安装时，此模块将在提取阶段从父模块中提取，而不是作为单独的依赖项安装。 dev如果为true，则此依赖项仅是顶层模块的开发依赖项，或者是一个传递性依赖项。对于既是顶层的开发依赖关系又是顶层的非开发依赖关系的传递依赖关系的依赖关系，这是错误的。 optional如果为true，则此依赖项仅是顶层模块的可选依赖项，或者是一个传递性依赖项。对于既是顶层的可选依赖关系又是顶层的非可选依赖关系的传递性依赖关系的依赖关系，则为false。即使所有可选依赖项都可以在当前平台上卸载，也应包括在内。 requires这是模块名称到版本的映射。这是此模块所需的所有内容的列表，无论它将安装在何处。版本应通过正常匹配规则匹配我们dependencies或更高级别的依赖关系 。 dependencies此依赖关系的依赖关系，与顶层完全相同。","link":"/2021/01/05/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E4%BB%80%E4%B9%88package-lock.json%20_/"},{"title":"经典题解-回溯法和动态规划","text":"题目数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的 **括号组合。示例：输入：n = 3输出：[ “((()))”, “(()())”, “(())()”, “()(())”, “()()()” ] 解法 回溯法判断回溯很简单，拿到一个问题，你感觉如果不穷举一下就没法知道答案，那就可以开始回溯了。一般回溯的问题有三种： Find a path to success 有没有解 Find all paths to success 求所有解 求所有解的个数 求所有解的具体信息 Find the best path to success 求最优解 回溯法是一个剪枝了的二叉树。我们要得到的结果是可以 good leaf，如果不满足 good leaf 就继续向下搜索，搜索的时候需要满足一定的条件。从上面的图片中我们可以很明显的看到，最后五条画黑线的就是最终的结果，其中左分支都是添加左括号，右分支都是添加右括号。那么我们在什么情况下添加左括号呢？很明显，最多能添加 n 个左括号，在递归调用的时候，在能传递到最底层的共用字符串中先添加 ”(“ ，然后 left-1，递归调用就可以。那什么时候添加右括号呢？当左括号个数大于右括号的个数时添加右括号。总之，向下搜索要满足两个条件： 插入数量不超过n 可以插入 ） 的前提是 ( 的数量大于 ） 回溯法的代码套路是使用两个变量： res 和 path，res 表示最终的结果，path 保存已经走过的路径。如果搜到一个状态满足题目要求，就把 path 放到 res 中。代码后面的判断条件都是 if，而不是 elif，因为是满足两个条件的任意一个就可以继续向下搜索，而不是同时只能满足其中的一个。 12345678910111213141516171819202122/** * @param {number} n * @return {string[]} */var generateParenthesis = function(n) { // 保存所有有效路径 let res = []; dfs(res, n, n, ''); return res;};function dfs(res, left, right, path) { if (right === 0) { return res.push(path); } if (left &gt; 0) { dfs(res, left - 1, right , path + '('); } if (right &gt; left) { dfs(res, left, right - 1 , path + ')'); }} 动态规划什么是动态规划？在此题中，动态规划的思想类似于数学归纳法，当知道所有 i&lt;n 的情况时，我们可以通过某种算法算出 i=n 的情况。 123dp递推公式：dp[i]=&quot;(&quot;+dp[m]+&quot;)&quot;+dp[k]其中m+k=i-1 本题最核心的思想是，考虑 i=n 时相比 n-1 组括号增加的那一组括号的位置。当我们清楚所有 i&lt;n 时括号的可能生成排列后，对与 i=n 的情况，我们考虑整个括号排列中最左边的括号。它一定是一个左括号，那么它可以和它对应的右括号组成一组完整的括号 “( )”，我们认为这一组是相比 n-1 增加进来的括号。那么，剩下 n-1 组括号有可能在哪呢？剩下的括号要么在这一组新增的括号内部，要么在这一组新增括号的外部（右侧）。既然知道了 i&lt;n 的情况，那我们就可以对所有情况进行遍历：“(“ + 【i=p时所有括号的排列组合】 + “)” + 【i=q时所有括号的排列组合】其中 p + q = n-1，且 p q 均为非负整数。事实上，当上述 p 从 0 取到 n-1，q 从 n-1 取到 0 后，所有情况就遍历完了。注：上述遍历是没有重复情况出现的，即当 (p1,q1)≠(p2,q2) 时，按上述方式取的括号组合一定不同。 123456789101112131415161718192021222324/** * @param {number} n * @return {string[]} */var generateParenthesis = function (n) { const cache = []; cache[0] = [&quot;&quot;]; cache[1] = [&quot;()&quot;]; for (let i = 2; i &lt;= n; i++) { const temp = []; for (let j = 0; j &lt; i; j++) { const list1 = cache[j]; const list2 = cache[i - 1 - j]; for (let k1 of list1) { for (let k2 of list2) { temp.push(&quot;(&quot; + k1 + &quot;)&quot; + k2); } } } cache.push(temp); } return cache[n];}; 原文链接：[https://leetcode-cn.com/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/](https://leetcode-cn.com/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/)原文链接：[https://leetcode-cn.com/problems/generate-parentheses](https://leetcode-cn.com/problems/generate-parentheses)原文链接：[https://leetcode-cn.com/problems/generate-parentheses/solution/ru-men-ji-bie-de-hui-su-fa-xue-hui-tao-lu-miao-don/](https://leetcode-cn.com/problems/generate-parentheses/solution/ru-men-ji-bie-de-hui-su-fa-xue-hui-tao-lu-miao-don/)","link":"/2021/01/05/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E9%A2%98%E8%A7%A3-%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"Git分支合并详解","text":"“合并前文件还在的，合并后就不见了”、“我遇到 Git 合并的 bug 了” 是两句经常听到的话，但真的是 Git 的 bug 么？或许只是你的预期不对。本文通过讲解三向合并和 Git 的合并策略，step by step 介绍 Git 是怎么做一个合并的，让大家对 Git 的合并结果有一个准确的预期，并且避免发生合并事故。 ** 故事时间在开始正文之前，先来听一下这个故事。如下图，小明从节点 A 拉了一条 dev 分支出来，在节点 B 中新增了一个文件 http.js，并且合并到 master 分支，合并节点为 E。这个时候发现会引起线上 bug，赶紧撤回这个合并，新增一个 revert 节点 E’。过了几天小明继续在 dev 分支上面开发新增了一个文件 main.js，并在这个文件中 import 了 http.js 里面的逻辑，在 dev 分支上面一切运行正常。可当他将此时的 dev 分支合并到 master 时候却发现，http.js 文件不见了，导致 main.js 里面的逻辑运行报错了。但这次合并并没有任何冲突。他又得重新做了一下 revert，并且迷茫的怀疑是 Git 的 bug。两句经常听到的话：—— ”合并前文件还在的，合并后就不见了“—— ”我遇到 Git 的 bug 了“相信很多同学或多或少在不熟悉 Git 合并策略的时候都会发生过类似上面的事情，明明在合并前文件还在的，为什么合并后文件就不在了么？一度还怀疑是 Git 的 bug。这篇文章的目的就是想跟大家讲清楚 Git 是怎么去合并分支的，以及一些底层的基础概念，从而避免发生如故事中的问题，并对 Git 的合并结果有一个准确的预期。 ** 如何合并两个文件在看怎么合并两个分支之前，我们先来看一下怎么合并两个文件，因为两个文件的合并是两个分支合并的基础。大家应该都听说过“三向合并”这个词，不知道大家有没有思考过为什么两个文件的合并需要三向合并，只有二向是否可以自动完成合并。如下图很明显答案是不能，如上图的例子，Git 没法确定这一行代码是我修改的，还是对方修改的，或者之前就没有这行代码，是我们俩同时新增的。此时 Git 没办法帮我们做自动合并。所以我们需要三向合并，所谓三向合并，就是找到两个文件的一个合并 base，如下图，这样子 Git 就可以很清楚的知道说，对方修改了这一行代码，而我们没有修改，自动帮我们合并这两个文件为 Print(“hello”)。接下来我们了解一下什么是冲突？冲突简单的来说就是三向合并中的三方都互不相同，即参考合并 base，我们的分支和别人的分支都对同个地方做了修改。 ** Git 的合并策略了解完怎么合并两个文件之后，我们来看一个使用 git merge 来做分支合并。如上图，将 master 分支合并到 feature 分支上，会新增一个 commit 节点来记录这次合并。Git 会有很多合并策略，其中常见的是 Fast-forward、Recursive 、Ours、Theirs、Octopus。下面分别介绍不同合并策略的原理以及应用场景。默认 Git 会帮你自动挑选合适的合并策略，如果你需要强制指定，使用git merge -s &lt;策略名字&gt;了解 Git 合并策略的原理可以让你对 Git 的合并结果有一个准确的预期。#### Fast-forwardFast-forward 是最简单的一种合并策略，如上图中将 some feature 分支合并进 master 分支，Git 只需要将 master 分支的指向移动到最后一个 commit 节点上。Fast-forward 是 Git 在合并两个没有分叉的分支时的默认行为，如果不想要这种表现，想明确记录下每次的合并，可以使用git merge –no-ff。#### RecursiveRecursive 是 Git 分支合并策略中最重要也是最常用的策略，是 Git 在合并两个有分叉的分支时的默认行为。其算法可以简单描述为：递归寻找路径最短的唯一共同祖先节点，然后以其为 base 节点进行递归三向合并。说起来有点绕，下面通过例子来解释。如下图这种简单的情况，圆圈里面的英文字母为当前 commit 的文件内容，当我们要合并中间两个节点的时候，找到他们的共同祖先节点（左边第一个），接着进行三向合并得到结果为 B。（因为合并的 base 是“A”，下图靠下的分支没有修改内容仍为“A”，下图靠上的分支修改成了“B”，所以合并结果为“B”）。但现实情况总是复杂得多，会出现历史记录链互相交叉等情况，如下图：当 Git 在寻找路径最短的共同祖先节点的时候，可以找到两个节点的，如果 Git 选用下图这一个节点，那么 Git 将无法自动的合并。因为根据三向合并，这里是是有冲突的，需要手动解决。（base 为“A“，合并的两个分支内容为”C“和”B“）而如果 Git 选用的是下图这个节点作为合并的 base 时，根据三向合并，Git 就可以直接自动合并得出结果“C”。（base 为“B“，合并的两个分支内容为”C“和”B“）作为人类，在这个例子里面我们很自然的就可以看出来合并的结果应该是“C”（如下图，节点 4、5 都已经是“B”了，节点 6 修改成“C”，所以合并的预期为“C”）那怎么保证 Git 能够找到正确的合并 base 节点，尽可能的减少冲突呢？答案就是，Git 在寻找路径最短的共同祖先节点时，如果满足条件的祖先节点不唯一，那么 Git 会继续递归往下寻找直至唯一。还是以刚刚这个例子图解。如下图所示，我们想要合并节点 5 和节点 6，Git 找到路径最短的祖先节点 2 和 3。因为共同祖先节点不唯一，所以 Git 递归以节点 2 和节点 3 为我们要合并的节点，寻找他们的路径最短的共同祖先，找到唯一的节点 1。接着 Git 以节点 1 为 base，对节点 2 和节点 3 做三向合并，得到一个临时节点，根据三向合并的结果，这个节点的内容为“B”。再以这个临时节点为 base，对节点 5 和节点 6 做三向合并，得到合并节点 7，根据三向合并的结果，节点 7 的内容为“C”至此 Git 完成递归合并，自动合并节点 5 和节点 6，结果为“C”，没有冲突。Recursive 策略已经被大量的场景证明它是一个尽量减少冲突的合并策略，我们可以看到有趣的一点是，对于两个合并分支的中间节点（如上图节点 4，5），只参与了 base 的计算，而最终真正被三向合并拿来做合并的节点，只包括末端以及 base 节点。需要注意 Git 只是使用这些策略尽量的去帮你减少冲突，如果冲突不可避免，那 Git 就会提示冲突，需要手工解决。（也就是真正意义上的冲突）。#### Ours &amp; TheirsOurs 和 Theirs 这两种合并策略也是比较简单的，简单来说就是保留双方的历史记录，但完全忽略掉这一方的文件变更。如下图在 master 分支里面执行git merge -s ours dev，会产生蓝色的这一个合并节点，其内容跟其上一个节点（master 分支方向上的）完全一样，即 master 分支合并前后项目文件没有任何变动。而如果使用 theirs 则完全相反，完全抛弃掉当前分支的文件内容，直接采用对方分支的文件内容。这两种策略的一个使用场景是比如现在要实现同一功能，你同时尝试了两个方案，分别在分支是 dev1 和 dev2 上，最后经过测试你选用了 dev2 这个方案。但你不想丢弃 dev1 的这样一个尝试，希望把它合入主干方便后期查看，这个时候你就可以在 dev2 分支中执行git merge -s ours dev1。 Octopus这种合并策略比较神奇，一般来说我们的合并节点都只有两个 parent（即合并两条分支），而这种合并策略可以做两个以上分支的合并，这也是 git merge 两个以上分支时的默认行为。比如在 dev1 分支上执行git merge dev2 dev3。他的一个使用场景是在测试环境或预发布环境，你需要将多个开发分支修改的内容合并在一起，如果不用这个策略，你每次只能合并一个分支，这样就会导致大量的合并节点产生。而使用 Octopus 这种合并策略就可以用一个合并节点将他们全部合并进来。 ** Git rebasegit rebase 也是一种经常被用来做合并的方法，其与 git merge 的最大区别是，他会更改变更历史对应的 commit 节点。如下图，当在 feature 分支中执行 rebase master 时，Git 会以 master 分支对应的 commit 节点为起点，新增两个全新的 commit 代替 feature 分支中的 commit 节点。其原因是新的 commit 指向的 parent 变了，所以对应的 SHA1 值也会改变，所以没办法复用原 feature 分支中的 commit。（这句话的理解需要这篇文章的基础知识）对于合并时候要使用 git merge 还是 git rebase 的争论，我个人的看法是没有银弹，根据团队和项目习惯选择就可以。git rebase 可以给我们带来清晰的历史记录，git merge 可以保留真实的提交时间等信息，并且不容易出问题，处理冲突也比较方便。唯一有一点需要注意的是，不要对已经处于远端的多人共用分支做 rebase 操作。我个人的一个习惯是：对于本地的分支或者确定只有一个人使用的远端分支用 rebase，其余情况用 merge。rebase 还有一个非常好用的东西叫 interactive 模式，使用方法是git rebase -i。可以实现压缩几个 commit，修改 commit 信息，抛弃某个 commit 等功能。比如说我要压缩下图 260a12a5、956e1d18，将他们与 9dae0027 合并为一个 commit，我只需将 260a12a5、956e1d18 前面的 pick 改成“s”，然后保存就可以了。限于篇幅，git rebase -i 还有很多实用的功能暂不展开，感兴趣的同学可以自己研究一下。 ** 总结现在我们再来看一下文章开头的例子，我们就可以理解为什么最后一次 merge 会导致 http.js 文件不见了。根据 Git 的合并策略，在合并两个有分叉的分支（上图中的 D、E‘）时，Git 默认会选择 Recursive 策略。找到 D 和 E’的最短路径共同祖先节点 B，以 B 为 base，对 D，E‘做三向合并。B 中有 http.js，D 中有 http.js 和 main.js，E’中什么都没有。根据三向合并，B、D 中都有 http.js 且没有变更，E‘删除了 http.js，所以合并结果就是没有 http.js，没有冲突，所以 http.js 文件不见了。这个例子理解原理之后解决方法有很多，这里简单带过两个方法：1. revert 节点 E’之后，此时的 dev 分支要抛弃删除掉，重新从 E’节点拉出分支继续工作，而不是在原 dev 分支上继续开发节点 D；2. 在节点 D 合并回 E’节点时，先 revert 一下 E‘节点生成 E’‘（即 revert 的 revert），再将节点 D 合并进来。Git 有很多种分支合并策略，本文介绍了 Fast-forward、Recursive、Ours/Theirs、Octopus 合并策略以及三向合并。掌握这些合并策略以及他们的使用场景可以让你避免发生一些合并问题，并对合并结果有一个准确的预期。希望这篇文章对大家有用，感兴趣的同学可以逛一逛我的博客www.lzane.com 或看看我的其他文章。参考 三向合并 http://blog.plasticscm.com/2016/02/three-way-merging-look-under-hood.html Recursive 合并【视频】https://www.youtube.com/watch?v=Lg1igaCtAck 书籍 Scott Chacon, Ben Straub - Pro Git-Apress (2014) 书籍 Jon Loeliger, Matthew McCullough - Version Control with Git, 2nd Edition - O’Reilly Media (2012) 原文 https://www.jiqizhixin.com/articles/2020-05-28-8","link":"/2021/01/05/Git/Git%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E8%AF%A6%E8%A7%A3/"},{"title":"一篇文章让你彻底掌握 Shell","text":"由于 bash 是 Linux 标准默认的 shell 解释器，可以说 bash 是 shell 编程的基础。 本文主要介绍 bash 的语法，对于 linux 指令不做任何介绍。 📦 本文已归档到：『blog』💻 本文的源码已归档到『 linux-tutorial』 12345███████╗██╗ ██╗███████╗██╗ ██╗██╔════╝██║ ██║██╔════╝██║ ██║███████╗███████║█████╗ ██║ ██║╚════██║██╔══██║██╔══╝ ██║ ██║███████║██║ ██║███████╗███████╗███████╗ 简介什么是 shell Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。 Shell 既是一种命令语言，又是一种程序设计语言。 Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问 Linux 内核的服务。 Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。 什么是 shell 脚本Shell 脚本（shell script），是一种为 shell 编写的脚本程序，一般文件后缀为 .sh。 业界所说的 shell 通常都是指 shell 脚本，但 shell 和 shell script 是两个不同的概念。 Shell 环境Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 Shell 的解释器种类众多，常见的有： sh - 即 Bourne Shell。sh 是 Unix 标准默认的 shell。 bash - 即 Bourne Again Shell。bash 是 Linux 标准默认的 shell。 fish - 智能和用户友好的命令行 shell。 xiki - 使 shell 控制台更友好，更强大。 zsh - 功能强大的 shell 与脚本语言。 指定脚本解释器在 shell 脚本，#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。#! 被称作shebang（也称为 Hashbang ）。 所以，你应该会在 shell 中，见到诸如以下的注释： 指定 sh 解释器 1#!/bin/sh 指定 bash 解释器 1#!/bin/bash 注意 上面的指定解释器的方式是比较常见的，但有时候，你可能也会看到下面的方式： 1#!/usr/bin/env bash 这样做的好处是，系统会自动在 PATH 环境变量中查找你指定的程序（本例中的bash）。相比第一种写法，你应该尽量用这种写法，因为程序的路径是不确定的。这样写还有一个好处，操作系统的PATH变量有可能被配置为指向程序的另一个版本。比如，安装完新版本的bash，我们可能将其路径添加到PATH中，来“隐藏”老版本。如果直接用#!/bin/bash，那么系统会选择老版本的bash来执行脚本，如果用#!/usr/bin/env bash，则会使用新版本。 模式shell 有交互和非交互两种模式。 交互模式 简单来说，你可以将 shell 的交互模式理解为执行命令行。 看到形如下面的东西，说明 shell 处于交互模式下： 1user@host:~$ 接着，便可以输入一系列 Linux 命令，比如 ls，grep，cd，mkdir，rm 等等。 非交互模式 简单来说，你可以将 shell 的非交互模式理解为执行 shell 脚本。 在非交互模式下，shell 从文件或者管道中读取命令并执行。 当 shell 解释器执行完文件中的最后一个命令，shell 进程终止，并回到父进程。 可以使用下面的命令让 shell 以非交互模式运行： 1234sh /path/to/script.shbash /path/to/script.shsource /path/to/script.sh./path/to/script.sh 上面的例子中，script.sh是一个包含 shell 解释器可以识别并执行的命令的普通文本文件，sh和bash是 shell 解释器程序。你可以使用任何喜欢的编辑器创建script.sh（vim，nano，Sublime Text, Atom 等等）。 其中，source /path/to/script.sh 和 ./path/to/script.sh 是等价的。 除此之外，你还可以通过chmod命令给文件添加可执行的权限，来直接执行脚本文件： 12chmod +x /path/to/script.sh #使脚本具有执行权限/path/to/test.sh 这种方式要求脚本文件的第一行必须指明运行该脚本的程序，比如： 💻 『示例源码』 12#!/usr/bin/env bashecho &quot;Hello, world!&quot; 上面的例子中，我们使用了一个很有用的命令echo来输出字符串到屏幕上。 基本语法解释器前面虽然两次提到了#! ，但是本着重要的事情说三遍的精神，这里再强调一遍： 在 shell 脚本，#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。#! 被称作shebang（也称为 Hashbang ）。 #! 决定了脚本可以像一个独立的可执行文件一样执行，而不用在终端之前输入sh, bash, python, php等。 123# 以下两种方式都可以指定 shell 解释器为 bash，第二种方式更好#!/bin/bash#!/usr/bin/env bash 注释注释可以说明你的代码是什么作用，以及为什么这样写。 shell 语法中，注释是特殊的语句，会被 shell 解释器忽略。 单行注释 - 以 # 开头，到行尾结束。 多行注释 - 以 :&lt;&lt;EOF 开头，到 EOF 结束。 💻 『示例源码』 1234567891011121314#--------------------------------------------# shell 注释示例# author：zp#--------------------------------------------# echo '这是单行注释'########## 这是分割线 ##########:&lt;&lt;EOFecho '这是多行注释'echo '这是多行注释'echo '这是多行注释'EOF echoecho 用于字符串的输出。 输出普通字符串： 12echo &quot;hello, world&quot;# Output: hello, world 输出含变量的字符串： 12echo &quot;hello, \\&quot;zp\\&quot;&quot;# Output: hello, &quot;zp&quot; 输出含变量的字符串： 123name=zpecho &quot;hello, \\&quot;${name}\\&quot;&quot;# Output: hello, &quot;zp&quot; 输出含换行符的字符串： 12345678# 输出含换行符的字符串echo &quot;YES\\nNO&quot;# Output: YES\\nNOecho -e &quot;YES\\nNO&quot; # -e 开启转义# Output:# YES# NO 输出含不换行符的字符串： 12345678910echo &quot;YES&quot;echo &quot;NO&quot;# Output:# YES# NOecho -e &quot;YES\\c&quot; # -e 开启转义 \\c 不换行echo &quot;NO&quot;# Output:# YESNO 输出重定向至文件 1echo &quot;test&quot; &gt; test.txt 输出执行结果 12echo `pwd`# Output:(当前目录路径) 💻 『示例源码』 123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env bash# 输出普通字符串echo &quot;hello, world&quot;# Output: hello, world# 输出含变量的字符串echo &quot;hello, \\&quot;zp\\&quot;&quot;# Output: hello, &quot;zp&quot;# 输出含变量的字符串name=zpecho &quot;hello, \\&quot;${name}\\&quot;&quot;# Output: hello, &quot;zp&quot;# 输出含换行符的字符串echo &quot;YES\\nNO&quot;# Output: YES\\nNOecho -e &quot;YES\\nNO&quot; # -e 开启转义# Output:# YES# NO# 输出含不换行符的字符串echo &quot;YES&quot;echo &quot;NO&quot;# Output:# YES# NOecho -e &quot;YES\\c&quot; # -e 开启转义 \\c 不换行echo &quot;NO&quot;# Output:# YESNO# 输出内容定向至文件echo &quot;test&quot; &gt; test.txt# 输出执行结果echo `pwd`# Output:(当前目录路径) printfprintf 用于格式化输出字符串。 默认，printf 不会像 echo 一样自动添加换行符，如果需要换行可以手动添加 \\n。 💻 『示例源码』 12345678910111213141516171819202122232425262728293031323334353637383940# 单引号printf '%d %s\\n' 1 &quot;abc&quot;# Output:1 abc# 双引号printf &quot;%d %s\\n&quot; 1 &quot;abc&quot;# Output:1 abc# 无引号printf %s abcdef# Output: abcdef(并不会换行)# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出printf &quot;%s\\n&quot; abc def# Output:# abc# defprintf &quot;%s %s %s\\n&quot; a b c d e f g h i j# Output:# a b c# d e f# g h i# j# 如果没有参数，那么 %s 用 NULL 代替，%d 用 0 代替printf &quot;%s and %d \\n&quot;# Output:# and 0# 格式化输出printf &quot;%-10s %-8s %-4s\\n&quot; 姓名 性别 体重kgprintf &quot;%-10s %-8s %-4.2f\\n&quot; 郭靖 男 66.1234printf &quot;%-10s %-8s %-4.2f\\n&quot; 杨过 男 48.6543printf &quot;%-10s %-8s %-4.2f\\n&quot; 郭芙 女 47.9876# Output:# 姓名 性别 体重kg# 郭靖 男 66.12# 杨过 男 48.65# 郭芙 女 47.99 printf 的转义符 序列 说明 \\a 警告字符，通常为 ASCII 的 BEL 字符 \\b 后退 \\c 抑制（不显示）输出结果中任何结尾的换行字符（只在%b 格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略 \\f 换页（formfeed） \\n 换行 \\r 回车（Carriage return） \\t 水平制表符 \\v 垂直制表符 \\\\ 一个字面上的反斜杠字符 \\ddd 表示 1 到 3 位数八进制值的字符。仅在格式字符串中有效 \\0ddd 表示 1 到 3 位的八进制值字符 变量跟许多程序设计语言一样，你可以在 bash 中创建变量。 Bash 中没有数据类型，bash 中的变量可以保存一个数字、一个字符、一个字符串等等。同时无需提前声明变量，给变量赋值会直接创建变量。 变量命名原则 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用 bash 里的关键字（可用 help 命令查看保留关键字）。 声明变量访问变量的语法形式为：${var} 和 $var 。 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，所以推荐加花括号。 123word=&quot;hello&quot;echo ${word}# Output: hello 只读变量使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 1234rword=&quot;hello&quot;echo ${rword}readonly rword# rword=&quot;bye&quot; # 如果放开注释，执行时会报错 删除变量使用 unset 命令可以删除变量。变量被删除后不能再次使用。unset 命令不能删除只读变量。 1234567dword=&quot;hello&quot; # 声明变量echo ${dword} # 输出变量值# Output: hellounset dword # 删除变量echo ${dword}# Output: （空） 变量类型 局部变量 - 局部变量是仅在某个脚本内部有效的变量。它们不能被其他的程序和脚本访问。 环境变量 - 环境变量是对当前 shell 会话内所有的程序或脚本都可见的变量。创建它们跟创建局部变量类似，但使用的是 export 关键字，shell 脚本也可以定义环境变量。 常见的环境变量： 变量 描述 $HOME 当前用户的用户目录 $PATH 用分号分隔的目录列表，shell 会到这些目录中查找命令 $PWD 当前工作目录 $RANDOM 0 到 32767 之间的整数 $UID 数值类型，当前用户的用户 ID $PS1 主要系统输入提示符 $PS2 次要系统输入提示符 这里 有一张更全面的 Bash 环境变量列表。 💻 『示例源码』 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/env bash################### 声明变量 ###################name=&quot;world&quot;echo &quot;hello ${name}&quot;# Output: hello world################### 输出变量 ###################folder=$(pwd)echo &quot;current path: ${folder}&quot;################### 只读变量 ###################rword=&quot;hello&quot;echo ${rword}# Output: helloreadonly rword# rword=&quot;bye&quot; # 如果放开注释，执行时会报错################### 删除变量 ###################dword=&quot;hello&quot; # 声明变量echo ${dword} # 输出变量值# Output: hellounset dword # 删除变量echo ${dword}# Output: （空）################### 系统变量 ###################echo &quot;UID:$UID&quot;echo LOGNAME:$LOGNAMEecho User:$USERecho HOME:$HOMEecho PATH:$PATHecho HOSTNAME:$HOSTNAMEecho SHELL:$SHELLecho LANG:$LANG################### 自定义变量 ###################days=10user=&quot;admin&quot;echo &quot;$user logged in $days days age&quot;days=5user=&quot;root&quot;echo &quot;$user logged in $days days age&quot;# Output:# admin logged in 10 days age# root logged in 5 days age################### 从变量读取列表 ###################colors=&quot;Red Yellow Blue&quot;colors=$colors&quot; White Black&quot;for color in $colorsdo echo &quot; $color&quot;done 字符串单引号和双引号shell 字符串可以用单引号 ''，也可以用双引号 “”，也可以不用引号。 单引号的特点 单引号里不识别变量 单引号里不能出现单独的单引号（使用转义符也不行），但可成对出现，作为字符串拼接使用。 双引号的特点 双引号里识别变量 双引号里可以出现转义字符 综上，推荐使用双引号。 拼接字符串123456789101112131415# 使用单引号拼接name1='white'str1='hello, '${name1}''str2='hello, ${name1}'echo ${str1}_${str2}# Output:# hello, white_hello, ${name1}# 使用双引号拼接name2=&quot;black&quot;str3=&quot;hello, &quot;${name2}&quot;&quot;str4=&quot;hello, ${name2}&quot;echo ${str3}_${str4}# Output:# hello, black_hello, black 获取字符串长度1234text=&quot;12345&quot;echo ${#text}# Output:# 5 截取子字符串1234text=&quot;12345&quot;echo ${text:2:2}# Output:# 34 从第 3 个字符开始，截取 2 个字符 查找子字符串12345678#!/usr/bin/env bashtext=&quot;hello&quot;echo `expr index &quot;${text}&quot; ll`# Execute: ./str-demo5.sh# Output:# 3 查找 ll 子字符在 hello 字符串中的起始位置。 💻 『示例源码』 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#!/usr/bin/env bash################### 使用单引号拼接字符串 ###################name1='white'str1='hello, '${name1}''str2='hello, ${name1}'echo ${str1}_${str2}# Output:# hello, white_hello, ${name1}################### 使用双引号拼接字符串 ###################name2=&quot;black&quot;str3=&quot;hello, &quot;${name2}&quot;&quot;str4=&quot;hello, ${name2}&quot;echo ${str3}_${str4}# Output:# hello, black_hello, black################### 获取字符串长度 ###################text=&quot;12345&quot;echo &quot;${text} length is: ${#text}&quot;# Output:# 12345 length is: 5# 获取子字符串text=&quot;12345&quot;echo ${text:2:2}# Output:# 34################### 查找子字符串 ###################text=&quot;hello&quot;echo `expr index &quot;${text}&quot; ll`# Output:# 3################### 判断字符串中是否包含子字符串 ###################result=$(echo &quot;${str}&quot; | grep &quot;feature/&quot;)if [[ &quot;$result&quot; != &quot;&quot; ]]; then echo &quot;feature/ 是 ${str} 的子字符串&quot;else echo &quot;feature/ 不是 ${str} 的子字符串&quot;fi################### 截取关键字左边内容 ###################full_branch=&quot;feature/1.0.0&quot;branch=`echo ${full_branch#feature/}`echo &quot;branch is ${branch}&quot;################### 截取关键字右边内容 ###################full_version=&quot;0.0.1-SNAPSHOT&quot;version=`echo ${full_version%-SNAPSHOT}`echo &quot;version is ${version}&quot;################### 字符串分割成数组 ###################str=&quot;0.0.0.1&quot;OLD_IFS=&quot;$IFS&quot;IFS=&quot;.&quot;array=( ${str} )IFS=&quot;$OLD_IFS&quot;size=${#array[*]}lastIndex=`expr ${size} - 1`echo &quot;数组长度：${size}&quot;echo &quot;最后一个数组元素：${array[${lastIndex}]}&quot;for item in ${array[@]}do echo &quot;$item&quot;done################### 判断字符串是否为空 ####################-n 判断长度是否非零#-z 判断长度是否为零str=testingstr2=''if [[ -n &quot;$str&quot; ]]then echo &quot;The string $str is not empty&quot;else echo &quot;The string $str is empty&quot;fiif [[ -n &quot;$str2&quot; ]]then echo &quot;The string $str2 is not empty&quot;else echo &quot;The string $str2 is empty&quot;fi# Output:# The string testing is not empty# The string is empty################### 字符串比较 ###################str=hellostr2=worldif [[ $str = &quot;hello&quot; ]]; then echo &quot;str equals hello&quot;else echo &quot;str not equals hello&quot;fiif [[ $str2 = &quot;hello&quot; ]]; then echo &quot;str2 equals hello&quot;else echo &quot;str2 not equals hello&quot;fi 数组bash 只支持一维数组。 数组下标从 0 开始，下标可以是整数或算术表达式，其值应大于或等于 0。 创建数组123# 创建数组的不同方式nums=([2]=2 [0]=0 [1]=1)colors=(red yellow &quot;dark blue&quot;) 访问数组元素 访问数组的单个元素： 12echo ${nums[1]}# Output: 1 访问数组的所有元素： 12345echo ${colors[*]}# Output: red yellow dark blueecho ${colors[@]}# Output: red yellow dark blue 上面两行有很重要（也很微妙）的区别： 为了将数组中每个元素单独一行输出，我们用 printf 命令： 123456printf &quot;+ %s\\n&quot; ${colors[*]}# Output:# + red# + yellow# + dark# + blue 为什么dark和blue各占了一行？尝试用引号包起来： 123printf &quot;+ %s\\n&quot; &quot;${colors[*]}&quot;# Output:# + red yellow dark blue 现在所有的元素都在一行输出 —— 这不是我们想要的！让我们试试${colors[@]} 12345printf &quot;+ %s\\n&quot; &quot;${colors[@]}&quot;# Output:# + red# + yellow# + dark blue 在引号内，${colors[@]}将数组中的每个元素扩展为一个单独的参数；数组元素中的空格得以保留。 访问数组的部分元素： 123echo ${nums[@]:0:2}# Output:# 0 1 在上面的例子中，${array[@]} 扩展为整个数组，:0:2取出了数组中从 0 开始，长度为 2 的元素。 访问数组长度123echo ${#nums[*]}# Output:# 3 向数组中添加元素向数组中添加元素也非常简单： 1234colors=(white &quot;${colors[@]}&quot; green black)echo ${colors[@]}# Output:# white red yellow dark blue green black 上面的例子中，${colors[@]} 扩展为整个数组，并被置换到复合赋值语句中，接着，对数组colors的赋值覆盖了它原来的值。 从数组中删除元素用unset命令来从数组中删除一个元素： 1234unset nums[0]echo ${nums[@]}# Output:# 1 2 💻 『示例源码』 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/env bash################### 创建数组 ###################nums=( [ 2 ] = 2 [ 0 ] = 0 [ 1 ] = 1 )colors=( red yellow &quot;dark blue&quot; )################### 访问数组的单个元素 ###################echo ${nums[1]}# Output: 1################### 访问数组的所有元素 ###################echo ${colors[*]}# Output: red yellow dark blueecho ${colors[@]}# Output: red yellow dark blueprintf &quot;+ %s\\n&quot; ${colors[*]}# Output:# + red# + yellow# + dark# + blueprintf &quot;+ %s\\n&quot; &quot;${colors[*]}&quot;# Output:# + red yellow dark blueprintf &quot;+ %s\\n&quot; &quot;${colors[@]}&quot;# Output:# + red# + yellow# + dark blue################### 访问数组的部分元素 ###################echo ${nums[@]:0:2}# Output:# 0 1################### 获取数组长度 ###################echo ${#nums[*]}# Output:# 3################### 向数组中添加元素 ###################colors=( white &quot;${colors[@]}&quot; green black )echo ${colors[@]}# Output:# white red yellow dark blue green black################### 从数组中删除元素 ###################unset nums[ 0 ]echo ${nums[@]}# Output:# 1 2 运算符算术运算符下表列出了常用的算术运算符，假定变量 x 为 10，变量 y 为 20： 运算符 说明 举例 + 加法 expr $x + $y 结果为 30。 - 减法 expr $x - $y 结果为 -10。 * 乘法 expr $x * $y 结果为 200。 / 除法 expr $y / $x 结果为 2。 % 取余 expr $y % $x 结果为 0。 = 赋值 x=$y 将把变量 y 的值赋给 x。 == 相等。用于比较两个数字，相同则返回 true。 [ $x == $y ] 返回 false。 != 不相等。用于比较两个数字，不相同则返回 true。 [ $x != $y ] 返回 true。 注意：条件表达式要放在方括号之间，并且要有空格，例如: [$x==$y] 是错误的，必须写成 [ $x == $y ]。 💻 『示例源码』 12345678910111213141516171819202122232425262728293031323334353637x=10y=20echo &quot;x=${x}, y=${y}&quot;val=`expr ${x} + ${y}`echo &quot;${x} + ${y} = $val&quot;val=`expr ${x} - ${y}`echo &quot;${x} - ${y} = $val&quot;val=`expr ${x} \\* ${y}`echo &quot;${x} * ${y} = $val&quot;val=`expr ${y} / ${x}`echo &quot;${y} / ${x} = $val&quot;val=`expr ${y} % ${x}`echo &quot;${y} % ${x} = $val&quot;if [[ ${x} == ${y} ]]then echo &quot;${x} = ${y}&quot;fiif [[ ${x} != ${y} ]]then echo &quot;${x} != ${y}&quot;fi# Output:# x=10, y=20# 10 + 20 = 30# 10 - 20 = -10# 10 * 20 = 200# 20 / 10 = 2# 20 % 10 = 0# 10 != 20 关系运算符关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 下表列出了常用的关系运算符，假定变量 x 为 10，变量 y 为 20： 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ]返回 false。 -ne 检测两个数是否相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ]返回 true。 💻 『示例源码』 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849x=10y=20echo &quot;x=${x}, y=${y}&quot;if [[ ${x} -eq ${y} ]]; then echo &quot;${x} -eq ${y} : x 等于 y&quot;else echo &quot;${x} -eq ${y}: x 不等于 y&quot;fiif [[ ${x} -ne ${y} ]]; then echo &quot;${x} -ne ${y}: x 不等于 y&quot;else echo &quot;${x} -ne ${y}: x 等于 y&quot;fiif [[ ${x} -gt ${y} ]]; then echo &quot;${x} -gt ${y}: x 大于 y&quot;else echo &quot;${x} -gt ${y}: x 不大于 y&quot;fiif [[ ${x} -lt ${y} ]]; then echo &quot;${x} -lt ${y}: x 小于 y&quot;else echo &quot;${x} -lt ${y}: x 不小于 y&quot;fiif [[ ${x} -ge ${y} ]]; then echo &quot;${x} -ge ${y}: x 大于或等于 y&quot;else echo &quot;${x} -ge ${y}: x 小于 y&quot;fiif [[ ${x} -le ${y} ]]; then echo &quot;${x} -le ${y}: x 小于或等于 y&quot;else echo &quot;${x} -le ${y}: x 大于 y&quot;fi# Output:# x=10, y=20# 10 -eq 20: x 不等于 y# 10 -ne 20: x 不等于 y# 10 -gt 20: x 不大于 y# 10 -lt 20: x 小于 y# 10 -ge 20: x 小于 y# 10 -le 20: x 小于或等于 y 布尔运算符下表列出了常用的布尔运算符，假定变量 x 为 10，变量 y 为 20： 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 💻 『示例源码』 1234567891011121314151617181920212223242526272829303132333435x=10y=20echo &quot;x=${x}, y=${y}&quot;if [[ ${x} != ${y} ]]; then echo &quot;${x} != ${y} : x 不等于 y&quot;else echo &quot;${x} != ${y}: x 等于 y&quot;fiif [[ ${x} -lt 100 &amp;&amp; ${y} -gt 15 ]]; then echo &quot;${x} 小于 100 且 ${y} 大于 15 : 返回 true&quot;else echo &quot;${x} 小于 100 且 ${y} 大于 15 : 返回 false&quot;fiif [[ ${x} -lt 100 || ${y} -gt 100 ]]; then echo &quot;${x} 小于 100 或 ${y} 大于 100 : 返回 true&quot;else echo &quot;${x} 小于 100 或 ${y} 大于 100 : 返回 false&quot;fiif [[ ${x} -lt 5 || ${y} -gt 100 ]]; then echo &quot;${x} 小于 5 或 ${y} 大于 100 : 返回 true&quot;else echo &quot;${x} 小于 5 或 ${y} 大于 100 : 返回 false&quot;fi# Output:# x=10, y=20# 10 != 20 : x 不等于 y# 10 小于 100 且 20 大于 15 : 返回 true# 10 小于 100 或 20 大于 100 : 返回 true# 10 小于 5 或 20 大于 100 : 返回 false 逻辑运算符以下介绍 Shell 的逻辑运算符，假定变量 x 为 10，变量 y 为 20: 运算符 说明 举例 &amp;&amp; 逻辑的 AND [[ ${x} -lt 100 &amp;&amp; ${y} -gt 100 ]] 返回 false ` ` 💻 『示例源码』 1234567891011121314151617181920212223x=10y=20echo &quot;x=${x}, y=${y}&quot;if [[ ${x} -lt 100 &amp;&amp; ${y} -gt 100 ]]then echo &quot;${x} -lt 100 &amp;&amp; ${y} -gt 100 返回 true&quot;else echo &quot;${x} -lt 100 &amp;&amp; ${y} -gt 100 返回 false&quot;fiif [[ ${x} -lt 100 || ${y} -gt 100 ]]then echo &quot;${x} -lt 100 || ${y} -gt 100 返回 true&quot;else echo &quot;${x} -lt 100 || ${y} -gt 100 返回 false&quot;fi# Output:# x=10, y=20# 10 -lt 100 &amp;&amp; 20 -gt 100 返回 false# 10 -lt 100 || 20 -gt 100 返回 true 字符串运算符下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”： 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为 0，为 0 返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为 0，不为 0 返回 true。 [ -n $a ] 返回 true。 str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 💻 『示例源码』 12345678910111213141516171819202122232425262728293031323334353637383940414243x=&quot;abc&quot;y=&quot;xyz&quot;echo &quot;x=${x}, y=${y}&quot;if [[ ${x} = ${y} ]]; then echo &quot;${x} = ${y} : x 等于 y&quot;else echo &quot;${x} = ${y}: x 不等于 y&quot;fiif [[ ${x} != ${y} ]]; then echo &quot;${x} != ${y} : x 不等于 y&quot;else echo &quot;${x} != ${y}: x 等于 y&quot;fiif [[ -z ${x} ]]; then echo &quot;-z ${x} : 字符串长度为 0&quot;else echo &quot;-z ${x} : 字符串长度不为 0&quot;fiif [[ -n &quot;${x}&quot; ]]; then echo &quot;-n ${x} : 字符串长度不为 0&quot;else echo &quot;-n ${x} : 字符串长度为 0&quot;fiif [[ ${x} ]]; then echo &quot;${x} : 字符串不为空&quot;else echo &quot;${x} : 字符串为空&quot;fi# Output:# x=abc, y=xyz# abc = xyz: x 不等于 y# abc != xyz : x 不等于 y# -z abc : 字符串长度不为 0# -n abc : 字符串长度不为 0# abc : 字符串不为空 文件测试运算符文件测试运算符用于检测 Unix 文件的各种属性。 属性检测描述如下： 操作符 说明 举例 -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。 -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ]返回 false。 -p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。 -s file 检测文件是否为空（文件大小是否大于 0），不为空返回 true。 [ -s $file ] 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 💻 『示例源码』 12345678910111213141516171819202122232425262728293031323334353637383940414243444546file=&quot;/etc/hosts&quot;if [[ -r ${file} ]]; then echo &quot;${file} 文件可读&quot;else echo &quot;${file} 文件不可读&quot;fiif [[ -w ${file} ]]; then echo &quot;${file} 文件可写&quot;else echo &quot;${file} 文件不可写&quot;fiif [[ -x ${file} ]]; then echo &quot;${file} 文件可执行&quot;else echo &quot;${file} 文件不可执行&quot;fiif [[ -f ${file} ]]; then echo &quot;${file} 文件为普通文件&quot;else echo &quot;${file} 文件为特殊文件&quot;fiif [[ -d ${file} ]]; then echo &quot;${file} 文件是个目录&quot;else echo &quot;${file} 文件不是个目录&quot;fiif [[ -s ${file} ]]; then echo &quot;${file} 文件不为空&quot;else echo &quot;${file} 文件为空&quot;fiif [[ -e ${file} ]]; then echo &quot;${file} 文件存在&quot;else echo &quot;${file} 文件不存在&quot;fi# Output:(根据文件的实际情况，输出结果可能不同)# /etc/hosts 文件可读# /etc/hosts 文件可写# /etc/hosts 文件不可执行# /etc/hosts 文件为普通文件# /etc/hosts 文件不是个目录# /etc/hosts 文件不为空# /etc/hosts 文件存在 控制语句条件语句跟其它程序设计语言一样，Bash 中的条件语句让我们可以决定一个操作是否被执行。结果取决于一个包在[[ ]]里的表达式。 由[[ ]]（sh中是[ ]）包起来的表达式被称作 检测命令 或 基元。这些表达式帮助我们检测一个条件的结果。这里可以找到有关bash 中单双中括号区别的答案。 共有两个不同的条件表达式：if和case。 if（1）if 语句 if在使用上跟其它语言相同。如果中括号里的表达式为真，那么then和fi之间的代码会被执行。fi标志着条件代码块的结束。 12345678910# 写成一行if [[ 1 -eq 1 ]]; then echo &quot;1 -eq 1 result is: true&quot;; fi# Output: 1 -eq 1 result is: true# 写成多行if [[ &quot;abc&quot; -eq &quot;abc&quot; ]]then echo &quot;&quot;abc&quot; -eq &quot;abc&quot; result is: true&quot;fi# Output: abc -eq abc result is: true （2）if else 语句 同样，我们可以使用if..else语句，例如： 123456if [[ 2 -ne 1 ]]; then echo &quot;true&quot;else echo &quot;false&quot;fi# Output: true （3）if elif else 语句 有些时候，if..else不能满足我们的要求。别忘了if..elif..else，使用起来也很方便。 💻 『示例源码』 12345678910x=10y=20if [[ ${x} &gt; ${y} ]]; then echo &quot;${x} &gt; ${y}&quot;elif [[ ${x} &lt; ${y} ]]; then echo &quot;${x} &lt; ${y}&quot;else echo &quot;${x} = ${y}&quot;fi# Output: 10 &lt; 20 case如果你需要面对很多情况，分别要采取不同的措施，那么使用case会比嵌套的if更有用。使用case来解决复杂的条件判断，看起来像下面这样： 💻 『示例源码』 12345678910111213141516171819202122execcase ${oper} in &quot;+&quot;) val=`expr ${x} + ${y}` echo &quot;${x} + ${y} = ${val}&quot; ;; &quot;-&quot;) val=`expr ${x} - ${y}` echo &quot;${x} - ${y} = ${val}&quot; ;; &quot;*&quot;) val=`expr ${x} \\* ${y}` echo &quot;${x} * ${y} = ${val}&quot; ;; &quot;/&quot;) val=`expr ${x} / ${y}` echo &quot;${x} / ${y} = ${val}&quot; ;; *) echo &quot;Unknown oper!&quot; ;;esac 每种情况都是匹配了某个模式的表达式。|用来分割多个模式，)用来结束一个模式序列。第一个匹配上的模式对应的命令将会被执行。*代表任何不匹配以上给定模式的模式。命令块儿之间要用;;分隔。 循环语句循环其实不足为奇。跟其它程序设计语言一样，bash 中的循环也是只要控制条件为真就一直迭代执行的代码块。 Bash 中有四种循环：for，while，until和select。 for循环for与它在 C 语言中的姊妹非常像。看起来是这样： 1234for arg in elem1 elem2 ... elemNdo ### 语句done 在每次循环的过程中，arg依次被赋值为从elem1到elemN。这些值还可以是通配符或者大括号扩展。 当然，我们还可以把for循环写在一行，但这要求do之前要有一个分号，就像下面这样： 1for i in {1..5}; do echo $i; done 还有，如果你觉得for..in..do对你来说有点奇怪，那么你也可以像 C 语言那样使用for，比如： 123for (( i = 0; i &lt; 10; i++ )); do echo $idone 当我们想对一个目录下的所有文件做同样的操作时，for就很方便了。举个例子，如果我们想把所有的.bash文件移动到script文件夹中，并给它们可执行权限，我们的脚本可以这样写： 💻 『示例源码』 12345DIR=/home/zpfor FILE in ${DIR}/*.sh; do mv &quot;$FILE&quot; &quot;${DIR}/scripts&quot;done# 将 /home/zp 目录下所有 sh 文件拷贝到 /home/zp/scripts while循环while循环检测一个条件，只要这个条件为 _真_，就执行一段命令。被检测的条件跟if..then中使用的基元并无二异。因此一个while循环看起来会是这样： 1234while [[ condition ]]do ### 语句done 跟for循环一样，如果我们把do和被检测的条件写到一行，那么必须要在do之前加一个分号。 💻 『示例源码』 1234567891011121314151617### 0到9之间每个数的平方x=0while [[ ${x} -lt 10 ]]; do echo $((x * x)) x=$((x + 1))done# Output:# 0# 1# 4# 9# 16# 25# 36# 49# 64# 81 until循环until循环跟while循环正好相反。它跟while一样也需要检测一个测试条件，但不同的是，只要该条件为 假 就一直执行循环： 💻 『示例源码』 1234567891011x=0until [[ ${x} -ge 5 ]]; do echo ${x} x=`expr ${x} + 1`done# Output:# 0# 1# 2# 3# 4 select循环select循环帮助我们组织一个用户菜单。它的语法几乎跟for循环一致： 1234select answer in elem1 elem2 ... elemNdo ### 语句done select会打印elem1..elemN以及它们的序列号到屏幕上，之后会提示用户输入。通常看到的是$?（PS3变量）。用户的选择结果会被保存到answer中。如果answer是一个在1..N之间的数字，那么语句会被执行，紧接着会进行下一次迭代 —— 如果不想这样的话我们可以使用break语句。 💻 『示例源码』 1234567891011121314#!/usr/bin/env bashPS3=&quot;Choose the package manager: &quot;select ITEM in bower npm gem pipdoecho -n &quot;Enter the package name: &quot; &amp;&amp; read PACKAGEcase ${ITEM} in bower) bower install ${PACKAGE} ;; npm) npm install ${PACKAGE} ;; gem) gem install ${PACKAGE} ;; pip) pip install ${PACKAGE} ;;esacbreak # 避免无限循环done 这个例子，先询问用户他想使用什么包管理器。接着，又询问了想安装什么包，最后执行安装操作。 运行这个脚本，会得到如下输出： 1234567$ ./my_script1) bower2) npm3) gem4) pipChoose the package manager: 2Enter the package name: gitbook-cli break 和 continue如果想提前结束一个循环或跳过某次循环执行，可以使用 shell 的break和continue语句来实现。它们可以在任何循环中使用。 break语句用来提前结束当前循环。 continue语句用来跳过某次迭代。 💻 『示例源码』 12345678910# 查找 10 以内第一个能整除 2 和 3 的正整数i=1while [[ ${i} -lt 10 ]]; do if [[ $((i % 3)) -eq 0 ]] &amp;&amp; [[ $((i % 2)) -eq 0 ]]; then echo ${i} break; fi i=`expr ${i} + 1`done# Output: 6 💻 『示例源码』 12345678910111213# 打印10以内的奇数for (( i = 0; i &lt; 10; i ++ )); do if [[ $((i % 2)) -eq 0 ]]; then continue; fi echo ${i}done# Output:# 1# 3# 5# 7# 9 函数bash 函数定义语法如下： 1234[ function ] funname [()] { action; [return int;]} 💡 说明： 函数定义时，function 关键字可有可无。 函数返回值 - return 返回函数返回值，返回值类型只能为整数（0-255）。如果不加 return 语句，shell 默认将以最后一条命令的运行结果，作为函数返回值。 函数返回值在调用该函数后通过 $? 来获得。 所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至 shell 解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。 💻 『示例源码』 1234567891011121314151617181920212223242526272829303132#!/usr/bin/env bashcalc(){ PS3=&quot;choose the oper: &quot; select oper in + - \\* / # 生成操作符选择菜单 do echo -n &quot;enter first num: &quot; &amp;&amp; read x # 读取输入参数 echo -n &quot;enter second num: &quot; &amp;&amp; read y # 读取输入参数 exec case ${oper} in &quot;+&quot;) return $((${x} + ${y})) ;; &quot;-&quot;) return $((${x} - ${y})) ;; &quot;*&quot;) return $((${x} * ${y})) ;; &quot;/&quot;) return $((${x} / ${y})) ;; *) echo &quot;${oper} is not support!&quot; return 0 ;; esac break done}calcecho &quot;the result is: $?&quot; # $? 获取 calc 函数返回值 执行结果： 123456789$ ./function-demo.sh1) +2) -3) *4) /choose the oper: 3enter first num: 10enter second num: 10the result is: 100 位置参数位置参数是在调用一个函数并传给它参数时创建的变量。 位置参数变量表： 变量 描述 $0 脚本名称 $1 … $9 第 1 个到第 9 个参数列表 ${10} … ${N} 第 10 个到 N 个参数列表 $* or $@ 除了$0外的所有位置参数 $# 不包括$0在内的位置参数的个数 $FUNCNAME 函数名称（仅在函数内部有值） 💻 『示例源码』 1234567891011121314151617181920212223#!/usr/bin/env bashx=0if [[ -n $1 ]]; then echo &quot;第一个参数为：$1&quot; x=$1else echo &quot;第一个参数为空&quot;fiy=0if [[ -n $2 ]]; then echo &quot;第二个参数为：$2&quot; y=$2else echo &quot;第二个参数为空&quot;fiparamsFunction(){ echo &quot;函数第一个入参：$1&quot; echo &quot;函数第二个入参：$2&quot;}paramsFunction ${x} ${y} 执行结果： 1234567891011$ ./function-demo2.sh第一个参数为空第二个参数为空函数第一个入参：0函数第二个入参：0$ ./function-demo2.sh 10 20第一个参数为：10第二个参数为：20函数第一个入参：10函数第二个入参：20 执行 ./variable-demo4.sh hello world ，然后在脚本中通过 $1、$2 … 读取第 1 个参数、第 2 个参数。。。 函数处理参数另外，还有几个特殊字符用来处理参数： 参数处理 说明 $# 返回参数个数 $* 返回所有参数 $$ 脚本运行的当前进程 ID 号 $! 后台运行的最后一个进程的 ID 号 $@ 返回所有参数 $- 返回 Shell 使用的当前选项，与 set 命令功能相同。 $? 函数返回值 💻 『示例源码』 12345678910111213141516171819202122232425262728293031323334runner() { return 0}name=zpparamsFunction(){ echo &quot;函数第一个入参：$1&quot; echo &quot;函数第二个入参：$2&quot; echo &quot;传递到脚本的参数个数：$#&quot; echo &quot;所有参数：&quot; printf &quot;+ %s\\n&quot; &quot;$*&quot; echo &quot;脚本运行的当前进程 ID 号：$$&quot; echo &quot;后台运行的最后一个进程的 ID 号：$!&quot; echo &quot;所有参数：&quot; printf &quot;+ %s\\n&quot; &quot;$@&quot; echo &quot;Shell 使用的当前选项：$-&quot; runner echo &quot;runner 函数的返回值：$?&quot;}paramsFunction 1 &quot;abc&quot; &quot;hello, \\&quot;zp\\&quot;&quot;# Output:# 函数第一个入参：1# 函数第二个入参：abc# 传递到脚本的参数个数：3# 所有参数：# + 1 abc hello, &quot;zp&quot;# 脚本运行的当前进程 ID 号：26400# 后台运行的最后一个进程的 ID 号：# 所有参数：# + 1# + abc# + hello, &quot;zp&quot;# Shell 使用的当前选项：hB# runner 函数的返回值：0 Shell 扩展扩展 发生在一行命令被分成一个个的 记号（tokens） 之后。换言之，扩展是一种执行数学运算的机制，还可以用来保存命令的执行结果，等等。 感兴趣的话可以阅读关于 shell 扩展的更多细节。 大括号扩展大括号扩展让生成任意的字符串成为可能。它跟 文件名扩展 很类似，举个例子： 1echo beg{i,a,u}n ### begin began begun 大括号扩展还可以用来创建一个可被循环迭代的区间。 12echo {0..5} ### 0 1 2 3 4 5echo {00..8..2} ### 00 02 04 06 08 命令置换命令置换允许我们对一个命令求值，并将其值置换到另一个命令或者变量赋值表达式中。当一个命令被``或$()包围时，命令置换将会执行。举个例子： 12345now=`date +%T`### ornow=$(date +%T)echo $now ### 19:08:26 算数扩展在 bash 中，执行算数运算是非常方便的。算数表达式必须包在$(( ))中。算数扩展的格式为： 12result=$(( ((10 + 5*3) - 7) / 2 ))echo $result ### 9 在算数表达式中，使用变量无需带上$前缀： 12345x=4y=7echo $(( x + y )) ### 11echo $(( ++x + y++ )) ### 12echo $(( x + y )) ### 13 单引号和双引号单引号和双引号之间有很重要的区别。在双引号中，变量引用或者命令置换是会被展开的。在单引号中是不会的。举个例子： 12echo &quot;Your home: $HOME&quot; ### Your home: /Users/&lt;username&gt;echo 'Your home: $HOME' ### Your home: $HOME 当局部变量和环境变量包含空格时，它们在引号中的扩展要格外注意。随便举个例子，假如我们用echo来输出用户的输入： 123INPUT=&quot;A string with strange whitespace.&quot;echo $INPUT ### A string with strange whitespace.echo &quot;$INPUT&quot; ### A string with strange whitespace. 调用第一个echo时给了它 5 个单独的参数 —— $INPUT 被分成了单独的词，echo在每个词之间打印了一个空格。第二种情况，调用echo时只给了它一个参数（整个$INPUT 的值，包括其中的空格）。 来看一个更严肃的例子： 123FILE=&quot;Favorite Things.txt&quot;cat $FILE ### 尝试输出两个文件: `Favorite` 和 `Things.txt`cat &quot;$FILE&quot; ### 输出一个文件: `Favorite Things.txt` 尽管这个问题可以通过把 FILE 重命名成Favorite-Things.txt来解决，但是，假如这个值来自某个环境变量，来自一个位置参数，或者来自其它命令（find, cat, 等等）呢。因此，如果输入 可能 包含空格，务必要用引号把表达式包起来。 流和重定向Bash 有很强大的工具来处理程序之间的协同工作。使用流，我们能将一个程序的输出发送到另一个程序或文件，因此，我们能方便地记录日志或做一些其它我们想做的事。 管道给了我们创建传送带的机会，控制程序的执行成为可能。 学习如何使用这些强大的、高级的工具是非常非常重要的。 输入、输出流Bash 接收输入，并以字符序列或 字符流 的形式产生输出。这些流能被重定向到文件或另一个流中。 有三个文件描述符： 代码 描述符 描述 0 stdin 标准输入 1 stdout 标准输出 2 stderr 标准错误输出 重定向重定向让我们可以控制一个命令的输入来自哪里，输出结果到什么地方。这些运算符在控制流的重定向时会被用到： Operator Description &gt; 重定向输出 &amp;&gt; 重定向输出和错误输出 &amp;&gt;&gt; 以附加的形式重定向输出和错误输出 &lt; 重定向输入 &lt;&lt; Here 文档 语法 &lt;&lt;&lt; Here 字符串 以下是一些使用重定向的例子： 1234567891011### ls的结果将会被写到list.txt中ls -l &gt; list.txt### 将输出附加到list.txt中ls -a &gt;&gt; list.txt### 所有的错误信息会被写到errors.txt中grep da * 2&gt; errors.txt### 从errors.txt中读取输入less &lt; errors.txt /dev/null 文件如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null： 1$ command &gt; /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。 如果希望屏蔽 stdout 和 stderr，可以这样写： 1$ command &gt; /dev/null 2&gt;&amp;1 Debugshell 提供了用于 debug 脚本的工具。 如果想采用 debug 模式运行某脚本，可以在其 shebang 中使用一个特殊的选项： 1#!/bin/bash options options 是一些可以改变 shell 行为的选项。下表是一些可能对你有用的选项： Short Name Description -f noglob 禁止文件名展开（globbing） -i interactive 让脚本以 交互 模式运行 -n noexec 读取命令，但不执行（语法检查） -t — 执行完第一条命令后退出 -v verbose 在执行每条命令前，向stderr输出该命令 -x xtrace 在执行每条命令前，向stderr输出该命令以及该命令的扩展参数 举个例子，如果我们在脚本中指定了-x例如： 12345#!/bin/bash -xfor (( i = 0; i &lt; 3; i++ )); do echo $idone 这会向stdout打印出变量的值和一些其它有用的信息： 123456789101112131415$ ./my_script+ (( i = 0 ))+ (( i &lt; 3 ))+ echo 00+ (( i++ ))+ (( i &lt; 3 ))+ echo 11+ (( i++ ))+ (( i &lt; 3 ))+ echo 22+ (( i++ ))+ (( i &lt; 3 )) 有时我们值需要 debug 脚本的一部分。这种情况下，使用set命令会很方便。这个命令可以启用或禁用选项。使用-启用选项，+禁用选项： 💻 『示例源码』 123456789101112131415161718192021222324# 开启 debugset -xfor (( i = 0; i &lt; 3; i++ )); do printf ${i}done# 关闭 debugset +x# Output:# + (( i = 0 ))# + (( i &lt; 3 ))# + printf 0# 0+ (( i++ ))# + (( i &lt; 3 ))# + printf 1# 1+ (( i++ ))# + (( i &lt; 3 ))# + printf 2# 2+ (( i++ ))# + (( i &lt; 3 ))# + set +xfor i in {1..5}; do printf ${i}; doneprintf &quot;\\n&quot;# Output: 12345 资源 awesome-shell - shell 资源列表 awesome-bash - bash 资源列表 bash-handbook bash-guide - bash 基本用法指南 bash-it - 为你日常使用、开发以及维护 shell 脚本和自定义命令提供了一个可靠的框架 dotfiles.github.io - 上面有 bash 和其它 shell 的各种 dotfiles 集合以及 shell 框架的链接 Runoob Shell 教程 shellcheck - 一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。 最后，Stack Overflow 上 bash 标签下有很多你可以学习的问题，当你遇到问题时，也是一个提问的好地方。 https://github.com/dunwu/blog/blob/master/source/_posts/coding/shell.md","link":"/2017/11/17/linux/shell/"}],"tags":[{"name":"工程化","slug":"工程化","link":"/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"shell","slug":"shell","link":"/tags/shell/"}],"categories":[{"name":"工程化","slug":"工程化","link":"/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"}]}