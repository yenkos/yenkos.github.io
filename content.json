{"pages":[],"posts":[{"title":"CSS 变量及其应用","text":"基本介绍自定义属性（有时候也被称作CSS变量或者级联变量）是由CSS作者定义的，它包含的值可以在整个文档中重复使用。由自定义属性标记设定值（比如： **--main-color: black;**），由var() 函数来获取值（比如： color: **var(--main-color)**;）复杂的网站都会有大量的CSS代码，通常也会有许多重复的值。举个例子，同样一个颜色值可能在成千上百个地方被使用到，如果这个值发生了变化，需要全局搜索并且一个一个替换（很麻烦哎～）。自定义属性在某个地方存储一个值，然后在其他许多地方引用它。另一个好处是语义化的标识。比如，--main-text-color 会比 #00ff00 更易理解，尤其是这个颜色值在其他上下文中也被使用到。自定义属性受级联的约束，并从其父级继承其值。 与sass less 变量的区别 sass命名是$color，less命名是@color，css命名是–color。 读取css变量，需要使用val()方法，sass和less可以直接使用。 css最大优势在于不需要编译，在运行时可以随时修改，同时应用到上下文。缺点是不兼容ie浏览器。 基本用法声明一个自定义属性，属性名需要以两个减号（--）开始，属性值则可以是任何有效的CSS值。和其他属性一样，自定义属性也是写在规则集之内的，如下： 123element { --main-bg-color: brown;} 注意，规则集所指定的选择器定义了自定义属性的可见作用域。通常的最佳实践是定义在根伪类 :root 下，这样就可以在HTML文档的任何地方访问到它了： 123:root { --main-bg-color: brown;} 然而这条规则不是绝对的，如果有理由去限制你的自定义属性，那么就应该限制。**注意：自定义属性名是大小写敏感的，--my-color 和 --My-color 会被认为是两个不同的自定义属性。如前所述，使用一个局部变量时用 var() 函数包裹以表示一个合法的属性值： 123element { background-color: var(--main-bg-color);} ### 使用自定义属性的第一步我们从这个简单的CSS代码开始，它将相同的颜色应用在了不同class的元素上： 12345678910111213141516171819202122232425262728293031.one { color: white; background-color: brown; margin: 10px; width: 50px; height: 50px; display: inline-block;}.two { color: white; background-color: black; margin: 10px; width: 150px; height: 70px; display: inline-block;}.three { color: white; background-color: brown; margin: 10px; width: 75px;}.four { color: white; background-color: brown; margin: 10px; width: 100px;}.five { background-color: brown;} 应用在如下HTML上： 123456&lt;div&gt; &lt;div class=&quot;one&quot;&gt;1:&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;2: Text &lt;span class=&quot;five&quot;&gt;5 - more text&lt;/span&gt;&lt;/div&gt; &lt;input class=&quot;three&quot;&gt; &lt;textarea class=&quot;four&quot;&gt;4: Lorem Ipsum&lt;/textarea&gt;&lt;/div&gt; 其呈现是：注意到在CSS代码中的重复：背景色 brown 被多处设置。对于一些CSS声明，是可以在级联关系更高的位置设置，通过CSS继承自然地解决这个重复的问题。但在一般项目中，是不可能通过这样的方式去解决。通过在 :root 伪类上设置自定义属性，然后在整个文档需要的地方使用，可以减少这样的重复性： 12345678910111213141516171819202122232425262728293031323334:root { --main-bg-color: brown;}.one { color: white; background-color: var(--main-bg-color); margin: 10px; width: 50px; height: 50px; display: inline-block;}.two { color: white; background-color: black; margin: 10px; width: 150px; height: 70px; display: inline-block;}.three { color: white; background-color: var(--main-bg-color); margin: 10px; width: 75px;}.four { color: white; background-color: var(--main-bg-color); margin: 10px; width: 100px;}.five { background-color: var(--main-bg-color);} 这里呈现的结果和前面的例子是一致的，但允许对所需属性值进行一个规范的声明。### 自定义属性的继承性自定义属性会继承。这意味着如果在一个给定的元素上，没有为这个自定义属性设置值，在其父元素上的值会被使用。看这一段HTML： 123456&lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;two&quot;&gt; &lt;div class=&quot;three&quot;&gt;&lt;/div&gt; &lt;div class=&quot;four&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 配套的CSS： 123456.two { --test: 10px;}.three { --test: 2em;} 在这个情况下， var(--test) 的结果分别是： 对于元素 class=&quot;two&quot; ：10px 对于元素 class=&quot;three&quot; ：2em 对于元素 class=&quot;four&quot; ：10px （继承自父属性） 对于元素 class=&quot;one&quot; ：_非法值_，会变成自定义属性的默认值 注意，这些是自定义属性，并不是你在其他编程语言中遇到的实际的变量。这些值仅当需要的时候才会计算，而并不会按其他规则进行保存。比如，你不能为元素设置一个属性，然后让它从兄弟或旁支子孙规则上获取值。属性仅用于匹配当前选择器及其子孙，这和通常的CSS是一样的。### 自定义属性备用值用 var() 函数可以定义多个备用值(fallback value)，当给定值未定义时将会用备用值替换。这对于 Custom Elements 和 Shadow DOM 都很有用。备用值并不是用于实现浏览器兼容性的。如果浏览器不支持CSS自定义属性，备用值也没什么用。它仅对支持CSS自定义属性的浏览器提供了一个备份机制，该机制仅当给定值未定义或是无效值的时候生效。函数的第一个参数是自定义属性的名称。如果提供了第二个参数，则表示备用值，当自定义属性值无效时生效。第二个参数可以嵌套，但是不能继续平铺展开下去了，例如： 123456789.two { color: var(--my-var, red); /* Red if --my-var is not defined */}.three { background-color: var(--my-var, var(--my-background, pink)); /* pink if --my-var and --my-background are not defined */}.three { background-color: var(--my-var, --my-background, pink); /* Invalid: &quot;--my-background, pink&quot; */} 第二个例子展示了如何处理一个以上的 fallback。该技术可能会导致性能问题，因为它花了更多的时间在处理这些变量上。注意：像自定义属性这些 fallback 语法允许使用逗号。比如 var(--foo, red, blue) 定义了一个 red, blue 的备用值——从第一个逗号到最后的全部内容，都会被作为备用值的一部分。### 有效性和值传统的CSS概念里，有效性和属性是绑定的，这对自定义属性来说并不适用。当自定义属性值被解析，浏览器不知道它们什么时候会被使用，所以必须认为这些值都是_有效的_。不幸的是，即便这些值是有效的，但当通过 var() 函数调用时，它在特定上下文环境下也可能不会奏效。属性和自定义变量会导致无效的CSS语句，这引入了一个新的概念：_计算时有效性_。### 无效变量会导致什么？当浏览器遇到无效的 var() 时，会使用继承值或初始值代替。考虑如下代码： 1&lt;p&gt;This paragraph is initial black.&lt;/p&gt; 123:root { --text-color: 16px; }p { color: blue; }p { color: var(--text-color); } 毫不意外，浏览器将 --text-color 的值替换给了 var(--text-color)，但是 16px 并不是 color 的合法属性值。代换之后，该属性不会产生任何作用。浏览器会执行如下两个步骤： 检查属性 color 是否为继承属性。是，但是 &lt;p&gt; 没有任何父元素定义了 color 属性。转到下一步。 将该值设置为它的默认初始值，比如 black。Result 段落颜色并不是蓝色，因为无效代换导致了它被替换成了默认初始值的黑色。如果你直接写n color: 16px 的话，则会导致语法错误，而前面的定义则会生效（段落显示为蓝色）。注意：当CSS属性-值对中存在语法错误，该行则会被忽略。然而如果自定义属性的值无效，它并不会被忽略，从而会导致该值被覆盖为默认值。### JavaScript 中的值在 JavaScript 中获取或者修改 CSS 变量和操作普通 CSS 属性是一样的： 123456// 获取一个 Dom 节点上的 CSS 变量element.style.getPropertyValue(&quot;--my-var&quot;);// 获取任意 Dom 节点上的 CSS 变量getComputedStyle(element).getPropertyValue(&quot;--my-var&quot;);// 修改一个 Dom 节点上的 CSS 变量element.style.setProperty(&quot;--my-var&quot;, jsVar + 4); 应用：全局样式，定义主题，快速切换。实现黑夜模式深色模式为目前网络发展的一大趋势，可以看到大量的网站为了提高网站的体验都添加了深色模式。深色模式在光线不足的情况下看起来不会那么刺眼，能够很好的保护我们的眼睛。在这边文章中主要讲如何使用CSS和JS实现深色模式和浅色模式的任意切换### 分析需求假设有这么一个页面，我们需要自由切换深色模式和浅色模式。那么就需要在不同模式使用不同的css，这里可以通过两种方式一种是直接引入不同的css文件，另外一种通过更改css变量值的方式进行更改样式，下面是浅色模式的截图### 具体实现首先定义浅色模式的变量名和变量值 1234567891011:root { --primary-bg: #eee; --primary-fg: #000; --secondary-bg: #ddd; --secondary-fg: #555; --primary-btn-bg: #000; --primary-btn-fg: #fff; --secondary-btn-bg: #ff0000; --secondary-btn-fg: #ffff00;}复制代码 当切换场景的时候需要更改css变量的值，更改如下: 1234567891011:root { --primary-bg: #282c35; --primary-fg: #fff; --secondary-bg: #1e2129; --secondary-fg: #aaa; --primary-btn-bg: #ddd; --primary-btn-fg: #222; --secondary-btn-bg: #780404; --secondary-btn-fg: #baba6a;}复制代码 可以看到当切换到深色模式的时候，变量使用了更加暗的颜色，从而实现深色模式### 更改css如何切换到暗模式有多种解决方法，在这里我们使用媒体查询，prefers-color-scheme这个媒体查询能够获取到用户的系统是否切换到了深色主题，具体如下: 1234567891011121314@media (prefers-color-scheme: dark) { :root { --primary-bg: #282c35; --primary-fg: #fff; --secondary-bg: #1e2129; --secondary-fg: #aaa; --primary-btn-bg: #ddd; --primary-btn-fg: #222; --secondary-btn-bg: #780404; --secondary-btn-fg: #baba6a; --image-opacity: 0.85; }}复制代码 如果希望用户可以通过选择系统的设置来切换浅色模式还是深色模式，那么上面这种方式就足够了。浏览的网站能够通过系统设置选择不同的样式但是上面这种方式存在一个问题，就是用户希望这个页面的模式不要跟随系统配置的更改而更改。用户可以主动更改网站的模式，那么上面这种方式就不合适了 手动选择模式思路就是通过控制js来给元素添加不同的class，不同的class拥有不同的样式。首先添加在html中添加一个按钮用于切换不同的模式 12345&lt;button id=&quot;toggle-button&quot;&gt;toggle&lt;/button&gt;&lt;script&gt; const toggleButton = document.querySelector('#toggle-button')&lt;/script&gt;复制代码 然后需要地方存储用户的偏好设置，这里使用localStorage来存储用户的选择。然后给按钮添加事件用于切换主题，下面是具体的代码 1234567891011121314151617const toggleButton = document.querySelector('#toggle-button') toggleButton.addEventListener('click', (e) =&gt; { darkMode = localStorage.getItem('theme'); if (darkMode === 'dark') { disableDarkMode(); } else { enableDarkMode(); } }); function enableDarkMode() { localStorage.setItem('theme', 'dark'); } function disableDarkMode() { localStorage.setItem('theme', 'light'); }复制代码 现在我们就可以存储这个用户的偏好设置。然后不同的主题下给body元素添加不同的class，具体如下 123456789function enableDarkMode() { document.body.classList.add(&quot;dark-mode&quot;) localStorage.setItem('theme', 'dark'); } function disableDarkMode() { document.body.classList.remove(&quot;dark-mode&quot;) localStorage.setItem('theme', 'light'); }复制代码 和媒体查询一样，在dark-mode的情况下更改css变量的属性值，具体如下: 123456789101112.dark-mode { --primary-bg: #282c35; --primary-fg: #fff; --secondary-bg: #1e2129; --secondary-fg: #aaa; --primary-btn-bg: #ddd; --primary-btn-fg: #222; --secondary-btn-bg: #780404; --secondary-btn-fg: #baba6a; --image-opacity: 0.85;}复制代码 同时在进入这个页面的时候需要获取到用户的偏好设置，从localStorage中读取 123let darkMode = localStorage.getItem(&quot;theme&quot;)if (darkMode === &quot;dark&quot;) enableDarkMode()复制代码 这次就可以在页面刷新以后仍然拿到用户的偏好设置。","link":"/2020/11/13/CSS/CSS%20%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"},{"title":"package-lock.json的作用","text":"什么是package-lock.json在前端项目根目录里有一个package-lock.json文件，有同学疑惑这个文件是干嘛用，不是已经有一个package文件了吗？这个文件前身是npm-shrinkwrap.json，因为npm的依赖管理非常宽松，一个项目在同一天内都可能会安装到不同版本的依赖包，依赖包的升级可能会给项目带来bug。 这时shrinkwrap就应运而生，但是大家都懒得写，所以npm在5+版本之后，收到yarn.lock的启发，默认会在安装时生成package-loack文件。 举个例子 总结package-lock是用来严格控制版本依赖的。 package-lock.json 详细解析package-lock.json会为npm修改node_modules树或的任何操作自动生成package.json。它描述了生成的确切树，因此无论中间依赖项更新如何，后续安装都可以生成相同的树。该文件旨在提交到源存储库中，并具有多种用途： 描述依赖关系树的单个表示，这样可以确保队友，部署和持续集成安装完全相同的依赖关系。 为用户提供一种工具，使其可以“时间旅行”到以前的状态，node_modules而不必提交目录本身。 为了通过可读的源代码控制差异更好地了解树的变化。 并允许npm跳过以前安装的软件包的重复元数据解析，从而优化安装过程。 关于package-lock.json它的一个关键细节是它无法发布，并且如果在顶级软件包之外的任何地方找到它，它将被忽略。它与共享格式npm-shrinkwrap.json，该文件本质上是相同的文件，但可以发布。除非部署CLI工具或使用发布过程来生产生产软件包，否则不建议这样做。如果软件包的根目录中同时存在package-lock.json和npm-shrinkwrap.json，package-lock.json将被完全忽略。 文件格式name这是程序包锁定的程序包名称。这必须与中的内容匹配 package.json。 version这是程序包锁定的程序包版本。这必须与中的内容匹配 package.json。 lockfileVersion整数版本，1从此文档的版本号开始，在生成this时使用了其语义package-lock.json。 packageIntegrity这是从中创建的子资源完整性值package.json。package.json不应进行任何预处理。子资源完整性字符串可由类似的模块生成 ssri。 preserveSymlinks表示安装是在NODE_PRESERVE_SYMLINKS启用环境变量的情况下完成的 。安装程序应坚持使该属性的值与该环境变量匹配。 dependencies程序包名称到依赖对象的映射。依赖项对象具有以下属性：version这是一个说明符，可唯一标识此程序包，并应可用于获取其新副本。 捆绑的依赖关系：不管来源如何，这都是一个纯粹用于参考目的的版本号。 注册表源：这是一个版本号。（例如，1.2.3） git源：这是一个具有已解决承诺的git说明符。（例如，git+https://example.com/foo/bar#115311855adb0789a0466714ed48a1499ffea97e） http tarball来源：这是tarball的URL。（例如，[https://example.com/example-1.3.0.tgz](https://example.com/example-1.3.0.tgz)） 本地tarball来源：这是tarball的文件URL。（例如file:///opt/storage/example-1.3.0.tgz） 本地链接源：这是链接的文件URL。（例如file:libs/our-module） integrity这是此资源的标准子资源完整性。 对于捆绑的依赖项，无论来源如何，均不包括在内。 对于注册表源，这是integrity注册表提供的，或者如果未提供SHA1 shasum。 对于git源，这是我们从中克隆的特定提交哈希。 对于远程tarball源，这是基于文件SHA512的完整性。 对于本地tarball源：这是基于文件SHA512的完整性字段。 resolved 对于捆绑的依赖项，无论来源如何，均不包括在内。 对于注册表源，这是相对于注册表URL的压缩包的路径。如果tarball URL与注册表URL不在同一服务器上，则这是完整的URL。 bundled如果为true，则为捆绑的依赖关系，并将由父模块安装。安装时，此模块将在提取阶段从父模块中提取，而不是作为单独的依赖项安装。 dev如果为true，则此依赖项仅是顶层模块的开发依赖项，或者是一个传递性依赖项。对于既是顶层的开发依赖关系又是顶层的非开发依赖关系的传递依赖关系的依赖关系，这是错误的。 optional如果为true，则此依赖项仅是顶层模块的可选依赖项，或者是一个传递性依赖项。对于既是顶层的可选依赖关系又是顶层的非可选依赖关系的传递性依赖关系的依赖关系，则为false。即使所有可选依赖项都可以在当前平台上卸载，也应包括在内。 requires这是模块名称到版本的映射。这是此模块所需的所有内容的列表，无论它将安装在何处。版本应通过正常匹配规则匹配我们dependencies或更高级别的依赖关系 。 dependencies此依赖关系的依赖关系，与顶层完全相同。","link":"/2020/11/13/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E4%BB%80%E4%B9%88package-lock.json%20_/"}],"tags":[],"categories":[]}